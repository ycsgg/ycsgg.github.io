<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021.11.15模拟赛</title>
    <url>/2021/11/15/2021-11-15%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>Turned into a moon that always tells the warmth and brightness of the sun</p>
<span id="more"></span>

<h2 id="2021-11-15-模拟赛"><a href="#2021-11-15-模拟赛" class="headerlink" title="2021.11.15 模拟赛"></a>2021.11.15 模拟赛</h2><p>某种意义上的信心赛？</p>
<h3 id="A-最小得分和"><a href="#A-最小得分和" class="headerlink" title="A. 最小得分和"></a>A. 最小得分和</h3><p>想一下应该是二分，因为肯定是取前 $k$ 小个所以二分不能取得最小值</p>
<p>排完序后依次扫可以发现每个合法区间的右端点有单调性，就可以 $O(n)$ 判断</p>
<h3 id="B-礼物"><a href="#B-礼物" class="headerlink" title="B. 礼物"></a>B. 礼物</h3><p>$G \le 16$ 状压，先跑 bfs 预处理出来关键点之间两两最短路</p>
<p>然后状压 dp 转移即可</p>
<h3 id="C-动物游戏"><a href="#C-动物游戏" class="headerlink" title="C. 动物游戏"></a>C. 动物游戏</h3><p>$O(n\times \mathrm{dep})$ 暴力过了，数据真就硬随</p>
<p>考虑深度为 $i$ 的点只需要用到深度为 $i-1$ 的点的信息，所以逐层拓展</p>
<p>每个点会给他到根的每个点的权值乘上一个自己的概率（对于下一层受到影响的点来说）</p>
<p>而每个点的答案就是自己到根上权值的乘积</p>
<p>树剖维护即可</p>
<h3 id="D-药香"><a href="#D-药香" class="headerlink" title="D. 药香"></a>D. 药香</h3><p>树形依赖背包，按 dfs 序转移即可</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>线段树</tag>
        <tag>二分</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.11.10模拟赛</title>
    <url>/2021/11/11/2021-11-10%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>To soar above this world</p>
<span id="more"></span>

<h2 id="2021-11-10-模拟赛"><a href="#2021-11-10-模拟赛" class="headerlink" title="2021.11.10 模拟赛"></a>2021.11.10 模拟赛</h2><h3 id="A-图"><a href="#A-图" class="headerlink" title="A. 图"></a>A. 图</h3><p>显然 $k$ 上限是最短路长度，而且只要按最短路跑出来的分层图赋权即可</p>
<h3 id="B-幂"><a href="#B-幂" class="headerlink" title="B. 幂"></a>B. 幂</h3><p>性价比极高的 80 分做法，枚举括号序列的长度为 $k$ 答案为 $\sum C_{\frac{k}{2}}\binom{n}{k}(n-k)$ $C_i$ 是卡特兰数</p>
<p>100 分做法需要用生成函数解递推式，性价比不高（但是 T4 又不会做，只能做做 T2 划划水这样子）</p>
<p>试图用生成函数凑出来 80 分式子的人都死了.jpg</p>
<p>考虑拼接括号形成的方案，为了不重复，我们钦定每次拼接都是完整括号或者单独的一个 $x$ </p>
<p>设方案数数列的生成函数为 $F(x)$ 则 $F(x)=\sum(x+x^2F(x))^i=\dfrac{1}{1-x-x^2F(x)}$</p>
<p>解出来为 $F(x) = \dfrac{1 - x \pm \sqrt{1 - 2x - 3x^2}}{2x^2}$ 因为 $\lim\limits_{x \to 0}F(x)=1$ 所以应该取符号</p>
<p>带权的方案数 $G(x)$ 类似 <a href="https://ycsgg.github.io/2021/10/07/2021-10-04%E6%A8%A1%E6%8B%9F%E8%B5%9B/">这场的道路</a> 的求法，考虑一个序列会被计算多少次，同样是拼接完整括号，即 $expr(\dots)$ 中 $\dots$ 的方案数</p>
<p>这一部分是 $x^2F(x)G(x)$ 还有拼接一个 $x$ 的方案数 $xF(x)+xG(x)$</p>
<p>解得 $G(x)=(2x)^{-1}\left((1-x)(1-2x-3x^2)^{-\frac{1}{2}}-1\right)$</p>
<p>主要是 $(1-2x-3x^2)^{-\frac{1}{2}}$ 怎么做，考虑解递推式，传统艺能微分表达自身</p>
<p>设 $F=G^{-\frac{1}{2}}$ 微分得到 $F’=-\dfrac{1}{2}G^{-\frac{3}{2}}G’=-\dfrac{1}{2}\dfrac{F}{G}G’$</p>
<p>即 $F’G=-\dfrac{1}{2}FG’$ 解出来得到 $(n + 1) f_{n + 1} - 2n f_n - 3(n - 1)f_{n - 1} = f_n + 3f_{n - 1} $</p>
<p>把剩下的 $(1-x)$ 对应的差分和 $2x$ 对应的除二平移加上就好</p>
<h3 id="C-异或"><a href="#C-异或" class="headerlink" title="C. 异或"></a>C. 异或</h3><p>考虑一个确定的序列什么时候异或值最小，一定出现在排完序的相邻两项中，证明可以逐位对比得到</p>
<p>所以我们只需要排好序一个一个的做，有 $dp_i=\sum dp_j+1(a_i \oplus a_j \ge x)$</p>
<p>发现这个转移其实是在 Trie 树上求子树和，这样复杂度就是 $O(n\log w)$ 的</p>
<h3 id="D-排列"><a href="#D-排列" class="headerlink" title="D. 排列"></a>D. 排列</h3><p>Orz RenaMoe</p>
<p>首先操作 $k$ 次能得到的排列是含有至少 $n-k$ 的上升子串的排列</p>
<p>容斥，枚举长度至少为 $n-k$ 的上升子串有几个</p>
<p>发现这是错的，因为上升子串重叠应该算作一个</p>
<p>贡献为为 $\dfrac{n!}{\prod a_i!}(-1)^{x}$ $x$ 和极长上升子串数量，第一部分是个多重集排列</p>
<p>尝试限制上升子串不能重叠发现非常困难，所以考虑合并容斥系数</p>
<p>设 $f_i$ 表示长度为 $i$ 的串容斥系数是多少，枚举上一个右端点，强制相交，有 $f_i=-\sum\limits_{j=1}^{n-k}f_{i-j}$</p>
<p>于是可以 $dp_i=\sum\limits_{j=1}^{i}dp_{i-j}f_j\dfrac{1}{j!}$</p>
<p>再观察下能够发现当 $i=(n-k)t+1$ 的时候 $f_i=1$ 当 $i=(n-k)t$ 时 $f_i=-1$</p>
<p>所以每次能转移的点只有 $\dfrac{n^2}{n-k}$ 个，总体复杂度就是 $O(n^2\log n)$ 个</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>容斥</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.11.08模拟赛</title>
    <url>/2021/11/08/2021-11-08%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>Wave good-bye to the past When hope and faith have grown so strong and sound</p>
<span id="more"></span>

<h2 id="2021-11-08模拟赛"><a href="#2021-11-08模拟赛" class="headerlink" title="2021.11.08模拟赛"></a>2021.11.08模拟赛</h2><h3 id="A-等差数列"><a href="#A-等差数列" class="headerlink" title="A. 等差数列"></a>A. 等差数列</h3><p>叉疯了</p>
<p>如果没有首项就是在 $\operatorname{lcm}$ 上重合，有了首项可以发现暴力找出来第一个相同的，后面还是 $\operatorname{lcm}$</p>
<p>公差为零啥的一堆情况记得特判…….</p>
<h3 id="B-玩具"><a href="#B-玩具" class="headerlink" title="B. 玩具"></a>B. 玩具</h3><p>先考虑身子肯定得移动过去，所以有 $n-b$ 的代价</p>
<p>而且因为身子不会后退，所以我们可以直接动腿，只算腿的代价</p>
<p>如果现在有个区间上的可停留点数 $\ge L$ 就可以直接移动，记一下腿的最前最后在哪，找到最靠前的能走地方，走一次 $L$ 的代价</p>
<p>前能到最后 $+b-1$ 的地方</p>
<h3 id="C-整除"><a href="#C-整除" class="headerlink" title="C. 整除"></a>C. 整除</h3><p>发现答案长度不是很大，用 string 记录，暴力BFS</p>
<h3 id="D-集合"><a href="#D-集合" class="headerlink" title="D. 集合"></a>D. 集合</h3><p>只会 $O(m\log^2n)$ 的愚蠢做法</p>
<p>拿两个启发式合并的并查集（因为没有启发式合并拿到了90pts ?）</p>
<p>$A$ 集合每个点挂一个 vector 记录每个操作的时间戳和值， $B$ 集合记录覆盖的时间戳</p>
<p>先查询最后的覆盖时间戳，然后查询 $A$ 集合中大于这个时间的加法标记，二分即可</p>
<p>注意每次合并区间其实也是一次类似覆盖的操作，每个点记录一下合并的时间戳，每次当前查询的时间戳要和他取 $\max$</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
  </entry>
  <entry>
    <title>2021.11.07模拟赛</title>
    <url>/2021/11/08/2021-11-07%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>Brighter than tomorrow and yesterday</p>
<span id="more"></span>

<h2 id="2021-11-07-模拟赛"><a href="#2021-11-07-模拟赛" class="headerlink" title="2021.11.07 模拟赛"></a>2021.11.07 模拟赛</h2><h3 id="A-签到题"><a href="#A-签到题" class="headerlink" title="A. 签到题"></a>A. 签到题</h3><p>对比剩下的三道确实蛮签到的（然后看错题浪费一个半小时，最后也没看对 -70 分）</p>
<p>体面很复杂，其实按照题面操作最后会得到一个树形结构，最小公共点就是树上 LCA</p>
<p>所以要支持单点和儿子加，链查</p>
<p>树上前缀和一下变成子树加和单点查，直接树状数组维护即可</p>
<p>注意题目区间的闭 or 开</p>
<h3 id="B-金币"><a href="#B-金币" class="headerlink" title="B. 金币"></a>B. 金币</h3><p>个人觉得挺好的</p>
<p>构造方案的思路走不下去</p>
<p>按照题解的方式将每次称的方案记成一个矩阵，每行代表每袋金币每次放上去多少个，正数放在右边，负数放在左边</p>
<p>列数是固定的，考虑怎么获取答案，如果把每次称量的结果记成向量，正数表示左边重，负数表示右边重</p>
<p>则如果存在唯一的向量与其线性相关我们就能断定他是假的，因为答案与它的变化成正比</p>
<p>而线性相关具有传递性，所以我们选出的向量不能有两个是线性相关的</p>
<p>同时需要满足每列和为 $0$ ，容易发现这总是可行的，若现在的答案重存在向量 $[x_1,x_2,x_3,\dots]$ 翻转第一个分量变成 $[-x_1,x_2,x_3,\dots]$</p>
<p>如果它存在就忽略，否则就加入，这样显然不会破坏原来的性质，对每一个分量都如此操作即可</p>
<p>所以我们只需要计 长度为 $n$ 值域为 $[-k,k]$ 内的向量在线性相关意义下等价类的个数</p>
<p>先选出代表元，发现线性相关的都成倍数关系，故必然仅存在一个各分量 $\gcd$ 为 $1$ 的向量</p>
<p>莫反计数即可 $1+\sum_{i=1}^k\mu(i)\left(\left(2\lfloor\frac ki\rfloor+1\right)^n-1\right)$</p>
<p>$+1$ 是零向量， $-1$ 是不能选全零向量</p>
<h3 id="C-线段树"><a href="#C-线段树" class="headerlink" title="C. 线段树"></a>C. 线段树</h3><p>$all_0(n)=all_0(\lfloor\frac n2\rfloor)+all_0(\lceil\frac n2\rceil)+\lceil\frac n2\rceil pre_0(\lfloor\frac n2\rfloor)+\lfloor\frac n2\rfloor suf_0(\lceil\frac n2\rceil)-1$</p>
<p>$pre_0(n)=pre_0(\lfloor\frac n2\rfloor)+pre_0(\lceil\frac n2\rceil)+\lfloor\frac n2\rfloor-1$</p>
<p>$suf_0(n)=suf_0(\lfloor\frac n2\rfloor)+suf_0(\lceil\frac n2\rceil)+\lceil\frac n2\rceil-1$</p>
<p>$all_1(n)=all_0(1)+\sum_{i=1}^{\lfloor\frac n2\rfloor}all_0(2i)+\sum_{i=2}^{\lceil\frac n2\rceil}all_0(2i-1)$</p>
<p>$=1+\sum_{i=1}^{\lfloor\frac n2\rfloor}\left(2all_0(i)+i\cdot pre_0(i)+i\cdot suf_0(i)-1\right)+\sum_{i=2}^{\lceil\frac n2\rceil}\left(all_0(i-1)+all_0(i)+i\cdot pre_0(i-1)+(i-1)\cdot suf_0(i)-1\right)$</p>
<p>$=2all_1(\lfloor\frac n2\rfloor)+\sum_{i=1}^{\lfloor\frac n2\rfloor}\left(i\cdot pre_0(i)+i\cdot suf_0(i)\right)+2all_1(\lceil\frac n2\rceil)-all_0(\lceil\frac n2\rceil)+\sum_{i=1}^{\lceil\frac n2\rceil}\left(i\cdot pre_0(i)+i\cdot suf_0(i)\right)+\sum_{i=1}^{\lceil\frac n2\rceil}pre_0(i)-\sum_{i=1}^{\lceil\frac n2\rceil}suf_0(i)-(\lceil\frac n2\rceil+1)pre_0(\lceil\frac n2\rceil)-n+1$</p>
<p>$pre_1(n)=\sum_{i=1}^npre_0(i),pre_2(n)=\sum_{i=1}^ni\cdot pre_0(i)$<br>$suf_1(n)=\sum_{i=1}^nsuf_0(i),suf_2(n)=\sum_{i=1}^ni\cdot suf_0(i)$</p>
<p>$pre_1(n)=2pre_1(\lfloor\frac n2\rfloor)+2pre_1(\lceil\frac n2\rceil)-pre_0(\lceil\frac n2\rceil)+\frac 14(n^2-3n-2\lceil\frac n2\rceil)+1$<br>$suf_1(n)=2suf_1(\lfloor\frac n2\rfloor)+2suf_1(\lceil\frac n2\rceil)-suf_0(\lceil\frac n2\rceil)+\frac 14(n^2-3n+2\lceil\frac n2\rceil)$<br>$pre_2(n)=4pre_2(\lfloor\frac n2\rfloor)+4pre_2(\lceil\frac n2\rceil)-(2\lceil\frac n2\rceil+1)pre_0({\lceil\frac n2\rceil})+\frac 1{12}(2n^3-3n^2-5n-6\lceil\frac n2\rceil^2)+1$<br>$suf_2(n)=4suf_2(\lfloor\frac n2\rfloor)+4suf_2(\lceil\frac n2\rceil)-(2\lceil\frac n2\rceil+1)suf_0({\lceil\frac n2\rceil})+\frac 1{12}(2n^3-3n^2-5n+6\lceil\frac n2\rceil^2)$</p>
<p>自行感悟吧</p>
<h3 id="D-泰拉"><a href="#D-泰拉" class="headerlink" title="D. 泰拉"></a>D. 泰拉</h3><p>最小树形图板子题 Tarjan DMST $O(m+n\log m)$ 或者把可并堆变成 $n^2$ 暴力找会更快 $n^2+m$</p>
<p>但是这东西好像没啥人会去学吧</p>
<p>考虑本题的特殊性质</p>
<p>按 $i \to x_i$ 连边，就会形成基环树森林，如果我们拿了一个环上的链，就可以最小代价拿掉整个基环树</p>
<p>拿一个树点就可以拿掉子树里的点，所以我们一旦拿掉一个点，就要拿完它的子树或基环树的所有点</p>
<p>因为没有 $x_i$ 的情况下编号越大越优，所以最优策略是先拿一些点然后拿到 $n$ 点，然后用 $n$ 拿剩下的环上的点最后拿完</p>
<p>而且拿到 $n$ 之前的点的几个段最大编号必然递增，否则调换顺序就会更优</p>
<p>设 $dp_i$ 表示确定了前若干组，当前最后一组的编号最大值为 $i$</p>
<p>预处理每个子树的代价一类的大力转移</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>数学</tag>
        <tag>莫比乌斯反演</tag>
        <tag>最小树形图</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.11.06模拟赛</title>
    <url>/2021/11/06/2021-11-06%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>There’s a way back home </p>
<span id="more"></span>

<h2 id="2021-11-06-模拟赛"><a href="#2021-11-06-模拟赛" class="headerlink" title="2021.11.06 模拟赛"></a>2021.11.06 模拟赛</h2><h3 id="A-下棋"><a href="#A-下棋" class="headerlink" title="A. 下棋"></a>A. 下棋</h3><p>记 $dp_{i,j,x,y}$ 表示 $i$ 个白色棋子，$j$ 个黑色棋子，后缀里白色比黑色最多多 $x$ 个，黑色比白色最多多 $y$ 个</p>
<p>每次枚举放那个棋子</p>
<p>$dp_{i,j,x,y} \to dp_{i+1,j,c+1,\max(0,d-1)}$ 白色棋</p>
<p>$dp_{i,j,x,y} \to dp_{i,j+1,\max(0,c-1),d+1}$ 黑色棋</p>
<h3 id="B-出租车"><a href="#B-出租车" class="headerlink" title="B. 出租车"></a>B. 出租车</h3><p>考虑只需要记录当前到了第几个人，当前目标是 $c$ 剩下三个人目标为 $a,b,c$ 的状态</p>
<p>记忆化搜索</p>
<p>每次枚举送一个人到目的地或者上一个人爆搜即可</p>
<h3 id="C-堆石子"><a href="#C-堆石子" class="headerlink" title="C. 堆石子"></a>C. 堆石子</h3><p>折半爆搜即可，合并的时候拿个 set 找到最大的小于 $m-\mathrm{sum}_S$ 的值合并</p>
<h3 id="D-不稳定的导弹系统"><a href="#D-不稳定的导弹系统" class="headerlink" title="D. 不稳定的导弹系统"></a>D. 不稳定的导弹系统</h3><p>先考虑这个交叉的限制，像是个最小割，大力拆点，把一个点变成横竖两个方向的点，之间连一条正无穷的边</p>
<p>如果一个导弹能攻击肯定是攻击最大的区域，所以把导弹到攻击位置依次连边，然后横边连源点，竖边连汇点</p>
<p>这样最小割就能求出来无交叉最大值</p>
<p>但是问题是如果有一个行/列的最大值不能选不意味着全都不能选，它可以选次大值或者次次大值之类的</p>
<p>考虑我们答案是 $\sum a_i - \operatorname{MinCut}(G)$ 得到的 ($a_i$ 是不考虑交叉选择的点)</p>
<p>我们可以把这个操作整合进 $\operatorname{MinCut}(G)$ 里，具体的，在顺次连接导弹到攻击区域的边的时候流量设置为 $a_i-p$ </p>
<p>$p$ 是当前点的点权，这样的话如果去割到了这个边贡献会是 $+p-a_i$ 就是我们想要的</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>折半搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.11.05模拟赛</title>
    <url>/2021/11/05/2021-11-05%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>I will never go</p>
<span id="more"></span>

<h2 id="2021-11-05-模拟赛"><a href="#2021-11-05-模拟赛" class="headerlink" title="2021.11.05 模拟赛"></a>2021.11.05 模拟赛</h2><h3 id="A-宝藏"><a href="#A-宝藏" class="headerlink" title="A. 宝藏"></a>A. 宝藏</h3><p><del>暴力怎么做，暴力是不是二分，二分，主席树</del></p>
<p>显然有主席树可以 $O(\log n)$ 检验一个位置是否满足条件，再想一下发现位置有单调性，枚举长度顺序检验即可</p>
<p>复杂度 $O(n\log n+q)$</p>
<h3 id="B-寻找道路"><a href="#B-寻找道路" class="headerlink" title="B. 寻找道路"></a>B. 寻找道路</h3><p><del>震惊，无良出题人脚造数据竟使暴力满分</del></p>
<p>先把前导零去掉，剩下的部分先保证长度最短，然后保证 $1$ 的位置尽可能靠后</p>
<p>从 $1$ 开始 BFS 找到所有前导零的点，然后把长度相同的一起转移，先转移 $0$ 再转移 $1$ 的边</p>
<p>注意要一起转移，否则可能会有某个点用 $1$ 更新了原本能用其他点的 $0$ 能更新的点</p>
<h3 id="C-猪国杀"><a href="#C-猪国杀" class="headerlink" title="C. 猪国杀"></a>C. 猪国杀</h3><p>大力计数</p>
<p>首先我们选的卡牌必然是排完序的一个前缀</p>
<p>如果我们能求出来 $i$ 个数字 每个数字不超过 $j$ 总和不超过 $k$ 的方案数 $f_{i,j,k}$</p>
<p>枚举一个数字表示当前选的最大值为 $j$ 有 $i$ 个严格小于他的， $t$ 个等于 $j$ 的，选了 $k$ 个 $j$</p>
<p>方案为 $\sum\limits_{i=0}^{n}\sum\limits_{j=1}^{A}\sum\limits_{k=1}^{n-i}f_{i,j-1,m-kj}\sum\limits_{t=k}^{n-i}(A-j)^{n-u-t}\binom{n}{i}\binom{n-i}{t}$</p>
<p>组合意义比较明显，问题是我们要求的是期望，为啥只用计算方案数？</p>
<p>因为方案数有重复统计的，注意到我们虽然钦定 $j$ 是选的数最大的，但其实他不是</p>
<p>因为 $f_{i,j-1,m-kj}$ 只要求总和小于等于 $m-kj$ 有可能选完之后后面还能选一些数</p>
<p>而对于固定个数列，因为我们对比当前选的数大的数没有限制，所以每个被选的数都当了遍 “最大值”，所以这样正好计算了选的个数次</p>
<h3 id="D-数树"><a href="#D-数树" class="headerlink" title="D. 数树"></a>D. 数树</h3><p><del>树哈希可过</del></p>
<p>考虑状压 设 $dp_{x,S}$ 表示在大树上第 $x$ 个节点儿子对应小树的状态 $S$</p>
<p>考虑如果让 $v$ 对应 $i$ 则 $v$ 的儿子也应对应 $i$ 的儿子</p>
<p>预处理小树儿子集合转移即可，最后需要除去小树自同构的方案数</p>
<p>复杂度 $O(nm^22^{10})$</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>主席树</tag>
        <tag>组合计数</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.11.03模拟赛</title>
    <url>/2021/11/03/2021-11-03%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>Turn into a shooting star that briefly shines but warms up every heart</p>
<span id="more"></span>

<h2 id="2021-11-03模拟赛"><a href="#2021-11-03模拟赛" class="headerlink" title="2021.11.03模拟赛"></a>2021.11.03模拟赛</h2><h3 id="A-质数统计"><a href="#A-质数统计" class="headerlink" title="A. 质数统计"></a>A. 质数统计</h3><p>求出来每个 $\mathrm{cnt}(i)$ 左下前缀和即可，求的过程可以 $O(n \log v)$ 分解质因子做</p>
<h3 id="B-城市规划"><a href="#B-城市规划" class="headerlink" title="B. 城市规划"></a>B. 城市规划</h3><p>二分答案，设 $dp_{i}$ 为 $i$ 号点不修改的最小修改次数，枚举 $j \in [1,i-1]$ 若 $|h_i-h_j| \le (i-j)mid$ 则可以修改 $i-j-1$ 个点达成条件</p>
<p>最后取 $\min(dp_i+n-i) \le k$</p>
<h3 id="C-花环"><a href="#C-花环" class="headerlink" title="C. 花环"></a>C. 花环</h3><p><a href="https://codeforces.com/problemset/problem/280/D">CF280D</a> 的环上版本</p>
<p>考虑序列上费用流怎么做，就是从 $S$ 到每个点流量为 $1$ ，每个点向下一个流量为 $1$ 费用为 $a_i$ 每个点向 $T$ 连边</p>
<p>图很特殊，可以手玩，没一次流肯定是流最大子段和的一段，然后他们的流量取反，所以在原序列上也这么做</p>
<p>线段树维护可以做到 $m\log n$ ，环考虑每次是取最大子段和还是总和减去最小子段和的一段即可</p>
<h3 id="D-密码门"><a href="#D-密码门" class="headerlink" title="D. 密码门"></a>D. 密码门</h3><p>对每一位维护状态，分别是相同/相反/恒0/恒1</p>
<p>线段树维护即可</p>
<p>可以不用带 $\log w$ ，只要对 $0$ 和 $2^k-1$ 维护值就可以得到每一位是 $0/1$ 的状态了</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>线段树</tag>
        <tag>二分</tag>
        <tag>模拟费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>ELMO 2017 Shortlist C3</title>
    <url>/2021/11/01/ELMO-2017-Shortlist-C3/</url>
    <content><![CDATA[<p>To soar above this world</p>
<span id="more"></span>

<h2 id="ELMO-2017-Shortlist-C3-Binary-String"><a href="#ELMO-2017-Shortlist-C3-Binary-String" class="headerlink" title="ELMO 2017 Shortlist C3 Binary String"></a>ELMO 2017 Shortlist C3 Binary String</h2><blockquote>
<p>Consider a finite binary string b with at least 2017 ones. Show that one can insert some plus signs in between pairs of digits such that the resulting sum, when performed in base 2, is equal to a power of two.</p>
</blockquote>
<p>Source : <a href="https://web.evanchen.cc/exams/ELMO-2017-SL.pdf">ELMO-2017-SL</a></p>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof :"></a>Proof :</h3><p>记二进制串里 $1$ 的个数有 $n$ 个，则对于 $n\ge17$ 都成立</p>
<p>所有 $[n,\dfrac{3n}{2}]$ 的数都可以表示出来</p>
<p>先在每一个字符后面都加上加号，这样总和为 $n$ ，每次选取一个单独的 $1$ 取消它后面的加号，要求他后面也是个单独的 $0$ 或 $1$</p>
<p>这样每操作一次会 $-1+2=+1$ 的增量，最坏的情况是 $111111$ 只能操作 $\dfrac{n}{2}$ 次，所以 $[n,\dfrac{3n}{2}]$ 一定可以被表示</p>
<p>那如果存在 $2^{k} \in [n,\dfrac{3n}{2}]$ 就解决了</p>
<p>否则一定有 $2^k+1\le n \le \dfrac{2^{k+2}}{3}$</p>
<p>先切断最后的四个 $1$ ，只考虑前面</p>
<p>那现在我们从左到右划分，找到一个 $1$ 就把他和他后面的两个位置连起来成一组</p>
<p>最终会形成 $g$ 个组的和 $l$ 个未划分的，未划分的只能是末尾有两个 $1$ 所以 $l \le 2$ 而 $g \ge4$ </p>
<p>而一组的和可能是 $7,6,5,4$ 之一，发现不管怎样，这些和都大于等于原来各自贡献 $v$ 的 $2v+1$</p>
<p>所以最终的总和至少是 $2(n-l-4)+g+l+4=2n-l-4+g$</p>
<p>$2(n-l-4)+g$ 是划分的组中 $1$ 的总贡献 $+l+4$ 是未划分的部分，因为 $l \le2$ 且 $g \ge 4$ 总有 $2n-l-4+g \ge 2n-2 \ge2^{k+1}$ </p>
<p>这样只要当和超过了 $2^{k+1}$ 时候就停下，如果刚好等于就结束，否则考虑减去刚划分的组 $1a_1a_2 \rightarrow 4+2a_1+a_3$</p>
<p>和会是 $2^{k+1}-1,2^{k+1}-2,2^{k+1}-3$ 中的一个</p>
<p>如果是 $2^{k+1}-3$ ，那就是把 $1+a_1$ 变成 $1a_1$ 总和增加了 $1$ ，然后拿出来末尾的四个 $1$，把他们的总和从 $4$ 变成 $6$ ，因为 $6 \in [4,\dfrac{3\times4}{2}]$ 所以一定能调整到</p>
<p>如果是 $2^{k+1}-2$ 或者 $2^{k+1}-1$ 直接调整末尾的 $4$ 个 $1$ 即可</p>
<p>实际上这个结论对 $n \le 16$ 的部分也成立</p>
<p>因为 $[1,16]$ 中 $[n,\dfrac{3n}{2}]$ 中没有 $2$ 的整次幂的只有 $5,9,13$ 他们最多能取到 $7,13,15$</p>
<p>如果 $0$ 隔开 $1$ 的段数多于 $\lfloor\dfrac{n}{2}\rfloor$ 就可以多调整几次调整为整次幂</p>
<p>否则的话情况不多，可以暴力枚举</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>MO</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.10.31模拟赛</title>
    <url>/2021/10/31/2021-10-31%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>A pair of wings for me at this moment</p>
<span id="more"></span>

<h2 id="2021-10-21-模拟赛"><a href="#2021-10-21-模拟赛" class="headerlink" title="2021.10.21 模拟赛"></a>2021.10.21 模拟赛</h2><p>题没交上去</p>
<h3 id="A-排队"><a href="#A-排队" class="headerlink" title="A. 排队"></a>A. 排队</h3><p>某种意义的模拟题，线段树暴力维护当然是可以的</p>
<p>但是考虑每次会加入一个空格和删除若干空格，所以 set 一类的东西会更方便些</p>
<p>或者用栈记录空格位置和长度来做到 $O(n)$</p>
<h3 id="B-排序"><a href="#B-排序" class="headerlink" title="B. 排序"></a>B. 排序</h3><p>发现一个区间会被重复统计当且仅当它的左端点是最小值<strong>或</strong>右端点，用单调栈统计下每个数作为最大/最小值能到的左/右端点</p>
<p>然后减去同时满足左右端点的，可以用主席树统计 $\sum\limits_{j=i+1}^{r_i}[l_j \le i]$ 的个数</p>
<h3 id="C-序列问题"><a href="#C-序列问题" class="headerlink" title="C. 序列问题"></a>C. 序列问题</h3><p>发现其实这个填数的过程限制很多，从 $[i,i+b]$ 到 $[i+1,i+b+1]$ 的过程中如果 $a_i$ 只出现了一次，那么 $a_{i+b+1}$ 只能是 $a_i$</p>
<p>否则的话他可以随便放一个数，假设是 $a_k$ 则往后移动 $k$ 位后就又可以随便填</p>
<p>设 $dp_{i}$ 表示填第 $i$ 个格子方案数，则 $dp_i = \sum\limits_{j=i+1}^{i+b}dp_j$ 后缀和优化下可以 $O(n)$</p>
<p>然后考虑前 $b+1$ 个数的状态，枚举第一次出现重复的位置是 $i$ 则另一个可以选择 $b+1-i$ 个位置，其他数有 $(b-1)!$ 的方案，乘上 $dp_{i+b+1}$ 即可</p>
<h3 id="D-序列问题"><a href="#D-序列问题" class="headerlink" title="D. 序列问题"></a>D. 序列问题</h3><p>很好想，每次询问容斥一遍就行</p>
<p>不过不太好写，要注意二元环和枚举的子集恰好构成环一类的</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
  </entry>
  <entry>
    <title>2021.10.29模拟赛</title>
    <url>/2021/10/29/2021-10-29%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>Let out the cries imprisoned for so long</p>
<span id="more"></span>

<h2 id="2021-10-29-模拟赛"><a href="#2021-10-29-模拟赛" class="headerlink" title="2021.10.29 模拟赛"></a>2021.10.29 模拟赛</h2><h3 id="A-破门而入"><a href="#A-破门而入" class="headerlink" title="A. 破门而入"></a>A. 破门而入</h3><p>就是问 $n$ 个不同元素划分成小于等于 $k$ 个环的数量</p>
<p>$O(n^2)$ 递推第一类斯特林数即可</p>
<h3 id="B-破门而入"><a href="#B-破门而入" class="headerlink" title="B. 破门而入"></a>B. 破门而入</h3><p>发现字符串的重复仅出现在 $a\dots a$ 这样的情况下，这样包含 $a$ 和不含 $a$ 反转是一样的</p>
<p>所以最终答案是所有串减去每个字符出现个数两两匹配 即 $\binom{cnt}{2}$</p>
<h3 id="C-奶油蛋糕塔"><a href="#C-奶油蛋糕塔" class="headerlink" title="C. 奶油蛋糕塔"></a>C. 奶油蛋糕塔</h3><p>把奶油当作点就是给边定向找最长路，发现大部分情况下直接找欧拉路选完就行，如果不存在欧拉路就删去最小的边</p>
<p>因为没欧拉路一定是四个奇点，删一个边会变成俩就有了，需要判一下能不能删，因为这个-30pts</p>
<h3 id="D-多重影分身之术"><a href="#D-多重影分身之术" class="headerlink" title="D. 多重影分身之术"></a>D. 多重影分身之术</h3><p>考过原题，然后没看T4，傻了</p>
<p>答案有单调性，直接二分贪心，每个点向左走，拿到左边没拿到的东西之后向右走</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>组合计数</tag>
        <tag>欧拉路径</tag>
      </tags>
  </entry>
  <entry>
    <title>题解-直径和</title>
    <url>/2021/10/26/%E9%A2%98%E8%A7%A3-%E7%9B%B4%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<p>A shoulder for the past</p>
<span id="more"></span>

<h2 id="直径和"><a href="#直径和" class="headerlink" title="直径和"></a>直径和</h2><p>求 $n$ 个点的有标号无根树的直径之和</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>基础思想是找到直径中点拼起来</p>
<p>假设我们能 dp 出来深度为 $j$ 大小为 $i$ 的树和森林的个数</p>
<p>对于奇数的只需要取中间的边就能把树分成两个部分，枚举两个部分的大小即可</p>
<p>偶数需要容斥，取直径的中点，他至少要有两个子树深度为 $\dfrac{d}{2}-1$ 先算存在的，然后枚举大小减去有一个不合法的</p>
<p>具体而言 设 $f_{i,j}$ 表示 $i$ 个点 深度至多为 $j$ 的树个数 ,$g_{i.j}$ 表示 $i$ 个点，深度至多为 $j$ 的森林个数</p>
<p>$h_{i,j}$ 表示 $i$ 个点 深度为 $j$ 的树个数</p>
<p>转移有 $f_{i,j} \gets g_{i,j-1} \times i$ 选定根</p>
<p>$g_{i,j} = \sum \binom{i-1}{k-1} f_{k,j}g_{i-k,j}$ 加上一个新树（注意标号）</p>
<p>奇数直径为 $\sum \binom{n-1}{i-1}h_{i,d}\times h_{n-i,d}$ ，偶数为 $h_{n,d}-\sum \binom{n}{i}h_{i,d-1}\times f_{n-i,d-1}$</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合计数</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题记录</title>
    <url>/2021/10/25/%E6%9D%82%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>Every page of tragedy is thrown away Burned out in the flame</p>
<span id="more"></span>

<p>随便做</p>
<h3 id="Edu111-D-Excellent-Arrays"><a href="#Edu111-D-Excellent-Arrays" class="headerlink" title="Edu111 D. Excellent Arrays"></a>Edu111 D. Excellent Arrays</h3><p>如果在 $i$ 位置上放了一个 $i+a$ 另一个位置是 $j-a$ 和就能满足条件</p>
<p>显然最大值是一半选 $+a$ 一半选 $-a$ 是个组合数</p>
<p>然后讨论下边界，有些地方不能任选</p>
<p><a href="https://codeforces.com/contest/1550/submission/132969888">Submission</a></p>
<h3 id="Edu112-E-Boring-Segments"><a href="#Edu112-E-Boring-Segments" class="headerlink" title="Edu112 E. Boring Segments"></a>Edu112 E. Boring Segments</h3><p>极差的话考虑排序之后双指针，维护全覆盖用线段树即可</p>
<p><a href="https://codeforces.com/contest/1555/submission/132974981">Submission</a></p>
<h3 id="Edu112-D-Say-No-to-Palindromes"><a href="#Edu112-D-Say-No-to-Palindromes" class="headerlink" title="Edu112 D. Say No to Palindromes"></a>Edu112 D. Say No to Palindromes</h3><p> 只有三个字符的无回文子串只能是 $abc$ 这样的排列，一共 $3!$ 种，每种都试一下做个前缀和即可</p>
<p><a href="https://codeforces.com/contest/1555/submission/132983064">Submission</a></p>
<h3 id="Edu112-F-Good-Graph"><a href="#Edu112-F-Good-Graph" class="headerlink" title="Edu112 F. Good Graph"></a>Edu112 F. Good Graph</h3><p>考虑如果现在是一个好图，加入一个新边的影响，如果他连接了两个连通块肯定可以加</p>
<p>否则需要考虑生成树，首先需要保证异或和为 $1$ ，然后需要保证树上 $u \to v$ 的路径都不是其他环</p>
<p>因为如果有环相交构成的大环就是 $0$ 了，这个可以给边打标记，因为每个边仅被访问一次，所以直接树状数组大力加</p>
<p><a href="https://codeforces.com/contest/1555/submission/133055595">Submission</a></p>
<h3 id="CF721-Div2-D-MEX-Tree"><a href="#CF721-Div2-D-MEX-Tree" class="headerlink" title="CF721 Div2 D. MEX Tree"></a>CF721 Div2 D. MEX Tree</h3><p>挺好想的，不太好写，$\operatorname{mex}=k$ 的肯定是选择了 $[0,k-1]$ 的一条链加上不包含 $k$ 的某些点</p>
<p>找链可以直接跳上去拼接，但是去掉包含 $k$ 的点需要巨大多分类讨论，为了避免讨论可以差分一下，只用找包含 $[0,k]$ 的路径</p>
<p><a href="https://codeforces.com/contest/1527/submission/133119317">Submission</a></p>
<h3 id="CF708-Div2-E2-Square-free-division"><a href="#CF708-Div2-E2-Square-free-division" class="headerlink" title="CF708 Div2 E2. Square-free division"></a>CF708 Div2 E2. Square-free division</h3><p>暴力 $dp_{i,j}$ 表示前 $i$ 个修改了 $j$ 次的最小段，每次枚举前面的位置是 $O(n^2k)$ 的</p>
<p>可以发现，能取的话肯定是取最靠前的最优，所以预处理 $(r,i)$ 表示点 $r$ 修改 $i$ 次最左边的位置即可 $O(nk^2)$</p>
<p><a href="https://codeforces.com/contest/1497/submission/133129172">Submission</a></p>
<h3 id="Edu109-E-Assimilation-IV"><a href="#Edu109-E-Assimilation-IV" class="headerlink" title="Edu109 E. Assimilation IV"></a>Edu109 E. Assimilation IV</h3><p>大降智<del>少推式子多动脑子</del></p>
<p>考虑每个点的概率，共 $n!$ 种可能，被选到的是排列中至少有一个 $i$ 使得 $i+a_i \ge n$ 发现没啥好办法统计…</p>
<p>补集转化，一个都没有就需要第 $n$ 位至少是 $2$ 第 $n-1$ 位至少是 $3$ </p>
<p>直接乘起来统计即可</p>
<p><a href="https://codeforces.com/contest/1525/submission/133146870">Submission</a></p>
<h3 id="Edu109-C-Robot-Collisions"><a href="#Edu109-C-Robot-Collisions" class="headerlink" title="Edu109 C. Robot Collisions"></a>Edu109 C. Robot Collisions</h3><p>只能在整数值相交意味着可以奇偶分开处理，每次相撞必然是里的最近的 LR 相撞</p>
<p>形如 LLRRLRLRLLLRL 的序列可以转换成括号序列，每次匹配的括号相撞，剩余的括号到了边界后反转后匹配</p>
<p><a href="https://codeforces.com/contest/1525/submission/133155855">Submission</a></p>
<h3 id="Edu113-D-Inconvenient-Pairs"><a href="#Edu113-D-Inconvenient-Pairs" class="headerlink" title="Edu113 D. Inconvenient Pairs"></a>Edu113 D. Inconvenient Pairs</h3><p>距离不等于曼哈顿距离的必然不在十字交叉口</p>
<p>考虑在横线方向上的答案 两个点不等于曼哈顿距离的一定处于两个不同的横线上，并且中间没有竖线，开个 map 统计即可</p>
<p><a href="https://codeforces.com/contest/1569/submission/133226359">Submission</a></p>
<h3 id="ABC224-F-Problem-where-s-Separate-Digits"><a href="#ABC224-F-Problem-where-s-Separate-Digits" class="headerlink" title="ABC224 F. Problem where +s Separate Digits"></a>ABC224 F. Problem where +s Separate Digits</h3><p>考虑每一位 $x$ 的贡献，如果他在从后往前数第 $k$ 个，它可以成为第 $[1,k-1]$ 位数，贡献分别为 $x\times10^i$ </p>
<p>他成为第 $i$ 位的方案数是自己后面 $i$ 位都没有 $+$ 的方案，总方案为 $(\frac{1}{2})^{n-1}$ 这种方案占比为 $(\frac{1}{2})^{i}$ 需要注意因为最后不能放加号，所以他贡献为 $x\times 10^{k-1}$ 的方案应该是是 $(\frac{1}{2})^{k-1}$ </p>
<p><a href="https://atcoder.jp/contests/abc224/submissions/26843811">Submission</a></p>
<h3 id="AGC035D-Add-and-Remove"><a href="#AGC035D-Add-and-Remove" class="headerlink" title="AGC035D Add and Remove"></a>AGC035D Add and Remove</h3><p>发现 $a_1$ 和 $a_n$ 没意义，一定只贡献一次</p>
<p>剩下的考虑计算每个元素对答案的贡献次数</p>
<p>反着进行这个过程，在 $a_i,a_{i+1}$ 种插入一个数，若 $a_i$ 被算了 $k_i$ 次这个数会被算 $k_i+k_{i+1}$ 次</p>
<p>反着推，设 $dp_{l,r,m,n}$ 表示第 $l$ 个算了 $m$ 次 第 $r$ 个算了 $n$ 次的最小贡献</p>
<p>有转移 $dp_{l,r,m,n} = \min(dp_{l,k-1,m,m+n}+dp_{k+1,r,m+n,n} +(m+n)a_i)$</p>
<p>状态上界是 $2^n$</p>
<p>DFS 做就行</p>
<h3 id="SPOJ-PERIODNI"><a href="#SPOJ-PERIODNI" class="headerlink" title="SPOJ PERIODNI"></a>SPOJ PERIODNI</h3><p>分成多个矩形后每个矩形块可以独立DP然后合并</p>
<p>分成矩形这个过程就是在笛卡尔树上做DP，设 $dp_{i,j}$ 是第 $i$ 个子树里放了 $j$ 个数的方案数，然后合并子树的方案后计算当前矩形的方案即可</p>
<h3 id="CF501-Div3-F-Bracket-Substring"><a href="#CF501-Div3-F-Bracket-Substring" class="headerlink" title="CF501 Div3 F. Bracket Substring"></a>CF501 Div3 F. Bracket Substring</h3><p>设 $dp_{i,j,k}$ 表示当前是第 $i$ 位，栈高 $j$ ，匹配到了子串的第 $k$ 位，用 KMP 预处理一下匹配即可 $O(n^3)$</p>
<h3 id="CF-Edu-114"><a href="#CF-Edu-114" class="headerlink" title="CF Edu 114"></a>CF Edu 114</h3><p>VP了一场，卡在E的分类讨论了</p>
<h4 id="A-C"><a href="#A-C" class="headerlink" title="A~C"></a>A~C</h4><p>略</p>
<h4 id="D-The-Strongest-Build"><a href="#D-The-Strongest-Build" class="headerlink" title="D. The Strongest Build"></a>D. The Strongest Build</h4><p>爆搜题，不知道为啥看错题以为最后的构造要升序卡了一会儿</p>
<p>发现 $n$ 才 $10$ 最有答案肯定是全选最大的，如果不能选最大的，就找一个位置选小一点的，然后堆优化BFS，第一个取出来的没被 ban 的就是答案</p>
<p>判断是不是被 ban 直接把 vector 塞进 map 里就行</p>
<p>因为没记录是否访问 MLE * 2 ，因为未知错误 WA * 2</p>
<p><a href="https://codeforces.com/contest/1574/submission/133446511">Submission</a></p>
<h4 id="E-Coloring"><a href="#E-Coloring" class="headerlink" title="E. Coloring"></a>E. Coloring</h4><p>先考虑空的状态</p>
<p>发现如果有两个相邻的格子同色，那就可以直接递推出所有的状态了</p>
<p>即 $2^m-2$ 减去了没有相邻同色的方案</p>
<p>而没有相邻同色的话每一行都可以决策是否与上一行相同或相反，即 $2\times 2^{n-1}$</p>
<p>如果加上限制，对于没有相邻同色的情况，意味着这一行被确定了，方案数要除 $2$ ，即 $2^{空行}$</p>
<p>同理，对于有相邻同色的就是 $2^{空列}$</p>
<p>还需要考虑有可能不能填成要求的状态，需要分类讨论</p>
<p><a href="https://codeforces.com/contest/1574/submission/133558793">Submission</a></p>
<h4 id="F-Occurrences"><a href="#F-Occurrences" class="headerlink" title="F. Occurrences"></a>F. Occurrences</h4><p>一个串出现的次数肯定不能比它的一个元素多，所以只要他的元素出现过，他就得出现过</p>
<p>如果把每个数按照序列顺序连边，每选定一个点就得把整个链放进去，如果这个链有分支或成环肯定是没办法选的</p>
<p>所以并查集维护能放进去的链，dp 方案即可</p>
<p>把连通块大小一样的一起做，最多只有 $\sqrt{k}$ 个，复杂度 $O(m\sqrt{k})$</p>
<h3 id="CF-Edu106-D-The-Number-of-Pairs"><a href="#CF-Edu106-D-The-Number-of-Pairs" class="headerlink" title="CF Edu106 D. The Number of Pairs"></a>CF Edu106 D. The Number of Pairs</h3><p><del>怎么又开始数学题了</del></p>
<p>设 $g = \gcd(a,b)$ $a’=\dfrac{a}{g},b’=\dfrac{b}{g}$</p>
<p>则 $cga’b’-dg=x \Rightarrow ca’b’-d=\dfrac{x}{g} $ </p>
<p>即 $g|x$ 设 $k = \dfrac{x}{g}$</p>
<p>则 $a’b’ = \dfrac{k+d}{c}$</p>
<p>所以 $c|k+d$ , 要求 $\gcd(a’,b’)=1$ 那么 $a’,b’$ 就是 $\dfrac{k+d}{c}$ 的质因子集合划分，即 $2^c$ 种方案</p>
<p>枚举 $g$ 即可</p>
<p><a href="https://codeforces.com/contest/1499/submission/133599725">Submission</a></p>
<h3 id="CF-Edu-105-D-Dogeforces"><a href="#CF-Edu-105-D-Dogeforces" class="headerlink" title="CF Edu 105 D. Dogeforces"></a>CF Edu 105 D. Dogeforces</h3><p>因为权值互异，所以按 LCA 的权值排序合并恰好形成了树形结构</p>
<p>每次合并当前的两个节点到一颗子树里，用并查集维护</p>
<p><a href="https://codeforces.com/contest/1494/submission/133947269">Submission</a></p>
<h3 id="CF749-Div1-2-E-Moment-of-Bloom"><a href="#CF749-Div1-2-E-Moment-of-Bloom" class="headerlink" title="CF749 Div1+2 E. Moment of Bloom"></a>CF749 Div1+2 E. Moment of Bloom</h3><p>图上奇偶性 -&gt; 生成树 ？</p>
<p>首先如果存在被访问奇数次的节点肯定无解，大概挺好理解的，而如果有解直接在生成树上找路径即可</p>
<p>原因是如果叶子结点成为端点次数是偶数，那么他与父节点边权是偶数，如此归纳即可</p>
<p><a href="https://codeforces.com/contest/1583/submission/133954884">Submission</a></p>
<h3 id="CF-Harbour-Space-Scholarship-Contest-2021-2022-H"><a href="#CF-Harbour-Space-Scholarship-Contest-2021-2022-H" class="headerlink" title="CF Harbour.Space Scholarship Contest 2021-2022 H"></a>CF Harbour.Space Scholarship Contest 2021-2022 H</h3><p>一个很妙的做法</p>
<p>强制每个 $x$ 只能使用那些，与 $x$ 相比只有最低的 $d$ 位可能不同的元素。</p>
<p>考虑一位一位更新答案，设 $f(x,d)$ 为数字 $x$ 在 $d$ 位上的答案，维护 $\mathrm{mmax}(x,d)$ 和 $\mathrm{mmin}(x,d)$ 为数字 $x$ 在 $d$ 位的异或最大/最小值</p>
<p>$\mathrm{mmax}(x,d)=\max({\mathrm{mmax}(x,d-1),\mathrm{mmax}(x\oplus2^{d},d-1)+2^{d=1}})$</p>
<p>$\mathrm{mmin}(x,d)=\max({\mathrm{mmin}(x,d-1),\mathrm{mmin}(x\oplus2^{d},d-1)+2^{d=1}})$</p>
<p>对于 $f(x,d)$ 仅需要决策 $f(x,d),f(x\oplus2^d,d),\mathrm{mmin}(x,d)-\mathrm{mmax}(x,d)+2^{d}$ 即可</p>
<h3 id="ARC114C-Sequence-Scores"><a href="#ARC114C-Sequence-Scores" class="headerlink" title="ARC114C Sequence Scores"></a>ARC114C Sequence Scores</h3><p>考虑加入一个新数字 $x$ 在长度为 $i$ 的序列的贡献</p>
<p>如果 $x$ 不在其中，需要额外一次操作</p>
<p>如果 $x$ 插入的位置是一个低点，不需要操作</p>
<p>否则需要一次额外操作</p>
<p>即 $F(i,x)$ 为这时的贡献，有 $F(i,x)=m^{i-1}-\sum\limits_{k=1}^{i-1}(m-x)^{i-1-k}\times m^{k-1}$</p>
<p>即枚举 $x$ 出现的位置，减去情况 $2$</p>
<p>$O(nm)$ 求和即可</p>
<h3 id="2021江西ICPC省赛-C-水晶洞窟"><a href="#2021江西ICPC省赛-C-水晶洞窟" class="headerlink" title="2021江西ICPC省赛 C. 水晶洞窟"></a>2021江西ICPC省赛 C. 水晶洞窟</h3><p>曼哈顿距离 $x,y$ 独立</p>
<p>要求的就是 $\dfrac{n(n-1)(n+1)}{6}+\max(\sum\limits_{i=1}^{n}\sum\limits_{j=i+1}^{n}|a_i-a_j|) (a_t \in [l_t,r_yt])$</p>
<p>显然后边的最大值在 $a_i$ 都是端点处取到，设 $f(a_1,a_1,\dots,a_n)=\max(\sum\limits_{i=1}^{n}\sum\limits_{j=i+1}^{n}|a_i-a_j|) (a_t \in [l_t,r_yt]$ 则对 $a_i$ 差分得到</p>
<p>$\Delta f_i=\sum\limits_{j=1}^{n}[a_j&lt;a_i]-[a_j&gt;a_i]$ 容易发现他单调不降，所以肯定是在端点取到最大值</p>
<p>继续贪心的想，$a_i$ 的分布应该尽可能”均匀”</p>
<p>证明咕</p>
<p>设 $dp_{i,j}$ 表示到了第 $i$ 层选了 $j$ 个放在左边的最大值</p>
<p>转移可以递推，假设一开始所有层的点都处在 $l_1,r_1$ 的位置上，左右各有 $\dfrac{n}{2}$ 个，每次决策一个点把其他点放下去</p>
<p><a href="https://codeforces.com/gym/103366/submission/134276901">Submission</a></p>
<h3 id="CF750-Div2-E-Pchelyonok-and-Segments"><a href="#CF750-Div2-E-Pchelyonok-and-Segments" class="headerlink" title="CF750 Div2 E. Pchelyonok and Segments"></a>CF750 Div2 E. Pchelyonok and Segments</h3><p>显然最长区间不能超过 $\sqrt{n}$</p>
<p>从前到后不好考虑，需要从后向前考虑，记 $dp_{i,j}$ 为第 $i$ 位后缀，存在一个区间 $[l,r]$ 和为 $r-l+1=j$ 的最大区间和</p>
<p>先转移 $dp_{i,j} \gets dp_{i+1,j}$ 若 $[i,i+j-1]$ 的区间和 $&lt; dp_{i+j,j-1}$ 则可以选择这个区间</p>
<p>复杂度 $O(n\sqrt{n})$</p>
<p><a href="https://codeforces.com/contest/1582/submission/134399039">Submission</a></p>
<h3 id="CF-Edu-116-D-Red-Blue-Matrix"><a href="#CF-Edu-116-D-Red-Blue-Matrix" class="headerlink" title="CF Edu 116 D. Red-Blue Matrix"></a>CF Edu 116 D. Red-Blue Matrix</h3><p>考虑枚举 $k \in [1,m-1]$ ，转换下条件就是前 $k$ 列的蓝色区域最大值小于红色区域最小值</p>
<p>为了满足这个条件直接按照第一列的顺序排列，即选择染色至少是染前 $i$ 行蓝色，剩下的条件可以 $O(1)$ 二维最大值检查</p>
<p>$O(nm)$</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树状数组</tag>
        <tag>KMP</tag>
        <tag>数论</tag>
        <tag>线段树</tag>
        <tag>组合计数</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.10.20模拟赛</title>
    <url>/2021/10/22/2021-10-20%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>Crumbled like the sands of time, that’s how it ends</p>
<span id="more"></span>

<h2 id="2021-10-20-模拟赛"><a href="#2021-10-20-模拟赛" class="headerlink" title="2021.10.20 模拟赛"></a>2021.10.20 模拟赛</h2><h3 id="A-F"><a href="#A-F" class="headerlink" title="A. F"></a>A. F</h3><p>根据期望的线性性有每个点的期望之和就是整个图的期望，每个点的期望就是选到自己的概率，即能到达自己的点的倒数</p>
<p>Floyd跑传递闭包即可</p>
<h3 id="B-S"><a href="#B-S" class="headerlink" title="B. S"></a>B. S</h3><p>简单 DP ，设 $dp_{i,j}$ 表示第一个串匹配到了第 $i$ 个，第二个串匹配到了 $j$ ，枚举删不删跳 fail 转移即可</p>
<h3 id="C-Y"><a href="#C-Y" class="headerlink" title="C. Y"></a>C. Y</h3><p>原题 NOIP 2013 </p>
<p>暴力跑过去了，感谢时代的进步（和O2</p>
<h3 id="D-o"><a href="#D-o" class="headerlink" title="D. o"></a>D. o</h3><p>考虑每个时刻新增的不好求，但是总面积跑个矩形面积并就出来了</p>
<p>那设 $F(i)$ 是 $i$ 时刻的总面积，答案为 $\sum i(F(i+1)-F(i))=tF(t)-\sum F(i)$ </p>
<p>发现重要性质是每个时刻 $F(i)$ 都是二次函数，系数的值只有在相交才会变，所以有 $O(n^2)$ 次变化，每次前缀和是 $3$ 次的，插值即可</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>KMP</tag>
        <tag>期望</tag>
        <tag>拉格朗日插值</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.10.19模拟赛</title>
    <url>/2021/10/20/2021-10-19%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>Frozen into icy rocks, that’s how it starts</p>
<span id="more"></span>

<h2 id="2021-10-19-模拟赛"><a href="#2021-10-19-模拟赛" class="headerlink" title="2021.10.19 模拟赛"></a>2021.10.19 模拟赛</h2><h3 id="A-最小和"><a href="#A-最小和" class="headerlink" title="A. 最小和"></a>A. 最小和</h3><p>set里插入前缀和，找到它的前驱后继保存答案，值相同取标号最小的</p>
<h3 id="B-小奇回地球"><a href="#B-小奇回地球" class="headerlink" title="B. 小奇回地球"></a>B. 小奇回地球</h3><p>二分加值跑最短路就行，需要注意到不了终点的点对答案无影响，即使存在负环</p>
<p>所以从终点开始 BFS 找出来能到终点的点，在上面跑最短路</p>
<h3 id="C-Alice’s-Trouble"><a href="#C-Alice’s-Trouble" class="headerlink" title="C. Alice’s Trouble"></a>C. Alice’s Trouble</h3><p>析和树板子题</p>
<h3 id="D-爱与和平"><a href="#D-爱与和平" class="headerlink" title="D. 爱与和平"></a>D. 爱与和平</h3><p>实际上就是找到 $\gcd(d,\dfrac{x}{d})=1$ 的部分做 dp ，是一个转二叉树的过程，用 $O(n)-O(1)$ $\gcd$ 就可以做到 $O(n\log n)$</p>
<p>但是卡常跑不过去</p>
<p>出题人的做法是预处理质因子集合，枚举子集转移，复杂度 $O(n\log n + \sum 2^{\omega(n)})$ 能跑过去，离谱</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>最短路</tag>
        <tag>析和树</tag>
        <tag>卡常</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.10.18模拟赛</title>
    <url>/2021/10/20/2021-10-18%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>What else should I engrave on my mind </p>
<span id="more"></span>

<h2 id="2021-10-18模拟赛"><a href="#2021-10-18模拟赛" class="headerlink" title="2021.10.18模拟赛"></a>2021.10.18模拟赛</h2><p>原题场，不过题还不错</p>
<h3 id="A-饥饿的狐狸"><a href="#A-饥饿的狐狸" class="headerlink" title="A. 饥饿的狐狸"></a>A. 饥饿的狐狸</h3><p>贪心</p>
<p>先排个序</p>
<p>最小值显然，最大值肯定是最小最大反复横跳，喝水更优就喝水，枚举下第一次吃最小还是最大</p>
<h3 id="B-保险箱"><a href="#B-保险箱" class="headerlink" title="B. 保险箱"></a>B. 保险箱</h3><p>竟然是数论题</p>
<p>考虑重要性质是答案一定是 $m_k$ 的一个最小的合法约数 $d$，因为若存在有数 $c$ 是密码，但是 $c\not{|}\ m_k$ 则 $\gcd(c,d)$ 是密码且 $\gcd(c,d) &lt; d$ </p>
<p>且 $\gcd(c,d) | m_k$ 矛盾</p>
<p>先把 $m_k \gets \gcd(m_k,n)$ 这样是通过 $am_k$ 能凑出来的最小值，对他分解因数，对于其他的 $m_i$ 因为它的因子必然不是密码，就和 $m_k$ 取 $\gcd$</p>
<p>并且标记这个因子不合法</p>
<p>找最小合法的因子的时候可以把不合法因子每次删一个质因子向下推而不是分解他，复杂度就变成了 $O(\sqrt{m_k}+k\log(m_k)+d(m_k)\omega(m_k))$</p>
<h3 id="C-追逐"><a href="#C-追逐" class="headerlink" title="C. 追逐"></a>C. 追逐</h3><p>树形dp</p>
<p>设 $f_{x,i}$ 表示 $x$ 中子树向上走到 $x$ 用了 $i$ 个磁铁的结果 , $g_{x,i}$ 表示 $x$ 走到子树里用了 $i$ 个磁铁的结果</p>
<p>转移枚举儿子合并，更新答案用 $g_{x,i}+f_{x,V-i}$ 更新</p>
<p>需要注意起点终点收益不同，需要反过来再跑一遍</p>
<h3 id="D-选举"><a href="#D-选举" class="headerlink" title="D. 选举"></a>D. 选举</h3><p>记 $C\to 1,T\to -1$ 就是要所有前后缀和都非负</p>
<p>贪心放就是对的，即遇到一个负数就改成 $0$</p>
<p>考虑前缀会加上前缀最小值的相反数，即 $-pre_{\min}$ ，第 $x$ 位后缀和的变化量是 $\min pre_{i&lt;x}-pre_{min}$</p>
<p>要求 $-\min(suf_{x}+pre_{i&lt;x}-pre_{\min})-pre_{\min}=-min(suf_x+\min pre_{i&lt;x})$</p>
<p>就是找到两个点的前后缀和不交且他们的和最小，即总和-最大子段和</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>数论</tag>
        <tag>线段树</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.10.17模拟赛</title>
    <url>/2021/10/17/2021-10-17%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>If I have never known the sore of farewell and pain of sacrifices</p>
<span id="more"></span>

<h2 id="2021-10-17模拟赛"><a href="#2021-10-17模拟赛" class="headerlink" title="2021.10.17模拟赛"></a>2021.10.17模拟赛</h2><h3 id="A-牛表"><a href="#A-牛表" class="headerlink" title="A. 牛表"></a>A. 牛表</h3><p><a href="https://sjzezoj.com/problem/1066">牛表</a></p>
<p>暴力连边是 $P^3$ 的复杂度，但是考虑到代价是线性加的，但是每次是乘的，所以猜想答案可能不超过 $\log$ 级别？</p>
<p>打个表答案不超过 $17$ 所以每个点只连前后十七条边即可</p>
<h3 id="B-牛牛和数组操作"><a href="#B-牛牛和数组操作" class="headerlink" title="B. 牛牛和数组操作"></a>B. 牛牛和数组操作</h3><p><a href="https://sjzezoj.com/problem/1067">牛牛和数组操作</a></p>
<p>设 $c[l,r]$ 是 $[l,r]$ 区间的最小代价， $t[l,r]$ 是 $[l,r]$ 区间的最小代价数量</p>
<p>暴力区间 dp，发现区间肯定是取最大值最优，卡卡常就过了</p>
<h3 id="C-与巨"><a href="#C-与巨" class="headerlink" title="C. 与巨"></a>C. 与巨</h3><p><a href="https://sjzezoj.com/problem/1068">与巨</a></p>
<p>操作是取 $ci$ 的后几位，发现二进制下乘法能用的性质不多，所以转换成模意义</p>
<p>若当前最高的 $1$ 位是 $x$ 需满足 $ci \equiv i \pmod {2^{x+1}}$</p>
<p>即 $(c-1)i \equiv0 \pmod {2^{x+1}}$ 如果 $(c-1)=b2^m$ 那么必然有 $2^{x+1-m}|i$</p>
<p>因为做了个前缀 $\max$ 所以要考虑每个能取到值往后会有 $2^{x+1-m}$ 的贡献</p>
<p>记 $u=x+1-m$ 则这个 $x$ 的答案为 $\sum (2^x+k2^{u})(2^u)$  $k$ 的范围是 $[0,2^{m-1})$</p>
<p>等差数列求和即可</p>
<p>对于 $x=n$ 的位置单独处理 $2^x+k2^u \le n \Rightarrow k=\lfloor\dfrac{n}{2^u}\rfloor-2^{x-u}$</p>
<p>会有一小部分算超出 $n$ 减去即可</p>
<h3 id="D-矩阵学说"><a href="#D-矩阵学说" class="headerlink" title="D. 矩阵学说"></a>D. 矩阵学说</h3><p><a href="https://sjzezoj.com/problem/1069">矩阵学说</a></p>
<p>发现这个东西显然具有单调性，二分，快速判定正方形内的不同个数可以用 bitset RMQ 判定</p>
<p>二分 $\le k$ 和 $\le k-1$ 做差即可</p>
<p>$O(n^2\log nm)$</p>
<p>May all the beauty be blessed</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.10.16模拟赛</title>
    <url>/2021/10/17/2021-10-16%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>I will no longer be a transient When I see smiles with tears</p>
<span id="more"></span>

<h2 id="2021-10-16模拟赛"><a href="#2021-10-16模拟赛" class="headerlink" title="2021.10.16模拟赛"></a>2021.10.16模拟赛</h2><h3 id="A-区间"><a href="#A-区间" class="headerlink" title="A. 区间"></a>A. 区间</h3><p><a href="https://sjzezoj.com/problem/1094">区间</a></p>
<p>经典原题，每次取区间最小值分治即可</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B. 树"></a>B. 树</h3><p><a href="https://sjzezoj.com/problem/1095">树</a></p>
<p>因为期望具有线性性，所以 $u \to v$ 的期望就是 $u \to lca$ $lca \to v$ 的期望之和</p>
<p>所以只需要处理出每个点走到它的父亲和从他父亲走到他的期望即可</p>
<p>走到他父亲 : $up_x=\dfrac{1}{d_x}+\sum\limits_{v \in \operatorname{son}(x)}\dfrac{1+up_v+up_x}{d_x}$</p>
<p>第一部分是直接走向父亲，第二部分是先走向一个儿子然后走回来，化简 $up_x=\sum up_v+d_x$</p>
<p>父亲走到他 ：$down_x =\dfrac{1}{d_{fa_x}}+\dfrac{1+down_{fa_x}+down_x}{d_{fa_x}}+\sum\limits_{v \in \operatorname{son}(fa_x)}\dfrac{1+up_v+down_x}{d_{fa_x}}$</p>
<p>第一部分是直接走，第二部分是走到父亲的父亲然后走回来，第三部分是先走到兄弟然后走回来</p>
<p>两边 DFS 即可</p>
<h3 id="C-做运动"><a href="#C-做运动" class="headerlink" title="C. 做运动"></a>C. 做运动</h3><p><a href="https://sjzezoj.com/problem/1096">做运动</a></p>
<p>按 $t$ 排序一条条加边，直到 $S,T$ 连通跑一下最短路</p>
<h3 id="D-手机信号"><a href="#D-手机信号" class="headerlink" title="D. 手机信号"></a>D. 手机信号</h3><p><a href="https://sjzezoj.com/problem/1097">手机信号</a></p>
<p>set 暴力维护三元组，细节挺多的，因为保证新建的区间内是空的，所以每次插入最多影响两个区间，所以复杂度正确</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>暴力</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.10.13模拟赛</title>
    <url>/2021/10/13/2021-10-13%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>I thought I were no more than a bystander Till I felt a touch so real</p>
<span id="more"></span>

<h3 id="2021-10-13模拟赛"><a href="#2021-10-13模拟赛" class="headerlink" title="2021.10.13模拟赛"></a>2021.10.13模拟赛</h3><p>傻逼了</p>
<h3 id="A-单词表"><a href="#A-单词表" class="headerlink" title="A. 单词表"></a>A. 单词表</h3><p><a href="https://sjzezoj.com/problem/1090">单词表</a></p>
<p>谢谢出题人的大样例，不然我可能就把错的二分交上去了</p>
<p>然后焦虑了一会没啥好想法只能暴力枚举，然后测了下跑得飞快</p>
<p>突然想到复杂度其实就是调和级数 $O(n\log n)$ 的….</p>
<p><del>然而还是被卡常了</del></p>
<h3 id="B-序列与改写"><a href="#B-序列与改写" class="headerlink" title="B. 序列与改写"></a>B. 序列与改写</h3><p><a href="https://sjzezoj.com/problem/1091">序列与改写</a></p>
<p>考虑这个约束条件是 $d|n \land d \operatorname{or} n=n$ ,发现这个改写的关系能变成一个 DAG</p>
<p>那我们 <del>EGF</del> 合并标号即可，因为 $n \le 2000$ 暴力卷积合并就行</p>
<p>复杂度上考虑这个限制其实很强，打表发现最大的改写深度不超过 $4$ ，所以卷积的时候枚举四项即可，复杂度 $O(16n^2)$</p>
<h3 id="C-拉丁方阵"><a href="#C-拉丁方阵" class="headerlink" title="C. 拉丁方阵"></a>C. 拉丁方阵</h3><p><a href="https://sjzezoj.com/problem/1093">拉丁方阵</a></p>
<p>先通过奥妙重重的找规律发现每个点操作次数就是 $A-B$ 每一位的数的绝对值，正数 $+$ 负数 $-$ 即可</p>
<p><del>因为出题人给了大样例，所以大样例必然是std跑的，只是random_shuffle了一下，所以sort一遍就能找到规律</del></p>
<p>证明就是 记$C=A-B$ ，则 $A_{i,j}+C_{i,j}+\sum\limits_{x\neq i}C_{x,j}+\sum\limits_{y\neq j}C_{i,y}=A_{i,j}-C_{i,j}+\sum C_{x,j}+\sum C_{i,y}$</p>
<p>考虑每行每列都是排列，所以 $\sum C_{x,j}$ 和 $\sum C_{i,y}$ 都是 $0$ 所以就是这样</p>
<h3 id="D-寻路游戏"><a href="#D-寻路游戏" class="headerlink" title="D.寻路游戏"></a>D.寻路游戏</h3><p><a href="https://sjzezoj.com/problem/1092">寻路游戏</a></p>
<p>障碍点很少，考虑能影响到最短路的点除了同一行列就是构成单调升/降内的一段</p>
<p>排序统计即可，感觉细节挺多的….</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>构造</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.10.11模拟赛</title>
    <url>/2021/10/12/2021-10-11%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>But it used to fly so high</p>
<span id="more"></span>

<h2 id="2021-10-11模拟赛"><a href="#2021-10-11模拟赛" class="headerlink" title="2021.10.11模拟赛"></a>2021.10.11模拟赛</h2><h3 id="A-F"><a href="#A-F" class="headerlink" title="A. F"></a>A. F</h3><p><a href="https://sjzezoj.com/problem/1075">F</a></p>
<p>因为 $a\ \mathrm{xor}\ b=x \Leftrightarrow a\ \mathrm{xor} \ x=b$</p>
<p>如果要检验一个 $x$ 只需要 $O(n\log n)$ 时间即可</p>
<p>而答案必然是在 $a_1 \ \mathrm{xor} \ b_i$ 中的，所以总复杂度 $O(n^2\log n)$</p>
<h3 id="B-S"><a href="#B-S" class="headerlink" title="B. S"></a>B. S</h3><p><a href="https://sjzezoj.com/problem/1074">S</a> </p>
<p>如果知道最后的序列求一下逆序对就知道交换次数</p>
<p>同时能发现性质，最终序列的每个字符的相对顺序和一开始序列的相对顺序不变</p>
<p>所以设 $dp[x][y][z][0/1/2]$ 表示选了 $x$ 个 $A$ $y$ 个 $B$ $z$ 个 $C$ ，当前位置是 $A/B/C$ 的答案，枚举下一位选啥即可</p>
<p>$O(n^3)$</p>
<h3 id="C-Y"><a href="#C-Y" class="headerlink" title="C.Y"></a>C.Y</h3><p><a href="https://sjzezoj.com/problem/1077">Y</a></p>
<p>利用均分纸牌的结论，每个人给下一个人的数量里一定有个 $0$ ，为了不重复，枚举最后一个是 $0$ 的人，把他和下一个人断开</p>
<p>记 $dp_{i,j}$ 表示第 $i$ 个人给了 $j$ 个的价值积之和，那么 $dp_{i,j}=\sum dp_{i-1,k}(a_i+k-j)$ 拆式子发现只需要维护 $\sum dp_{i,j}$ 和 $\sum dp_{i,j} \times j$</p>
<p>注意枚举的下界需要按照是不是大于当前枚举的最后一个是零的人决定</p>
<p>这样复杂度 $O(n^2)$</p>
<p>考虑每次断开只有初始值不一样，转移过程一样，预处理转移矩阵前后积即可，复杂度 $O(n)$</p>
<h3 id="D-o"><a href="#D-o" class="headerlink" title="D. o"></a>D. o</h3><p><a href="https://www.luogu.com.cn/problem/P6881">火事</a></p>
<p>如果以时间为 $y$ 轴画出所有的数</p>
<p>那么每个点的范围是个平行四边形，拆成三个等腰直角三角形，然后维护平行于 $x$ 轴和平行于 $y=x$ 的就行</p>
<p>然后你就口胡完了!</p>
]]></content>
      <categories>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>扫描线</tag>
        <tag>线段树</tag>
        <tag>矩阵优化DP</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title>IOI2018 高速公路收费</title>
    <url>/2021/10/07/IOI2018-%E9%AB%98%E9%80%9F%E5%85%AC%E8%B7%AF%E6%94%B6%E8%B4%B9/</url>
    <content><![CDATA[<p>Sometimes I see a dying bird fall to the ground</p>
<span id="more"></span>

<h2 id="IOI2018-高速公路收费"><a href="#IOI2018-高速公路收费" class="headerlink" title="IOI2018 高速公路收费"></a>IOI2018 高速公路收费</h2><p>非常好的一道题，Subtask 设置的很好，仔细思考跟着做就能推出来最终做法</p>
<h3 id="Subtask-1"><a href="#Subtask-1" class="headerlink" title="Subtask 1"></a>Subtask 1</h3><p>一棵树，并且确定了一条边，且点数 $\le 100$</p>
<p>先问一下 $S,T$ 的距离</p>
<p>然后分别试一下每条边是否在路径上即可</p>
<h3 id="Subtask-2"><a href="#Subtask-2" class="headerlink" title="Subtask 2"></a>Subtask 2</h3><p>比 Subtask 1 的点数变多了</p>
<p>考虑以 $0$ 为根，处理出深度，那么 $T$ 一定在 $\mathrm{dep}=dis(S,T)$ 上</p>
<p>那我们可以二分这些边，每次把一半置成 $1$ 如果变动了，说明在这半边</p>
<h3 id="Subtask-3"><a href="#Subtask-3" class="headerlink" title="Subtask 3"></a>Subtask 3</h3><p>链，直接二分即可</p>
<h3 id="Subtask-4"><a href="#Subtask-4" class="headerlink" title="Subtask 4"></a>Subtask 4</h3><p>仅仅保证了树，但是我们可以二分找到一个边在 $S \to T$ 上，然后删去这条边，在分别以这两个端点为根的树上做 Subtask 2</p>
<h3 id="Subtask-5"><a href="#Subtask-5" class="headerlink" title="Subtask 5"></a>Subtask 5</h3><p>?</p>
<p>似乎没啥能用的性质</p>
<h3 id="Subtask-6"><a href="#Subtask-6" class="headerlink" title="Subtask 6"></a>Subtask 6</h3><p>现在能做树了，考虑把图转成树来做</p>
<p>我们希望可以找到一种方法使得改边树上的状态时最短路不会经过图上，实际上也很简单，先类似 Subtask 4 找出来边，然后两个端点跑 bfs，找出最短路，然后把非 bfs 树的边全都设为 $B$ 这样无论怎么改都只会走树边</p>
<p>找到第一条在 $S \to T$ 需要 $\log_2m$ 然后两棵树分别二分需要 $2\log_2n$</p>
<p>不会超过 $50$</p>
<p><a href="https://uoj.ac/submission/510883">code</a></p>
]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.10.06模拟赛</title>
    <url>/2021/10/07/2021-10-06%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>Somewhere surrounded by the night, the sun will shine</p>
<span id="more"></span>

<h2 id="2021-10-06-模拟赛"><a href="#2021-10-06-模拟赛" class="headerlink" title="2021.10.06 模拟赛"></a>2021.10.06 模拟赛</h2><h3 id="A-string"><a href="#A-string" class="headerlink" title="A. string"></a>A. string</h3><p><a href="https://sjzezoj.com/problem/1040">string</a></p>
<p>很像是 HEOI2016 排序，但是有 $26$ 个字母 <del>开26个线段树</del></p>
<p>开二十六个线段树或者每个节点开一个 $26$ 大小的数组是可行的，不过我常数太大了，所以用了奇怪的方法</p>
<p>线段树上如果当前段全是一个颜色就记录一下，数量就是 $r-l+1$ ，如果不是就继续递归</p>
<p>直觉上排序之后会变得有序，所以不会暴力扫的太多，大概可以用势能一类的证明复杂度？(<del>或者Hack我</del>)</p>
<p><a href="https://sjzezoj.com/submission/38270">code</a></p>
<h3 id="B-water"><a href="#B-water" class="headerlink" title="B. water"></a>B. water</h3><p><a href="https://sjzezoj.com/problem/1041">water</a></p>
<p>比较优秀的想法是最小生成树，不过可以有不优秀的想法</p>
<p>考虑每个点能蓄水就是他四周的最低的比他高的那个 $v$ 减去他的$h_{x,y}$ ，所以我们开个小根堆去 BFS，但是要考虑蓄水状态可以继承，所以每次放到堆里的是 $\max(h_{x,y},v)$</p>
<p><a href="https://sjzezoj.com/submission/38182">code</a></p>
<h3 id="C-number"><a href="#C-number" class="headerlink" title="C. number"></a>C. number</h3><p><a href="https://sjzezoj.com/problem/1042">number</a></p>
<p>设一个暴力的状态 $(i,S,k)$表示当前第 $i$ 位，$0…9$ 的次数状态为 $S$ , $\bmod m =k$ 的方案</p>
<p>第一个问题是 $S$ 怎么压，因为题目保证了 $n \le 20$ ，可以考虑变进制状压，每一位的进制是出现的次数，这样最多是 $3^{10}$ 的状态</p>
<p>然后发现复杂度过不去，要跑 $5$ s，但其实发现没必要记录 $i$ 这一维，因为 $S$ 必然是从小到大转移，这样就是 $O(3^{10}10m)$ 的复杂度</p>
<p><a href="https://sjzezoj.com/submission/38183">code</a></p>
<hr>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>线段树</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.10.04模拟赛</title>
    <url>/2021/10/07/2021-10-04%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>Some deserts on this planet were oceans once</p>
<span id="more"></span>

<h2 id="2021-10-04模拟赛"><a href="#2021-10-04模拟赛" class="headerlink" title="2021.10.04模拟赛"></a>2021.10.04模拟赛</h2><h3 id="A-aplusb"><a href="#A-aplusb" class="headerlink" title="A. aplusb"></a>A. aplusb</h3><p>如果 $n$ 是奇数显然取 $\lfloor\dfrac{n}{2}\rfloor\pm 1$ 最优</p>
<p>偶数可以<del>打表找规律</del> 发现如果只有一个 $2$ 因子，那还是取 $\dfrac{n}{2}\pm1$</p>
<p>否则的话取 $\dfrac{n}{2}\pm 2$</p>
<h3 id="B-道路"><a href="#B-道路" class="headerlink" title="B.  道路"></a>B.  道路</h3><p><a href="https://sjzezoj.com/problem/1004">道路</a></p>
<p>先考虑求 $k^0$ 的经典问题，城市规划</p>
<p>设 $g_i$ 为 $i$ 个点的无向图方案数，设 $m=\binom{n}{2}$ 显然有 $g_i=2^{\binom{n}{2}}$</p>
<p>$f_i$ 为无向连通图的方案数，需要减去不合法状态</p>
<p>枚举 $1$ 所在的连通块大小为 $j$ 则 $f_i=g_i-\sum\limits_j\binom{i-1}{j-1}f_jg_{i-j}$</p>
<p>那我们用 $g_{i,k}$ 表示 $i$ 个点 $m^k$ 的和，设 $\vartheta = x\mathrm{D}$ 则 $g_{i,k} = \vartheta^k(x+1)^{\binom{i}{2}}|_{x=1}$</p>
<p>而计算 $f_{i,k}$ 时拼接起来的和可以用 $(a+b)^m$ 展开来处理</p>
<p><a href="https://sjzezoj.com/submission/37863">code</a></p>
<h3 id="C-hole"><a href="#C-hole" class="headerlink" title="C. hole"></a>C. hole</h3><p><a href="https://sjzezoj.com/contest/159/problem/1005">hole</a></p>
<p>先考虑没有插入点的的三角形数点怎么做</p>
<p>因为是等腰直角三角形，斜边上的 $x+y=d$ ，所以按 $x+y$ 排序差分</p>
<p><a href="https://imgtu.com/i/5SnXlQ"><img src="https://z3.ax1x.com/2021/10/07/5SnXlQ.md.png" alt="5SnXlQ.md.png"></a></p>
<p>黄线处减，蓝线处加，左右两个平行四边形分别拿树状数组减出来即可</p>
<p>那加上时间就直接 CDQ 即可</p>
<p><a href="https://sjzezoj.com/submission/38011">code</a></p>
<h3 id="D-斐波那契"><a href="#D-斐波那契" class="headerlink" title="D. 斐波那契"></a>D. 斐波那契</h3><p><a href="https://sjzezoj.com/problem/1006">斐波那契</a></p>
<p><a href="https://www.luogu.com.cn/blog/ycs-gg/cf446c">Solution</a></p>
<p><a href="https://sjzezoj.com/submission/37854">code</a></p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>线段树</tag>
        <tag>组合计数</tag>
        <tag>CDQ</tag>
        <tag>斐波那契</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.10.02模拟赛</title>
    <url>/2021/10/03/2021-10-02%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>虎踞龙盘今胜昔，天翻地覆慨而慷。</p>
<span id="more"></span>

<h2 id="2021-10-02-模拟赛"><a href="#2021-10-02-模拟赛" class="headerlink" title="2021.10.02 模拟赛"></a>2021.10.02 模拟赛</h2><h3 id="A-旅游路线"><a href="#A-旅游路线" class="headerlink" title="A. 旅游路线"></a>A. 旅游路线</h3><p><a href="https://sjzezoj.com/problem/1027">旅游路线</a></p>
<p>最大子矩阵板子题</p>
<h3 id="B-金色丝线将瞬间一分为二"><a href="#B-金色丝线将瞬间一分为二" class="headerlink" title="B. 金色丝线将瞬间一分为二"></a>B. 金色丝线将瞬间一分为二</h3><p><a href="https://sjzezoj.com/problem/1028">金色丝线将瞬间一分为二</a></p>
<p>$x,y$ 独立，考虑分开处理</p>
<p>对于 $x$ 而言，当前插入一个点加的答案 $\Delta = \sum\limits_{j&lt;i}|x_j-x_i|=\sum\limits_{j&lt;i,x_j\le x_i}x_i-x_j+\sum\limits_{j&lt;i,x_j&gt;x_i}x_j-x_i$</p>
<p>树状数组维护这个东西即可</p>
<p><a href="https://sjzezoj.com/submission/37522">code</a></p>
<h3 id="C-神在夏至祭降下了神谕"><a href="#C-神在夏至祭降下了神谕" class="headerlink" title="C. 神在夏至祭降下了神谕"></a>C. 神在夏至祭降下了神谕</h3><p><a href="https://sjzezoj.com/problem/1029">神在夏至祭降下了神谕</a></p>
<p>先把 $0$ 记成 $-1$ 会好看一点</p>
<p>朴素DP : $dp_i = \sum \limits_{j&lt;i,|S(j,i)| \le k} dp_{j}$ </p>
<p>发现如果我们能迅速求出来 $|S(i,j)|\le k$ 的和即可，考虑开个桶，表示距离当前点 $x$ 的 $S(i,x)$ 的 $dp_k$ 之和</p>
<p>每次加入一个点会把桶整体平移，移动零点的指针即可，统计用树状数组</p>
<p><a href="https://sjzezoj.com/submission/37653">code</a></p>
<h3 id="D-number"><a href="#D-number" class="headerlink" title="D. number"></a>D. number</h3><p><a href="https://sjzezoj.com/problem/1030">number</a></p>
<p>考虑仅有最后五位是有用的，用 $dp_{i,S}$ 表示当前是第 $i$ 位，后五位状态为 $S$</p>
<p>先预处理出来所有不合法的情况，需要记录下 $S$ 如果不合法，那不合法的位置到哪里，因为可能会被截断</p>
<p>然后正常数位DP，每次暴力扫不合法的情况判断即可</p>
<p>比较优秀的解法应该是AC自动机？</p>
<p><a href="https://sjzezoj.com/submission/37528">code</a></p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title>ArchLinux折腾笔记</title>
    <url>/2021/09/30/ArchLinux%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>\Arch/</p>
<span id="more"></span>

<p>先上个图</p>
<p>[图片]</p>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>先在虚拟机上装了两边，然后在物理机上装(果然遇到了巨大多问题)，之后又给其他人的物理机装 Arch</p>
<p><del>现在我已经把安装流程刻在 DNA 里啦</del></p>
<p>需要一个有 Arch 的启动盘和支持 UEFI 启动</p>
<p>双系统最好在另一个系统下划分好空余空间，建议至少有 40G</p>
<p>首先需要以 UEFI 启动，然后在 BIOS 里关闭安全启动</p>
<p>进入到 ArchLive ，选第一个选项即可</p>
<h3 id="1-1-分区"><a href="#1-1-分区" class="headerlink" title="1.1 分区"></a>1.1 分区</h3><p>先看一眼硬盘设备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls /dev</span><br></pre></td></tr></table></figure>

<p>机械一般叫 sdX 比如 /dev/sda1</p>
<p>固态一般叫 nvme0nX 比如 /dev/nvme0n1</p>
<p>GPT 分区下用 <code>cgdisk</code> 分区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cgdisk /dev/nvme0n1</span><br></pre></td></tr></table></figure>

<p>进去后长这样</p>
<p>[图片]</p>
<p>如果是双系统只把之前分好的空余空间划分就行</p>
<p>先 new 一下新分区</p>
<p>然后选 [Type] ，Linux filesystem 的代码是 8300 </p>
<p>如果不是双系统还需要划 EFI 分区，代码是 ef00</p>
<p>交换分区我觉得没必要，要分的话可以参考 <a href="https://wiki.archlinux.org/title/Installation_guide#Partition_the_disks">ArchWiki</a></p>
<p>建议稍微分大一点，比如 512M</p>
<p>然后 [Write] -&gt; yes -&gt; [Quit]</p>
<p>用 <code>fdisk -l</code> 看一眼划分的分区，记住分区的名字 类似 nvme0n1p5 这样的</p>
<p>之后用 <code>mkfs</code> 格式化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs.ext4 /dev/你划分的主分区</span><br></pre></td></tr></table></figure>

<p>EFI 分区（如果是双系统不要格式化）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs.fat -F32 /dev/EFI分区</span><br></pre></td></tr></table></figure>

<h3 id="1-2-联网"><a href="#1-2-联网" class="headerlink" title="1.2 联网"></a>1.2 联网</h3><p>因为需要安装软件包，需要先连上网</p>
<p>如果是有线网应该自动连接了，无线网需要手动配置下</p>
<p>如果 <code>ping bing.com</code> 能成功就是连上了</p>
<p>有线网如果没连上 <del>那我也不会</del> ，可以试试 <code>systemctl enable --now dhcpcd</code></p>
<p> 无线网先用 rfkill 查看是否处于 blocked 状态</p>
<p>一般无线网卡叫 wlan0 一类的名字，可以先用 ip link 看一下，详情查看 wiki</p>
<p>如果显示无线网卡 SOFT 状态是 block ，用  <code>rfkill unblock 设备名 </code> 解除下</p>
<p>然后进入 <code>iwctl</code></p>
<p>先 <code>station 设备名 scan</code></p>
<p>然后 <code>station 设备名 get-networks</code> 找到网络</p>
<figure class="highlight plain"><figcaption><span>设备名 connect 网络名``` 连接</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">可以用 &#96;&#96;&#96;timedatectl set-ntp true&#96;&#96;&#96; 同步下时间</span><br><span class="line"></span><br><span class="line">### 1.3 挂载</span><br><span class="line"></span><br><span class="line">先 &#96;&#96;&#96;mount &#x2F;de&#x2F;主分区 &#x2F;mnt &#96;&#96;&#96; 挂载主分区</span><br><span class="line"></span><br><span class="line">然后 &#96;&#96;&#96;mkdir -p &#x2F;mnt&#x2F;boot&#x2F;efi&#96;&#96;&#96; 创建 &#96;&#96;&#96;&#x2F;boot&#x2F;efi&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">之后 &#96;&#96;&#96;mount &#x2F;dev&#x2F;EFI分区 &#x2F;mnt&#x2F;boot&#x2F;efi&#96;&#96;&#96; 挂载 EFI 分区</span><br><span class="line"></span><br><span class="line">### 1.4 安装</span><br><span class="line"></span><br><span class="line">然后就可以大力安装啦！</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;bash</span><br><span class="line">pacstrap -i &#x2F;mnt base linux linux-firmware vim openssh xfsprogs dhcpcd dialog man networkmanager iproute2 wireless_tools wpa_supplicant os_prober base-devel git sudo</span><br></pre></td></tr></table></figure>

<p> 等待安装完成</p>
<p>之后生成 fstab</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">genfstab -U &#x2F;mnt &gt;&gt; &#x2F;mnt&#x2F;etc&#x2F;fstab</span><br></pre></td></tr></table></figure>

<h3 id="1-5-新系统"><a href="#1-5-新系统" class="headerlink" title="1.5 新系统"></a>1.5 新系统</h3>]]></content>
      <categories>
        <category>ArchLinux</category>
      </categories>
      <tags>
        <tag>Arch</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.09.27模拟赛</title>
    <url>/2021/09/27/2021-09-27%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生</p>
<span id="more"></span>

<h2 id="2021-09-27模拟赛"><a href="#2021-09-27模拟赛" class="headerlink" title="2021.09.27模拟赛"></a>2021.09.27模拟赛</h2><h3 id="A-e"><a href="#A-e" class="headerlink" title="A. e"></a>A. e</h3><p><a href="https://sjzezoj.com/problem/999">e</a></p>
<p>先把树上主席树建出来，找到 $\min(|a_p-r|)$ 就是找 $r$ 的前驱后继，可以在主席树上二分</p>
<p>因为是最小值，所以不用考虑链重复的问题，不用把虚树建出来，只用查询所有点到 lca 链上的前驱后继即可</p>
<p><a href="https://sjzezoj.com/submission/36381">code</a></p>
<h3 id="B-简单的序列"><a href="#B-简单的序列" class="headerlink" title="B. 简单的序列"></a>B. 简单的序列</h3><p><a href="https://sjzezoj.com/problem/1000">简单的序列</a></p>
<p>考虑如果中间 $m$ 的字符串有 $k$ 个未匹配的右括号，$l$ 个未匹配的左括号</p>
<p>那么需要左边有 $k$ 个未匹配的左括号，右边同理，还需要枚举 $j$ 个括号作为左边匹配右边的</p>
<p>预处理 $\mathrm{cnt}_{i,j}$ 表示 $i$ 个括号有 $j$ 个未匹配的左括号</p>
<p>考虑当前加入一个右括号，会抵消一个，转移到 $\mathrm{cnt}_{i+1,j-1}$</p>
<p>否则是 $\mathrm{cnt}_{i+1,j+1}$</p>
<p>复杂度 $O((n-m)^2)$</p>
<h3 id="C-简单的期望"><a href="#C-简单的期望" class="headerlink" title="C. 简单的期望"></a>C. 简单的期望</h3><p><a href="https://sjzezoj.com/problem/1001">简单的期望</a></p>
<p>emm</p>
<p>显然 $2$ 的次数就是二进制下末尾连续 $0$ 的个数</p>
<p>发现一个关键性质是只有 $200$ 次操作，而 $2^8 &gt; 200$</p>
<p>所以第 $9$ 位的进位最多只会进一次</p>
<p>那考虑 $dp_{i,S,k,0/1}$ 表示操作了 $i$ 次，低 $8$ 位状态为 $S$ ，第 $9$ 位为 $0/1$ 后面连续的概率</p>
<p>大力转移即可</p>
<p><a href="https://sjzezoj.com/submission/36565">code</a></p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>主席树</tag>
        <tag>组合计数</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.09.25模拟赛</title>
    <url>/2021/09/25/2021-09-25%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>最是人间留不住，朱颜辞镜花辞树</p>
<span id="more"></span>

<h2 id="2021-09-25模拟赛"><a href="#2021-09-25模拟赛" class="headerlink" title="2021.09.25模拟赛"></a>2021.09.25模拟赛</h2><h3 id="A-极简主义的安保"><a href="#A-极简主义的安保" class="headerlink" title="A. 极简主义的安保"></a>A. 极简主义的安保</h3><p><a href="https://sjzezoj.com/problem/1007">极简主义的安保</a></p>
<p>诡异的翻译</p>
<p><del>有梦想你也45</del></p>
<p>考虑每个点如果减去了 $c(x)$</p>
<p>那么有 $p(u)-c(u)+p(v)-c(v)=w(u,v)$</p>
<p>即 $c(u)+c(v) = p(u)+p(v)-w(u,v) $</p>
<p>右边是个定值，根据之前某个题的思路，如果一个联通块里钦点了一个点 $x$ 确定了，别的点 $y$ 就可以表达成 $\pm c(x)+B_y$</p>
<p>dfs 搜一下搜出来符号和 $B_y$ 碰到已经访问的点就联立解下方程判有无解</p>
<p>总和是 $c(x) \times \sum K_y+\sum B_y$</p>
<p>更新点的时候顺便更新下最小/大值带入即可</p>
<h3 id="B-稻草人"><a href="#B-稻草人" class="headerlink" title="B. 稻草人"></a>B. 稻草人</h3><p><a href="https://sjzezoj.com/problem/1008">稻草人</a></p>
<p>二维数点可以考虑 CDQ</p>
<p>考虑按 $y$ 坐标排序，按 mid 分成两个部分，然后分别按 $x$ 排序，钦点上边的一个点作为右上角</p>
<p>他能贡献到的点是在下半部分的一段单调递减的序列，单调递减可以用一个单调栈去维护</p>
<p>$y$ 的显示保证了，需要考虑 $x$ 的限制，能够贡献的区间是离他最近的 $y$ 小于它的点</p>
<p>也用一个单调栈维护，然后再第一个单调栈上二分即可</p>
<h3 id="C-只不过是长的领带"><a href="#C-只不过是长的领带" class="headerlink" title="C. 只不过是长的领带"></a>C. 只不过是长的领带</h3><p><a href="https://sjzezoj.com/problem/1009">只不过是长的领带</a></p>
<p>显然的贪心，小的 $a$ 匹配小的 $b$ 即可</p>
<h3 id="D-汤姆的餐厅"><a href="#D-汤姆的餐厅" class="headerlink" title="D. 汤姆的餐厅"></a>D. 汤姆的餐厅</h3><p><a href="https://sjzezoj.com/problem/1010">汤姆的餐厅</a></p>
<p>贪心的考虑，我们希望先满足每个菜 $k$ 个人的条件</p>
<p>那么让每个人贡献一个 $1$ 的时间给所有菜，那一个人这方面的贡献是 $\min(n,b_i)$</p>
<p>要合法的化就要满足选取的人的 $\sum b_i \ge \sum a_i$</p>
<p>且贡献到 $k$ 个时间 $\ge nk$</p>
<p>背包跑一下就行</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>思维</tag>
        <tag>背包</tag>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.09.24模拟赛</title>
    <url>/2021/09/25/2021-09-24%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>苟利国家生死以，岂因祸福避趋之</p>
<span id="more"></span>

<h2 id="2021-09-24模拟赛"><a href="#2021-09-24模拟赛" class="headerlink" title="2021.09.24模拟赛"></a>2021.09.24模拟赛</h2><h3 id="A-maze"><a href="#A-maze" class="headerlink" title="A. maze"></a>A. maze</h3><p><a href="https://sjzezoj.com/problem/1019">maze</a></p>
<p>考虑到竖边代价变大最短路必然不降，所以具有单调性，二分即可</p>
<p><a href="https://sjzezoj.com/submission/35122">code</a></p>
<h3 id="B-论逼格"><a href="#B-论逼格" class="headerlink" title="B. 论逼格"></a>B. 论逼格</h3><p><a href="https://sjzezoj.com/problem/1020">论逼格</a></p>
<p>显然有长度为 $2i-1$ 的回文串有 $9\times10^i$ 个</p>
<p>要求的就是</p>
<p>$9\sum\limits_{i=1}^{\frac{n}{2}}(2i-1)\times10^i = 18\sum\limits_{i=1}^{\frac{n}{2}}i10^i-\sum\limits_{i=1}^{\frac{n}{2}}10^i$</p>
<p>有 $\sum\limits_{i=1}^{n}iq^i=\dfrac{q+q^{n+1}(n(q-1)-1)}{(q-1)^2}$</p>
<p>证明方法很多，<del>建议直接对等比数列求和的式子求导乘x</del></p>
<p>大力化简完就是 $\dfrac{1}{9}(11+(18n-11)10^{n})$</p>
<h3 id="C-数独"><a href="#C-数独" class="headerlink" title="C. 数独"></a>C. 数独</h3><p><a href="https://sjzezoj.com/problem/1021">数独</a></p>
<p>大力爆搜</p>
<h3 id="D-迷宫"><a href="#D-迷宫" class="headerlink" title="D. 迷宫"></a>D. 迷宫</h3><p><a href="https://sjzezoj.com/problem/1022">迷宫</a></p>
<p>只有两行的是经典题高速公路</p>
<p>考虑拓展下就是设 $M_{i,j}$ 表示左端点第 $i$ 个到右端点第 $j$ 个的最短距离</p>
<p>合并枚举中间点 Floyd 然后拿线段树维护下即可</p>
<p><a href="https://sjzezoj.com/submission/35144">code</a></p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>最短路</tag>
        <tag>线段树</tag>
        <tag>二分</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.09.22模拟赛</title>
    <url>/2021/09/25/2021-09-22%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>又是六道题</p>
<span id="more"></span>

<h2 id="2021-09-22模拟赛"><a href="#2021-09-22模拟赛" class="headerlink" title="2021.09.22模拟赛"></a>2021.09.22模拟赛</h2><h3 id="A-极好的问题"><a href="#A-极好的问题" class="headerlink" title="A. 极好的问题"></a>A. 极好的问题</h3><p><a href="https://sjzezoj.com/problem/1011">极好的问题</a></p>
<p>枚举两个数找第三个数就行，有点小细节</p>
<p>$O(n^2\log n)$</p>
<p><a href="https://sjzezoj.com/submission/31345">code</a></p>
<h3 id="B-打铁的匠"><a href="#B-打铁的匠" class="headerlink" title="B. 打铁的匠"></a>B. 打铁的匠</h3><p><a href="https://sjzezoj.com/problem/1012">打铁的匠</a></p>
<p>主席树板子题</p>
<p>dfs 序上查询子树深度 $\ge dep_u+k$  的和即可</p>
<p><a href="https://sjzezoj.com/submission/33481">code</a></p>
<h3 id="C-扭动的树"><a href="#C-扭动的树" class="headerlink" title="C. 扭动的树"></a>C. 扭动的树</h3><p><a href="https://sjzezoj.com/problem/1013">扭动的树</a></p>
<p>按 key 排序后每个子树都可以表示为一个区间，记 $dp_{0/1,l,r}$ 表示当前 $[l,r]$ 区间作为左右子树时的最大和</p>
<p>转移枚举根节点即可，需要判断下 $\gcd$ 能不能连边</p>
<p><a href="https://sjzezoj.com/submission/31157">code</a></p>
<h3 id="D-座位安排"><a href="#D-座位安排" class="headerlink" title="D. 座位安排"></a>D. 座位安排</h3><p><a href="https://sjzezoj.com/problem/1014">座位安排</a></p>
<p>贪心</p>
<p>考虑前门的人能坐下的是一条斜线内的区域，先按照 $s$ 排序，贪心的让作为匹配到达它的 $s$ 最小的</p>
<p><a href="https://sjzezoj.com/submission/33558">code</a></p>
<h3 id="E-红心大战"><a href="#E-红心大战" class="headerlink" title="E. 红心大战"></a>E. 红心大战</h3><p><a href="https://sjzezoj.com/problem/1015">红心大战</a></p>
<p>纯模拟</p>
<p><a href="https://sjzezoj.com/submission/31161">code</a></p>
<h3 id="F-购物"><a href="#F-购物" class="headerlink" title="F. 购物"></a>F. 购物</h3><p><a href="https://sjzezoj.com/problem/1016">购物</a></p>
<p>先排除掉包含区间</p>
<p>处理出来每个点能到达的最右的点，$O(n^2)$ DP划分这个序列即可</p>
<p><a href="https://sjzezoj.com/submission/35004">code</a></p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>区间DP</tag>
        <tag>数论</tag>
        <tag>模拟</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.09.19模拟赛</title>
    <url>/2021/09/20/2021-09-19%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>应是天仙狂醉，乱把白云揉碎。</p>
<span id="more"></span>

<h2 id="2021-09-19模拟赛"><a href="#2021-09-19模拟赛" class="headerlink" title="2021.09.19模拟赛"></a>2021.09.19模拟赛</h2><h3 id="A-背包问题"><a href="#A-背包问题" class="headerlink" title="A. 背包问题"></a>A. 背包问题</h3><p><a href="https://sjzezoj.com/problem/984">背包问题</a></p>
<p>考虑没有背包的限制就是一个二维偏序，有背包的话因为我们选出来的体积越来越大，肯定是用大背包装大物品比较优</p>
<p>都从大到小排序，跑一下价值上的最长上升子序列即可</p>
<p><a href="https://sjzezoj.com/submission/31046">code</a></p>
<h3 id="B-子树问题"><a href="#B-子树问题" class="headerlink" title="B. 子树问题"></a>B. 子树问题</h3><p><a href="https://sjzezoj.com/problem/985">子树问题</a></p>
<p>经典问题了属于是</p>
<p>不如考虑暴力多项式做法，枚举子树个数和大小，设 $F_j(x)$ 表示深度不超过 $j$ 的个数</p>
<p>考虑枚举子树个数并拼接，有 $F_j(x) = x\exp(F_{j-1}(x))$ </p>
<p>（就是拼接树</p>
<p>$O(n^2\log n)$ 常数起飞</p>
<p>正常的 $dp$ 思路是考虑枚举一下子树的大小，设 $dp_{i,j}$ 表示 $i$ 个点 深度不超过 $j$ 的方案数</p>
<p>有 $dp_{i,j} = \sum dp_{i-k,j}\times dp_{k,j-1} \times\binom{i-2}{k-1}$</p>
<p>就是在 $i-k$ 的基础上插入一个新的大小为 $k$ 的子树，为了保证不计重，需要让 $k$ 的根标号是 $2$</p>
<p>而给剩下的点分配标号就是 $\binom{i-1-k+k-1}{k-1}=\binom{i-2}{k-1}$</p>
<p><a href="https://sjzezoj.com/submission/30726">code</a></p>
<h3 id="C-括号序列"><a href="#C-括号序列" class="headerlink" title="C. 括号序列"></a>C. 括号序列</h3><p><a href="https://sjzezoj.com/problem/986">括号序列</a></p>
<p>带颜色括号的合法字串个数</p>
<p>考虑 $O(n^2)$ 暴力，每个点开个栈往后扫，碰到一个同色的能弹就弹，栈空了就合法</p>
<p>那么如果我从 1 开始记录栈，如果有两个栈的状态一样，说明清空了，有 $n$ 个就是任选两个 $\binom{n}{2}$</p>
<p><a href="https://sjzezoj.com/submission/30725">code</a></p>
<h3 id="D-倾斜的线"><a href="#D-倾斜的线" class="headerlink" title="D. 倾斜的线"></a>D. 倾斜的线</h3><p><a href="https://sjzezoj.com/problem/987">倾斜的线</a></p>
<p>懒了，不想写式子了</p>
<p>通分一下能够发现把每个点写成 $(Qy-Px,Qx)$ 的形式</p>
<p>就是找最小斜率，排序扫一遍就行</p>
<p><a href="https://sjzezoj.com/submission/30965">code</a></p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>思维</tag>
        <tag>计数DP</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.09.18模拟赛</title>
    <url>/2021/09/20/2021-09-18%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>今古恨，几千般，只应离合是悲欢？江头未是风波恶，别有人间行路难。</p>
<span id="more"></span>

<h2 id="2021-09-18模拟赛"><a href="#2021-09-18模拟赛" class="headerlink" title="2021.09.18模拟赛"></a>2021.09.18模拟赛</h2><p>全 是 J O I</p>
<h3 id="A-愉快的标志设计"><a href="#A-愉快的标志设计" class="headerlink" title="A. 愉快的标志设计"></a>A. 愉快的标志设计</h3><p><a href="https://sjzezoj.com/problem/805">愉快的标志设计</a></p>
<p>签到题，枚举某一个位置作为起点，前缀和记录下需要改多少个数 $O(n\log n)$ 判断即可</p>
<p><a href="https://sjzezoj.com/submission/30443">code</a></p>
<h3 id="B-电报"><a href="#B-电报" class="headerlink" title="B. 电报"></a>B. 电报</h3><p><a href="https://sjzezoj.com/problem/587">电报</a></p>
<p>贪心蛮好想的，但是不太好证</p>
<p>因为每个点只有一个出边，所以最后的强连通分量必然是个环</p>
<p>那么每个点就只能有一个入度</p>
<p>担心的考虑每个点要代价最大的入度，因为这样改的最少</p>
<p>然后考虑会剩下很多环和挂上边的链</p>
<p>要把链并进环里，必然要把链 $a \rightarrow$ 环 的边连上，然后把被连的的点原来的入度拆掉</p>
<p>所以跑一下环，找到这个代价的最小值即可</p>
<p>证明考虑构造出方案来</p>
<p>首先这个图会是一个内向基环树森林</p>
<p>我们先把环上的树处理掉，考虑一个节点的两个入度，选择一个最大的入度，然后其他的入度顺次连接就能变成链</p>
<p><a href="https://imgtu.com/i/4GzpDg"><img src="https://z3.ax1x.com/2021/09/20/4GzpDg.png" alt="4GzpDg.png"></a></p>
<p>然后一个内向基环树，如果最后变成了这样</p>
<p><a href="https://imgtu.com/i/4GznrF"><img src="https://z3.ax1x.com/2021/09/20/4GznrF.md.png" alt="4GznrF.md.png"></a></p>
<p>那他已经变成链了，不用管他</p>
<p>否则就是</p>
<p><a href="https://imgtu.com/i/4GzJxK"><img src="https://z3.ax1x.com/2021/09/20/4GzJxK.md.png" alt="4GzJxK.md.png"></a></p>
<p>那我们贪心找一下断开的环边，也会变成链，最后就是一堆链</p>
<p>随便连就能连出来环</p>
<p><a href="https://sjzezoj.com/submission/30573">code</a></p>
<h3 id="C-三明治"><a href="#C-三明治" class="headerlink" title="C. 三明治"></a>C. 三明治</h3><p><a href="https://sjzezoj.com/problem/543">三明治</a></p>
<p>考虑 $O(n^4)$ 大暴力，枚举每一个点那个位置先被吃，然后爆搜，如果搜出来环就不合法</p>
<p>仔细思考一下能够发现，如果先吃的是左边的，那么它左边的也一定被先吃，所以可以继承状态，对于每一行枚举从左还是从右开始吃</p>
<p>然后每行共用一个 $O(nm)$ 的状态，总复杂度 $O(n^2m)$</p>
<p><a href="https://sjzezoj.com/submission/30446">code</a></p>
<h3 id="D-绳"><a href="#D-绳" class="headerlink" title="D. 绳"></a>D. 绳</h3><p><a href="https://sjzezoj.com/problem/811">绳</a></p>
<p>题面描述比较诡异，其实就是在绳子上找个位置对折一下，要求对应位置颜色对齐</p>
<p>因为染色代价先染后染一样，所以最开始染成两种颜色即可</p>
<p>一个结论是能够折成长度为二的绳子，除了首尾的极大同色连续段都是偶数长度的，充分性显然，必要性可以反证</p>
<p>这能推出来所有同色连续段的首位奇偶性相同，所以枚举奇偶性进行染色，然后剩下的位置选一个颜色最多的染上就行</p>
<p>剩下位置颜色最多的可以开桶维护</p>
<p><a href="https://sjzezoj.com/submission/31012">code</a></p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.09.17模拟赛</title>
    <url>/2021/09/17/2021-09-17%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>早岁那知世事艰，中原北望气如山</p>
<span id="more"></span>

<h2 id="2021-09-17模拟赛"><a href="#2021-09-17模拟赛" class="headerlink" title="2021.09.17模拟赛"></a>2021.09.17模拟赛</h2><p>没做T4大失误</p>
<h3 id="A-Sequence"><a href="#A-Sequence" class="headerlink" title="A. Sequence"></a>A. Sequence</h3><p><a href="https://sjzezoj.com/problem/980">Sequence</a></p>
<p>简单题，预处理出每个点的前后最长的差为 $1$ 的序列，二分长度判定即可</p>
<p><a href="https://sjzezoj.com/submission/30121">code</a></p>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B. Tree"></a>B. Tree</h3><p><a href="https://sjzezoj.com/problem/981">Tree</a></p>
<p>发现一个点从 $a \rightarrow b$ 之后连通块的变化是先减去与他相邻的点颜色为 $a$ 的数量，然后加上颜色为 $b$ 的数量</p>
<p>开个 map 维护儿子颜色数量即可</p>
<p><a href="https://sjzezoj.com/submission/30122">code</a></p>
<h3 id="C-Backpack"><a href="#C-Backpack" class="headerlink" title="C. Backpack"></a>C. Backpack</h3><p><a href="https://sjzezoj.com/problem/982">Backpack</a></p>
<p>背包没法删除，所以考虑合并</p>
<p>类似一道不能删的区间乘积，分成 $k$ 段，每段处理前后缀的背包，每个 $k$ 区间 $O(W)$ 合并背包即可</p>
<p>复杂度 $O(TnW)$ 巨大卡常题</p>
<p><a href="https://sjzezoj.com/submission/30213">code</a></p>
<h3 id="D-Chain"><a href="#D-Chain" class="headerlink" title="D. Chain"></a>D. Chain</h3><p><a href="https://sjzezoj.com/problem/983">Chain</a></p>
<p>考虑每个点选取 $0/1$ 都是从上一个点的 $0/1$ 转移来的，直接保存每个点的前 $k$ 小的路径，每次 $O(k)$ 归并</p>
<p>总复杂度 $O(nk)$</p>
<p><a href="https://sjzezoj.com/submission/30243">code</a></p>
<p><a href="https://imgtu.com/i/4Mccyn"><img src="https://z3.ax1x.com/2021/09/17/4Mccyn.png" alt="img"></a></p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>背包</tag>
        <tag>归并</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.09.15模拟赛</title>
    <url>/2021/09/16/2021-09-15%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>长梦不多时，短梦无碑记，普天下，梦南柯，人似蚁</p>
<span id="more"></span>

<h2 id="2021-09-15模拟赛"><a href="#2021-09-15模拟赛" class="headerlink" title="2021.09.15模拟赛"></a>2021.09.15模拟赛</h2><h3 id="A-wzoi"><a href="#A-wzoi" class="headerlink" title="A. wzoi"></a>A. wzoi</h3><p><a href="https://sjzezoj.com/problem/977">wzoi</a></p>
<p>贪心的考虑，维护一个栈即可</p>
<p><a href="https://sjzezoj.com/submission/29346">code</a></p>
<h3 id="B-Divisors"><a href="#B-Divisors" class="headerlink" title="B. Divisors"></a>B. Divisors</h3><p><a href="https://sjzezoj.com/problem/972">Divisors</a></p>
<p>非常暴力的把所有的因子分解出来，排序然后统计即可</p>
<p>因为 $10^9$ 内的最多约数只有 $1200$ 左右，所以不是瓶颈，复杂度 $O(m\sqrt n)$</p>
<p><a href="https://sjzezoj.com/submission/29358">code</a></p>
<h3 id="C-Market"><a href="#C-Market" class="headerlink" title="C. Market"></a>C. Market</h3><p><a href="https://sjzezoj.com/problem/973">Market</a></p>
<p>没做出来</p>
<p>$60$ 的暴力考虑到因为时间点只有 $300$ 个所以把每个时间点的答案预处理出来</p>
<p>观察满分的数据范围发现虽然代价很高，但是价值很小。只有 $300$ ，考虑记录 $f_V$ 表示价值为 $V$ 的最小代价，转移这个的复杂度是 $O(n\sum V)$ 的</p>
<p>然后想办法查询，<del>RenaMoe 暴力排序过了</del> ，因为要价值尽可能的大，所以做一个后缀 $\min$ ，就有了单调性，就可以二分查询</p>
<p>复杂度 $O(n\sum v_i+m\log \sum v_i)$</p>
<p><a href="https://sjzezoj.com/submission/29604">code</a></p>
<h3 id="D-动态数点"><a href="#D-动态数点" class="headerlink" title="D. 动态数点"></a>D. 动态数点</h3><p><a href="https://sjzezoj.com/problem/974">动态数点</a></p>
<p>ST 表大力维护区间 $\gcd$ 二分区间长度 $O(n\log n)$ 可过</p>
<p>但是存在 $O(n)$ 做法，因为 $a|b $ 且 $b|c$ $\Rightarrow a|c$ </p>
<p>所以以 $i$ 为左端点，最远能拓展到 $r$ ，那么 $[i,r]$ 这些点都没用，因为他们能拓展到的点都能被 $i$ 拓展到，直接从 $r+1$ 继续</p>
<p>这样每个数字只会被扫描一边，$O(n)$</p>
<p><a href="https://sjzezoj.com/submission/29366">code</a></p>
<h3 id="E-序列"><a href="#E-序列" class="headerlink" title="E. 序列"></a>E. 序列</h3><p><a href="https://sjzezoj.com/problem/975">序列</a></p>
<p>绝对值先去掉，考虑每次循环左移除了第一个数字其他的从 $x-i$ 变成 $x-(i-1)$ </p>
<p>如果原来 $x-i$ 是负数，那么绝对值上就会少 $1$ 贡献，其他的会多 $1$ 贡献</p>
<p>这样记录下有多少个数字减去排列一开始是小于 $0$ 的，然后考虑 $-y$ 会在 $y$ 轮后变成正的，开个桶记录，到那一轮加减对应的 $\mathrm{cnt}$ 即可</p>
<p>特别处理第一个数，他减去 $n$ 后变成负数 $y$ 需要 $-y+i$ 轮</p>
<p><a href="https://sjzezoj.com/submission/29871">code</a></p>
<h3 id="F-最大战略储备"><a href="#F-最大战略储备" class="headerlink" title="F. 最大战略储备"></a>F. 最大战略储备</h3><p><a href="https://sjzezoj.com/problem/891">最大战略储备</a></p>
<p>先从最暴力的 Kruskal 开始，发现如果现在没有边，那么如果选定了一条 $(e.a_i) \rightarrow (e.b_i)$ 的边，所有的 $(e.a_i) \rightarrow (e.b_i)$ 都会选上，因为他们的权值一样，之后如果选定了 $(a_i,f) \rightarrow (b_i,f)$ 的边，因为 $(e.a_i) \rightarrow (e.b_i)$ 之前已经连起来了，所以这两个只需要连一条即可</p>
<p>反过来同理</p>
<p>所以我们想可以记录每行每列现在的连通块个数，每次连行/列边仅需要连列/行连通块数目，这样只需要做 $O(n+m)$ 的 Kruskal 即可</p>
<p><a href="https://sjzezoj.com/submission/29386">code</a></p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.09.13模拟赛</title>
    <url>/2021/09/13/2021-09-13%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>忳郁邑余侘傺兮，吾独穷困乎此时也</p>
<span id="more"></span>

<h2 id="2021-09-13模拟赛"><a href="#2021-09-13模拟赛" class="headerlink" title="2021.09.13模拟赛"></a>2021.09.13模拟赛</h2><h3 id="A-古代龙人的谜题"><a href="#A-古代龙人的谜题" class="headerlink" title="A. 古代龙人的谜题"></a>A. 古代龙人的谜题</h3><p><a href="https://sjzezoj.com/problem/929">古代龙人的谜题</a></p>
<p>能发现成立当且仅当两个最靠左右的 $1$ 在 $1$ 中标号的奇偶性相同</p>
<p>考虑一个点作为右端点的时候，它可以选取自己左右的连续的 $0$ 中的位置，或者选取之前的奇偶性相同的 $1$ 的左边的连续 $0$</p>
<p>就可以 $O(n)$ 统计了</p>
<p><a href="https://sjzezoj.com/submission/28792">code</a></p>
<h3 id="B-石头剪刀布"><a href="#B-石头剪刀布" class="headerlink" title="B. 石头剪刀布"></a>B. 石头剪刀布</h3><p><a href="https://sjzezoj.com/problem/930">石头剪刀布</a></p>
<p>考虑如果最终的结果确定了，所有的比赛过程也就确定了，所以只需要知道最后是谁赢了就能递归建出来序列</p>
<p>因为不太好判断所以可以把三种可能枚举一遍，字典序最小看一下左右子树谁小谁在前面就行</p>
<p>$O(n2^n)$</p>
<p><a href="https://sjzezoj.com/submission/28798">code</a></p>
<h3 id="C-投票"><a href="#C-投票" class="headerlink" title="C. 投票"></a>C. 投票</h3><p><a href="https://sjzezoj.com/problem/931">投票</a></p>
<p>感性理解下每次取两个人投票肯定是要让他们两个投乘不投的概率最大化，所以肯定是选一个能选的最大的和最小的</p>
<p>理性理解下可以考虑如果选了 $m$ 个人，当前选了 $x$ ，那么最后的概率是 $\sum c_ip_x+c’_{i}(1-p_x)$，这是个一次函数，一定要 $p_x$ 最大/最小的时候取到最大值</p>
<p>$c_i$ 没法求，但是不重要，都试试就行</p>
<p>求出来 $i$ 个前后缀 $j$ 个人支持的概率拼起来即可</p>
<p>$O(n^2)$</p>
<p><a href="https://sjzezoj.com/submission/28811">code</a></p>
<h3 id="D-小学组"><a href="#D-小学组" class="headerlink" title="D. 小学组"></a>D. 小学组</h3><p><a href="https://sjzezoj.com/problem/932">小学组</a></p>
<p>确实是小学组，暴力即可</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.09.10模拟赛</title>
    <url>/2021/09/10/2021-09-10%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>渔舟唱晚，响穷彭蠡之滨；雁阵惊寒，声断衡阳之浦。</p>
<span id="more"></span>

<h2 id="2021-09-10模拟赛"><a href="#2021-09-10模拟赛" class="headerlink" title="2021.09.10模拟赛"></a>2021.09.10模拟赛</h2><p>T2没细想，T3大失误 -84 pts</p>
<h3 id="A-Strange"><a href="#A-Strange" class="headerlink" title="A.Strange"></a>A.Strange</h3><p><a href="https://sjzezoj.com/problem/963">Strange</a></p>
<p>考虑只相交的线段 = 所有线段 - 包含的线段 - 不交的线段</p>
<p>不交的线段找询问左端点左边的线段树右端点个数，右边同理</p>
<p>包含的线段先离线下来，按右端点排序，加入线段树区间的左端点，直接在树状数组上查询区间的端点数量即可</p>
<p><a href="https://sjzezoj.com/submission/27842">code</a></p>
<h3 id="B-加冕"><a href="#B-加冕" class="headerlink" title="B.加冕"></a>B.加冕</h3><p><a href="https://sjzezoj.com/problem/964">加冕</a></p>
<p>考虑大力 dp</p>
<p>设 $dp_{S}$ 是达成质因子状态的最小代价</p>
<p>转移 $dp_{S} = \min\limits_{T \sub S}dp_{T}+f(S-T)$</p>
<p>计算 $f(S)$ 可以用同于最短路的方法</p>
<p>以 $p$ 为模数，在模 $p$ 意义下操作 $q\times x$ 和 $q+1$</p>
<p>$dis_0$ 即最小值</p>
<p><a href="https://sjzezoj.com/submission/28042">code</a></p>
<h3 id="C-交错的字符串"><a href="#C-交错的字符串" class="headerlink" title="C.交错的字符串"></a>C.交错的字符串</h3><p><a href="https://sjzezoj.com/problem/965">交错的字符串</a></p>
<p>处理出前一半的哈希值然后和后一半的配对即可</p>
<p>因为 $A+B = A’+B’ \Rightarrow A-A’ =B’-B$</p>
<p>所以记录下哈希值的差值即可</p>
<p><a href="https://sjzezoj.com/submission/27951">code</a></p>
<h3 id="D-爬"><a href="#D-爬" class="headerlink" title="D.爬"></a>D.爬</h3><p><del>爬就爬，我最会爬了</del></p>
<p><a href="https://sjzezoj.com/problem/966">爬</a></p>
<p>叉人神题</p>
<p>大概的思路是贪心的按照 $a_i-b_i$ 排序，然后再不被淹的过程中答案具有单调性（显然 $x$ 天能出去 $x+1$ 也能）</p>
<p>所以二分时间，确定时间后考虑最优策略要么是把前面的一个 $b$ 很大的值最后吃，或者是把后面的一个 $a$ 很大的最后吃</p>
<p>分别特判一下</p>
<p>在找 $b$ 最大的值需要特判一下拿掉了这个值会不会导致中间被淹，而且因为 $a_i-b_i$ 单调递减，所以拿掉就不合法的一定是一个前缀</p>
<p><a href="https://sjzezoj.com/submission/28105">code</a></p>
<h2 id="Extra"><a href="#Extra" class="headerlink" title="Extra."></a>Extra.</h2><h3 id="A-防线"><a href="#A-防线" class="headerlink" title="A.防线"></a>A.防线</h3><p><a href="https://sjzezoj.com/problem/933">防线</a></p>
<p>看起来就很线段树合并</p>
<p>让线段树的节点代表填满最左端的 $1$ 和最右端的 $1$ 中间的最小代价</p>
<p>考虑向上 pushup 的过程</p>
<p>考虑左区间最右的 $1$ 和右区间最左的 $1$</p>
<p>中间的 $r-l-1$ 个 $0$ 一定要他们填满，所以 $r-l-1$ 和当前的答案取 $\max$ 合并</p>
<p>最终最外围的 $m-(r-l+1)$ 个点一定需要这么多次操作，取 $\max$</p>
<p><a href="https://sjzezoj.com/submission/28292">code</a></p>
<h3 id="B-钦定"><a href="#B-钦定" class="headerlink" title="B.钦定"></a>B.钦定</h3><p><a href="https://sjzezoj.com/problem/962">钦定</a></p>
<p>先把没用的点区间，让操作序列单增</p>
<p>反向考虑贡献</p>
<p>当前区间长度如果为 $x$</p>
<p>那么他会用到长度为 $y$ 的区间 $\lfloor\dfrac{x}{y}\rfloor$ 次，和 $x \bmod y$ 的区间一次</p>
<p>如果 $x$ 区间被用过了 $t$ 次</p>
<p>相应的 $y$ 区间会加上 $\lfloor\dfrac{x}{y}\rfloor t$ 次， $x \bmod y$ 用到了 $t$ 次</p>
<p>所以先加入大的区间，反向更新贡献，然后区间长度 $\le n$ 的做一下后缀和就是答案</p>
<p><a href="https://sjzezoj.com/submission/28238">code</a></p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
  </entry>
  <entry>
    <title>2021.09.08模拟赛</title>
    <url>/2021/09/08/2021-09-08%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>回首向来萧瑟处，归去，也无风雨也无晴</p>
<span id="more"></span>

<h2 id="2021-09-08模拟赛"><a href="#2021-09-08模拟赛" class="headerlink" title="2021.09.08模拟赛"></a>2021.09.08模拟赛</h2><p>手速场</p>
<h3 id="A-a"><a href="#A-a" class="headerlink" title="A.a"></a>A.a</h3><p><a href="https://sjzezoj.com/problem/907">a</a></p>
<p>因为 $n$ 非常小，考虑 $O(n^2)$ 枚举上下边界</p>
<p>然后钦定右端点为 $j$ 双指针维护当前能构成 $[l,r]$ 的左右边界即可</p>
<p>$O(n^2m)$</p>
<p><a href="https://sjzezoj.com/submission/27187">code</a></p>
<h3 id="B-b"><a href="#B-b" class="headerlink" title="B.b"></a>B.b</h3><p><a href="https://sjzezoj.com/problem/908">b</a></p>
<p>枚举 $\gcd$ 设 $f_i$ 表示 $\gcd = i | d$ 的方案数</p>
<p>显然 $f_i=\prod(cnt_{j,i}+1)-1$  </p>
<p>$cnt_{j,i}$ 表示第 $j$ 个序列 $i$ 的倍数的个数</p>
<p>$-1$ 减去了空集</p>
<p>莫比乌斯反演即可</p>
<p>$O(nm\ln w)$</p>
<p><a href="https://sjzezoj.com/submission/27189">code</a></p>
<h3 id="C-朝圣"><a href="#C-朝圣" class="headerlink" title="C.朝圣"></a>C.朝圣</h3><p><a href="https://sjzezoj.com/problem/909">朝圣</a></p>
<p>DAG 上大力 dp 即可</p>
<p>$O(nL)$</p>
<p><a href="https://sjzezoj.com/submission/27191">code</a></p>
<h3 id="D-合并集合"><a href="#D-合并集合" class="headerlink" title="D.合并集合"></a>D.合并集合</h3><p><a href="https://sjzezoj.com/problem/934">合并集合</a></p>
<p>复制两倍断环成链然后区间 DP 即可</p>
<p>$O(2^3n^3)$</p>
<p><a href="https://sjzezoj.com/submission/27195">code</a></p>
<h3 id="E-苹果树"><a href="#E-苹果树" class="headerlink" title="E.苹果树"></a>E.苹果树</h3><p><a href="https://sjzezoj.com/problem/935">苹果树</a></p>
<p>删边的弱化版</p>
<p>考虑一个树边和某一个非树边一同删去导致不连通要么是这个树边仅被这一个非树边覆盖，或者没被覆盖</p>
<p>所以没被覆盖的边贡献 $m$ ，所有仅被覆盖一次的树边贡献 $1$</p>
<p><a href="https://sjzezoj.com/submission/27200">code</a></p>
<h3 id="F-d"><a href="#F-d" class="headerlink" title="F.d"></a>F.d</h3><p><a href="https://sjzezoj.com/contest/problem/936">d</a></p>
<p>枚举 $m$ 个删除里多少个删最小的 $a_i$ ，剩下的删最小的 $b_i$ 即可</p>
<p><a href="https://sjzezoj.com/submission/27205">code</a></p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>区间DP</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.09.06模拟赛</title>
    <url>/2021/09/06/2021-09-06%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>Per Aspera Ad Astra</p>
<span id="more"></span>

<h2 id="2021-09-06模拟赛"><a href="#2021-09-06模拟赛" class="headerlink" title="2021.09.06模拟赛"></a>2021.09.06模拟赛</h2><h3 id="A-都市"><a href="#A-都市" class="headerlink" title="A.都市"></a>A.都市</h3><p><a href="https://sjzezoj.com/problem/910">都市</a></p>
<p>考虑要升序输出，把升序的答案数组记作 ${a_i}$</p>
<p>先把所有的数字排个序，前两个数字必然是 $a_1+a_2$ 和 $a_1+a_3$</p>
<p>但是第三个数字不一定是 $a_2+a_3$ ，但只要知道了 $a_2+a_3$ 是谁就可以直接找出来所以的数字了</p>
<p>所以直接枚举 $a_2+a_3$ 是谁就可以递推了，复杂度 $O(n^3)$</p>
<p><a href="https://sjzezoj.com/submission/26881">code</a></p>
<h3 id="B-争辩"><a href="#B-争辩" class="headerlink" title="B. 争辩"></a>B. 争辩</h3><p><a href="https://sjzezoj.com/problem/802">争辩</a></p>
<p>很妙的题目</p>
<p>仔细考虑题目中的限制条件，先考虑 $a$ 是一个排列的情况，比较明显的能发现逆序对数每次减少 $0$ 或 $2$ 个</p>
<p>所以当且仅当它的逆序对数是奇数它是不优美的</p>
<p>而 $a$ 不是一个排列的话，我们可以用那个重复的元素任意的减少逆序对数（<del>我死在这里</del>）</p>
<p>所以只需要算出来 $det(A)$ 和 $perm(A)$ 然后 $\dfrac{\mathrm{perm}(A)-\det(A)}{2}$ 就是所有不优美的和</p>
<p>$\mathrm{perm}(A) = \sum\limits_{p是排列}\prod A_{i,p_i}$</p>
<p>这个东西叫 积和式 无多项式复杂度做法，但是给出的矩阵很特殊，是一个下三角矩阵加上一条对角线</p>
<p>考虑如果是下三角矩阵显然是所有对角线元素的积</p>
<p>但是加上这一条对角线后就需要考虑其他情况</p>
<p>设大小为 $n$ 的这种矩阵的积和式为 $D_n$</p>
<p><a href="https://imgtu.com/i/h4F2Ox"><img src="https://z3.ax1x.com/2021/09/06/h4F2Ox.png" alt="h4F2Ox.png"></a></p>
<p>考虑选了第一行的第一个数，有 $D_n = D_{n-1}A_{1,1}$</p>
<p>如果选了第二个</p>
<p><a href="https://imgtu.com/i/h411Rx"><img src="https://z3.ax1x.com/2021/09/06/h411Rx.png" alt="h411Rx.png"></a></p>
<p>下一行就要选两个蓝色的位置，第一个是 $D_{n-2}A_{2,1}A_{1,2}$ ,第二个需要继续讨论</p>
<p>所以就可以递推下去</p>
<p>加了一条对角线的 $\det(A)$ 也可以这么算</p>
<p><a href="https://sjzezoj.com/submission/26966">code</a></p>
<h3 id="C-Prime"><a href="#C-Prime" class="headerlink" title="C.Prime"></a>C.Prime</h3><p><a href="https://sjzezoj.com/problem/911">Prime</a></p>
<p>区间筛板子</p>
<p><a href="https://sjzezoj.com/submission/26793">code</a></p>
<h3 id="D-Hunter"><a href="#D-Hunter" class="headerlink" title="D.Hunter"></a>D.Hunter</h3><p><a href="https://sjzezoj.com/problem/912">Hunter</a></p>
<p>因为期望具有线性性，所以考虑每个人在 $1$ 之前死的概率求和 $+1$ 即可</p>
<p>答案为 $\sum\dfrac{w_i}{w_1+w_i}$</p>
<p><del>部分分极具误导性</del></p>
<p><a href="https://sjzezoj.com/submission/26929">code</a></p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年8月模拟赛简要题解·下</title>
    <url>/2021/09/03/2021%E5%B9%B48%E6%9C%88%E6%A8%A1%E6%8B%9F%E8%B5%9B%E7%AE%80%E8%A6%81%E9%A2%98%E8%A7%A3%E4%B8%8B/</url>
    <content><![CDATA[<p>人世几回伤往事，山形依旧枕寒流。</p>
<span id="more"></span>

<h2 id="2021-08-17"><a href="#2021-08-17" class="headerlink" title="2021.08.17"></a>2021.08.17</h2><h3 id="A-魔力"><a href="#A-魔力" class="headerlink" title="A.魔力"></a>A.魔力</h3><p><a href="https://sjzezoj.com/problem/559">魔力</a></p>
<p>设 $cnt_i$ 为字符 $i$ 出现的次数，那么题目求的就是所有 $cnt_i$ 均相等的区间个数</p>
<p>因为 $cnt_i$ 不固定，所以做个差分可以发现当且仅当差分为 $0$ 的时候合法</p>
<p>那么从 $1$ 开始拓展记录 $cnt$ 差分，如果出现了两个地方的 $cnt$ 差分数组相同，那么这两个 $cnt$ 差分数组相减就是全 $0$</p>
<p>记录一个 vector 的 map 即可</p>
<p><a href="https://sjzezoj.com/submission/18060">code</a></p>
<h3 id="B-粒子"><a href="#B-粒子" class="headerlink" title="B.粒子"></a>B.粒子</h3><p><a href="https://sjzezoj.com/116/problem/560">粒子</a></p>
<p>就是一大堆一次函数求第一次交点</p>
<p>二分时间即可</p>
<p><a href="https://sjzezoj.com/submission/18105">code</a></p>
<h3 id="C-六"><a href="#C-六" class="headerlink" title="C.六"></a>C.六</h3><p><a href="https://sjzezoj.com/problem/561">六</a></p>
<p>状压</p>
<p>发现只压某个质因子出现的次数是不行的</p>
<p>因为 $(2,3)$ $(6)$ 质因子出现次数相同，但是可以转移的状态不同</p>
<p>还需要记录一个每一对质因子能否同时出现在一个数里的状态</p>
<p>这里只需要二进制 $\dfrac{cnt(cnt-1)}{2}$ 位，质因子是三进制状压</p>
<p>记录一个 pair 去转移即可</p>
<p>考的时候没想到再去记录一个二进制位</p>
<p><a href="https://sjzezoj.com/submission/18424">code</a></p>
<h3 id="D-多重集合问题"><a href="#D-多重集合问题" class="headerlink" title="D.多重集合问题"></a>D.多重集合问题</h3><p><a href="https://sjzezoj.com/problem/623">多重集合问题</a></p>
<p>经典题目，整体二分</p>
<p><a href="https://sjzezoj.com/submission/18154">code</a></p>
<h2 id="2021-08-18"><a href="#2021-08-18" class="headerlink" title="2021.08.18"></a>2021.08.18</h2><h3 id="A-引子"><a href="#A-引子" class="headerlink" title="A.引子"></a>A.引子</h3><p><a href="https://sjzezoj.com/contest/117/problem/624">引子</a></p>
<p>大模拟，注意数字可以是多位数</p>
<p><a href="https://sjzezoj.com/submission/18505">code</a></p>
<h3 id="B-可爱精灵宝贝"><a href="#B-可爱精灵宝贝" class="headerlink" title="B.可爱精灵宝贝"></a>B.可爱精灵宝贝</h3><p><a href="https://sjzezoj.com/contest/117/problem/625">可爱精灵宝贝</a></p>
<p>记录 $dp_{l,r,t,0/1}$ 表示拿完 $[l,r]$ 的物品后时间为 $t$ 且在 左/右 端点上的最大价值</p>
<p>分类讨论转移</p>
<p><a href="https://sjzezoj.com/submission/18796">code</a></p>
<h3 id="C-相互再归的鹅妈妈"><a href="#C-相互再归的鹅妈妈" class="headerlink" title="C.相互再归的鹅妈妈"></a>C.相互再归的鹅妈妈</h3><p><a href="https://sjzezoj.com/problem/626">相互再归的鹅妈妈</a></p>
<p>钦定有些人能选同一个然后斯特林反演</p>
<p>不会写</p>
<h3 id="D-盟誓的文艺复兴"><a href="#D-盟誓的文艺复兴" class="headerlink" title="D.盟誓的文艺复兴"></a>D.盟誓的文艺复兴</h3><p><a href="https://sjzezoj.com/problem/627">盟誓的文艺复兴</a></p>
<p>首先注意到只有 $c=2,3$ 是有意义的，别的都可以拆成 $c=2.3$ 的情况</p>
<p>$c=2$ 的情况就是</p>
<p>$\sum\limits_{i=1}^{\sqrt[3]{n}} \mu^2(i)(\sqrt{\dfrac{n}{i}}-i)$</p>
<p>即枚举无完全平方因子的数，然后乘上能选的数字 ($a&lt;b$)</p>
<p>$c=3$ 比较复杂</p>
<p>先把 $c=2$ 统计过的排除掉</p>
<p>设 $k$ 是满足 $k^2 | ab$ 最大数字</p>
<p>那么 $ab^3 = (\dfrac{ab}{k^2})(bk)^2$</p>
<p>考虑如果之前没被统计过需要满足 $\dfrac{ab}{k^2}&gt;bk \Rightarrow a \ge k^3$</p>
<p>定义 $\mu_3(x) := [\not\exist d^3|x,d\neq 1]$</p>
<p>即没有完全三次方因子</p>
<p>式子是</p>
<p>$\huge\sum\limits_{a=1}^{\sqrt[4]{n}}\mu_3(i)\sum\limits_{k^3\le a}\sum\limits_{b=a+1}^{\sqrt[3]{\frac{n}{a}}}[k^2|ab]\mu^2(\dfrac{ab}{k^2})$</p>
<p>然后设 $g=\gcd(a,k^2),a’=\dfrac{a}{g},k’=\dfrac{k^2}{g},b’=\dfrac{b}{k’}$ （神奇代换，不懂原理）</p>
<p>$\huge\sum\limits_{a=1}^{\sqrt[4]{n}}\mu_3(i)\sum\limits_{k^3\le a}\sum\limits_{b’=\frac{a}{k’}+1}^{\frac{\sqrt[3]{\frac{n}{a}}}{k’}}\mu^2(a’b’)$</p>
<p>$\mu(ab)= \mu(a)\mu(b)[\gcd(a,b)=1]$</p>
<p>所以</p>
<p>$\huge\sum\limits_{a=1}^{\sqrt[4]{n}}\mu_3(i)\sum\limits_{k^3\le a}\mu^2(a’)\sum\limits_{b’=\frac{a}{k’}+1}^{\frac{\sqrt[3]{\frac{n}{a}}}{k’}}\mu^2(b’)[\gcd(a’,b’)=1]$</p>
<p>反演掉 $[\gcd(a,b)=1]$</p>
<p>$\huge\sum\limits_{a=1}^{\sqrt[4]{n}}\mu_3(i)\sum\limits_{k^3\le a}\mu^2(a’)\sum\limits_{d|a’}\mu(d)\sum\limits_{b’=\frac{a}{k’}+1}^{\frac{\sqrt[3]{\frac{n}{a}}}{k’}}[d|b’]\mu^2(b’)$</p>
<p>枚举的其实都挺小的，可以大力预处理</p>
<p><a href="https://sjzezoj.com/submission/18993">code</a></p>
<h2 id="2021-08-19"><a href="#2021-08-19" class="headerlink" title="2021.08.19"></a>2021.08.19</h2><h3 id="A-没有硝烟的战争"><a href="#A-没有硝烟的战争" class="headerlink" title="A.没有硝烟的战争"></a>A.没有硝烟的战争</h3><p><a href="https://sjzezoj.com/problem/632">没有硝烟的战争</a></p>
<p>类似 SG 的方法，记录 $dp_{i,j}$ 表示第 $i$ 个动物报了 $j$ 能不能赢</p>
<p>如果它的下一个是同种族并且 $[j+1,j+k]$ 中有一个必胜他就必胜</p>
<p>否则必败，下一个是不同种族且 $[j+1,j+k]$ 中有一个必胜他就必败，否则必胜</p>
<p>大力转移 $O((n+m)m)$</p>
<p><a href="https://sjzezoj.com/submission/19194">code</a></p>
<h3 id="B-秘密通道"><a href="#B-秘密通道" class="headerlink" title="B.秘密通道"></a>B.秘密通道</h3><p><a href="https://sjzezoj.com/problem/633">秘密通道</a></p>
<p>能连的边全连上跑最短路</p>
<p>具体来说是把一个位置上下左右的四个墙按到最近的墙的距离连上</p>
<p><a href="https://sjzezoj.com/submission/19158">code</a></p>
<h3 id="C-城市猎人"><a href="#C-城市猎人" class="headerlink" title="C.城市猎人"></a>C.城市猎人</h3><p><a href="https://sjzezoj.com/contest/119/problem/634">城市猎人</a></p>
<p>每天会把 $m-i+1$ 的倍数的城市全都连起来，类似克鲁斯卡尔重构树，记录连接的过成为一个树，找 LCA 即可</p>
<p><a href="https://sjzezoj.com/submission/19253">code</a></p>
<h3 id="D-无限远点的牵牛星"><a href="#D-无限远点的牵牛星" class="headerlink" title="D.无限远点的牵牛星"></a>D.无限远点的牵牛星</h3><p><a href="https://ycsgg.github.io/2021/08/19/UER-6-%E9%80%83%E8%B7%91/">题解</a></p>
<h2 id="2021-08-20"><a href="#2021-08-20" class="headerlink" title="2021.08.20"></a>2021.08.20</h2><h3 id="A-路径计数"><a href="#A-路径计数" class="headerlink" title="A.路径计数"></a>A.路径计数</h3><p><a href="https://sjzezoj.com/problem/508">路径计数</a></p>
<p>四点四边的无向图欧拉回路技术</p>
<p>不太可做</p>
<p>考虑给无向边定向，实际上定了一个向因为要有欧拉回路所以剩下的也都出来了</p>
<p>枚举第一条边多少个边定正向，跑 BEST 定理</p>
<p><a href="https://sjzezoj.com/submission/20005">code</a></p>
<h3 id="B-BRT"><a href="#B-BRT" class="headerlink" title="B.BRT"></a>B.BRT</h3><p><a href="https://sjzezoj.com/problem/562">BRT</a></p>
<p>记忆化可以水过去</p>
<p>没有梦想，没敢写</p>
<p><a href="https://sjzezoj.com/submission/20056">code</a></p>
<h3 id="C-xor"><a href="#C-xor" class="headerlink" title="C.xor"></a>C.xor</h3><p><a href="https://sjzezoj.com/problem/563">xor</a></p>
<p>见 <a href="https://www.luogu.com.cn/problem/CF241B">Friends</a></p>
<p><a href="https://sjzezoj.com/submission/19798">code</a></p>
<h3 id="D-核糖"><a href="#D-核糖" class="headerlink" title="D.核糖"></a>D.核糖</h3><p><a href="https://sjzezoj.com/problem/564">核糖</a></p>
<p>同 [旅行规划]</p>
<p>就是区间加等差数列，区间查最大值</p>
<p>分块，块内维护凸包即可</p>
<p>（然而暴力可过</p>
<p><a href="https://sjzezoj.com/submission/19692">核糖</a></p>
<h2 id="2021-08-21"><a href="#2021-08-21" class="headerlink" title="2021.08.21"></a>2021.08.21</h2><h3 id="A-赛"><a href="#A-赛" class="headerlink" title="A.赛"></a>A.赛</h3><p><a href="https://sjzezoj.com/problem/749">赛</a></p>
<p><del>wqs二分</del></p>
<p>贪心的考虑先选两个人都喜欢的，然后选各自喜欢的，最后选不喜欢的补齐</p>
<p>需要查询前 $k$ 小，可以用可删堆做，或者干脆排完序拿指针模拟</p>
<p>挺难写的</p>
<p><a href="https://sjzezoj.com/submission/20210">code</a></p>
<h3 id="B-Merchant"><a href="#B-Merchant" class="headerlink" title="B.Merchant"></a>B.Merchant</h3><p><a href="https://sjzezoj.com/problem/750">Merchant</a></p>
<p>一堆一次函数，求前 $m$ 大总和超过 $S$ 的最小时间</p>
<p>虽然前 $m$ 大不随时间单调，但是一定呈现一个先降后升或上升的形式，所以特判 $0$ 是否有解即可</p>
<p><a href="https://sjzezoj.com/submission/20204">code</a></p>
<h3 id="C-Equation"><a href="#C-Equation" class="headerlink" title="C.Equation"></a>C.Equation</h3><p><a href="https://sjzezoj.com/problem/751">Equation</a></p>
<p>手动处理下，每个点都能表示成 $x_1\pm w$ 的形式，可以 dfs 一遍预处理符号</p>
<p>修改操作是是一个子树的修改，查询只要知道 $w$ 和符号就能解方程</p>
<p>没开 long long 挂大分</p>
<p><a href="https://sjzezoj.com/submission/20535">code</a></p>
<h3 id="D-Rectangle"><a href="#D-Rectangle" class="headerlink" title="D.Rectangle"></a>D.Rectangle</h3><p><a href="https://sjzezoj.com/problem/752">Rectangle</a></p>
<p>暂咕</p>
<p><a href="https://sjzezoj.com/submission/20753">code</a></p>
<h2 id="2021-08-23"><a href="#2021-08-23" class="headerlink" title="2021.08.23"></a>2021.08.23</h2><h3 id="A-xor"><a href="#A-xor" class="headerlink" title="A.xor"></a>A.xor</h3><p><a href="https://sjzezoj.com/problem/773">xor</a></p>
<p>先前缀异或一下转化成区间内两个点最大异或值</p>
<p>考虑大力分块，$pre_{i,j}$ 表示块 $i$ ，第 $j$ 位前缀最大两点异或值</p>
<p>用可持久化 Trie 找即可</p>
<p>$O((n+q)\sqrt n\log w)$</p>
<p><a href="https://sjzezoj.com/submission/21072">code</a></p>
<h3 id="B-magic"><a href="#B-magic" class="headerlink" title="B.magic"></a>B.magic</h3><p><a href="https://sjzezoj.com/problem/774">magic</a></p>
<p>字符集巨大的 AC 自动机</p>
<p>考虑 AC 自动机建立 fail 指针的过程，是要继承自 fail 的转移边，如果字符集很大暴力扫是不可取的，但是继承这个操作可以想到可持久化数据结构，用主席树就可以很好的维护树上的继承关系</p>
<p>主席树太不熟练了，写挂了调到考完</p>
<p><a href="https://sjzezoj.com/submission/21207">code</a></p>
<h3 id="C-strGame"><a href="#C-strGame" class="headerlink" title="C.strGame"></a>C.strGame</h3><p><a href="https://sjzezoj.com/problem/775">strGame</a></p>
<p>类似SG，但是多局之间有影响，考虑多分些状态表示必胜，必败，能控制必胜必败和被控制</p>
<p>Trie 上 dfs 求出状态</p>
<p>如果是必胜那么只能赢奇数轮，能控制必胜必败就一定能赢</p>
<p>否则必败</p>
<p><a href="https://sjzezoj.com/submission/20949">code</a></p>
<h3 id="D-神秘数问题"><a href="#D-神秘数问题" class="headerlink" title="D.神秘数问题"></a>D.神秘数问题</h3><p><a href="https://uoj.ac/contest/20/problem/140">被粉碎的数字</a></p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
  </entry>
  <entry>
    <title>2021.09.03模拟赛</title>
    <url>/2021/09/03/2021-09-03%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>莫听穿林打叶声，何妨吟啸且徐行</p>
<span id="more"></span>

<h2 id="2021-09-03模拟赛"><a href="#2021-09-03模拟赛" class="headerlink" title="2021.09.03模拟赛"></a>2021.09.03模拟赛</h2><h3 id="A-养花"><a href="#A-养花" class="headerlink" title="A. 养花"></a>A. 养花</h3><p><a href="https://sjzezoj.com/problem/895">养花</a></p>
<p>经典分块题</p>
<p>考虑处理出来每个块里 $\bmod x$ 的最大值，贪心的考虑 $nx-1$ 是最大值，如果没有就继续向前扫，直到找到，这是一个前缀 $\max$ 过程</p>
<p>开一个桶记录有那些数，做个前缀 $\max$ 就可以 $O(k\ln k)$ 来计算每一个块的答案，预处理是 $O(Bk\ln k)$</p>
<p>查询暴力查即可，$O(B)$ 最终块长取 $O(\sqrt{k\ln k})$ 即可</p>
<p><a href="https://sjzezoj.com/submission/25737">code</a></p>
<h3 id="B-折射"><a href="#B-折射" class="headerlink" title="B.折射"></a>B.折射</h3><p>先转换成从下往上射的图形，长这样</p>
<p><a href="https://imgtu.com/i/h6j5TS"><img src="https://z3.ax1x.com/2021/09/03/h6j5TS.png" alt="h6j5TS.png"></a></p>
<p>发现按 $y$ 排序需要查询一个矩形内符合条件的方案，不太好做，所以改为按 $x$ 排序</p>
<p>那么发现因为两次入射的方向需要不同，记 $dp_{x,0/1}$ 表示从左下还是右下入射</p>
<p>转移的时候从自己向前枚举，遇到比自己高的就把自己的方案加给他，否则把他的方案加给自己</p>
<p>考虑为啥是对的</p>
<p>因为大的情况是从小的拼起来的，所以只需要证明最小的不合法情况不会被计算</p>
<p><a href="https://imgtu.com/i/h6jjmV"><img src="https://z3.ax1x.com/2021/09/03/h6jjmV.png" alt="h6jjmV.png"></a></p>
<p>这样显然不会被统计，因为要求两次转移的 $0/1$ 不同</p>
<p><a href="https://imgtu.com/i/h6vF61"><img src="https://z3.ax1x.com/2021/09/03/h6vF61.png" alt="h6vF61.png"></a></p>
<p>这样子考虑计算最右边的点的时候先会更新最上面的点，这时候下面的点的方案数还没有贡献到她，所以不会计算这条路径</p>
<p><a href="https://sjzezoj.com/submission/25617">code</a></p>
<h3 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C. 字符串"></a>C. 字符串</h3><p>考虑一个位置 $i$ 如果 $2i-1 \le n$ 的话那么必须 $2i-1$ 这个点合法且自己能够翻转得到 $2i-1$</p>
<p>大于 $n$ 只需要这一段后缀和原串后缀匹配即可</p>
<p><a href="https://sjzezoj.com/submission/25618">code</a></p>
<h3 id="D-施工"><a href="#D-施工" class="headerlink" title="D. 施工"></a>D. 施工</h3><p>考虑我们的最优策略是把一段填平</p>
<p>而且一定是一段谷底，即先减后增的，可以反证</p>
<p>那么设 $dp_{i}$ 当前点为 $i$ 高度为 $h_i$ 的最小值，有 $dp_i = \min(dp_j + \sum\limits_{k=j+1}^{i}(t-h_k)^2+c\times|h_i-t+h_j-t|)$</p>
<p>把后面的式子拆开可以发现是个关于 $t$ 的二次函数，可以 $O(1)$ 计算</p>
<p>所以就需要优化枚举 $j$ </p>
<p>因为是把中间填平，所以需要保证枚举的两个端点是大于区间里的高度的，而且因为只需要填谷底，不要填单调递减/增的地方，可以拿单调栈维护一下当前能更新的元素，前后放极大值辅助更新，因为每个点只会被进栈一次，复杂度 $O(n)$</p>
<p><a href="https://sjzezoj.com/submission/25987">code</a></p>
<h3 id="Bonus-糖果"><a href="#Bonus-糖果" class="headerlink" title="Bonus. 糖果"></a>Bonus. 糖果</h3><p>求 $n$ 个点环大小为 $m$ 的基环树</p>
<p>考虑钦点 $m$ 个点作为环，乘上环同构的方案数 $\binom{n}{m}\dfrac{(m-1)!}{2}$</p>
<p>这样的话就是把一个大小为 $m$ 的环和 $n-m$ 个点拼成一个树的方案</p>
<p>purfer 序列的结论: $k$ 个大小分别为 $\mathrm{siz}_i$ 的连通块拼成树方案数为 $\prod \mathrm{siz}_in^{k-2}$</p>
<p><a href="https://ycsgg.github.io/2021/08/08/WC2019-%E6%95%B0%E6%A0%91/">证明</a></p>
<p>现在是 $n-m+1$ 个连通块，有一个大小为 $m$ 剩下的都是 $1$ </p>
<p>总方案数 $\binom{n}{m}\dfrac{(m-1)!}{2}m\times n^{n-m-1}$</p>
<p>需要特判掉 $n=m$ 和 $m \le 2$ 的情况</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>计数</tag>
        <tag>字符串</tag>
        <tag>分块</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年8月模拟赛简要题解·上</title>
    <url>/2021/08/27/2021%E5%B9%B48%E6%9C%88%E6%A8%A1%E6%8B%9F%E8%B5%9B%E7%AE%80%E8%A6%81%E9%A2%98%E8%A7%A3%E4%B8%8A/</url>
    <content><![CDATA[<p>醉后不知天在水，满船清梦压星河</p>
<span id="more"></span>

<h2 id="2021-08-05"><a href="#2021-08-05" class="headerlink" title="2021.08.05"></a>2021.08.05</h2><h3 id="A-Sign"><a href="#A-Sign" class="headerlink" title="A. Sign"></a>A. Sign</h3><p><a href="https://sjzezoj.com/problem/565">Sign</a></p>
<p>签到题，处理每条边贡献即可</p>
<p><a href="https://sjzezoj.com/submission/15638">code</a></p>
<h3 id="B-Map"><a href="#B-Map" class="headerlink" title="B. Map"></a>B. Map</h3><p><a href="https://sjzezoj.com/problem/566">Map</a></p>
<p>考场上直接大力找规律找出来了，答案是 $\dfrac{\dfrac{(n-1)^t-(-1)^t}{n}+(-1)^t}{(n-1)^t}$</p>
<p>实际上列个 DP 式子就能推出来</p>
<p>然后忘了对 n 取模挂分</p>
<p><a href="https://sjzezoj.com/submission/15635">code</a></p>
<h3 id="C-Path"><a href="#C-Path" class="headerlink" title="C. Path"></a>C. Path</h3><p><a href="https://sjzezoj.com/problem/567">Path</a></p>
<p>线段树优化建图裸题</p>
<p><a href="https://sjzezoj.com/submission/15615">code</a></p>
<h3 id="D-星系探索"><a href="#D-星系探索" class="headerlink" title="D. 星系探索"></a>D. 星系探索</h3><p><a href="https://sjzezoj.com/problem/568">星系探索</a></p>
<p>ETT 题，但是因为只用换子树和子树加，只用 Splay 维护括号序也是可以的</p>
<p>没开 long long 挂了50</p>
<p><a href="https://sjzezoj.com/submission/15639">code</a></p>
<h2 id="2021-08-09"><a href="#2021-08-09" class="headerlink" title="2021.08.09"></a>2021.08.09</h2><h3 id="A-龙妹妹喝牛奶"><a href="#A-龙妹妹喝牛奶" class="headerlink" title="A. 龙妹妹喝牛奶"></a>A. 龙妹妹喝牛奶</h3><p><a href="https://sjzezoj.com/problem/579">龙妹妹喝牛奶</a></p>
<p>单独考虑每个点被选上的概率是 $1-(1-\dfrac{(2x(n-x+1)-1)\times(2y(m-y)-1)}{n^2m^2})^k$</p>
<p><a href="https://sjzezoj.com/submission/16099">code</a></p>
<h3 id="B-枯法者训练"><a href="#B-枯法者训练" class="headerlink" title="B.枯法者训练"></a>B.枯法者训练</h3><p><a href="https://sjzezoj.com/problem/580">枯法者训练</a></p>
<p>同余最短路板子，选定一个 mod ，把别的数字表示成 $x\times mod+r$ 的形式然后跑模意义下每个 $r$ 需要多少个 $mod$</p>
<p>选择最小的 $a_i$ 使得点数最少</p>
<p><a href="https://sjzezoj.com/submission/16097">code</a></p>
<h3 id="C-没名字"><a href="#C-没名字" class="headerlink" title="C. 没名字"></a>C. 没名字</h3><p><a href="https://sjzezoj.com/problem/581">没名字</a></p>
<p>EX 的推柿子题</p>
<p>忽略掉解直线方程的部分 <del>其实是我忘了而且懒得再推了</del></p>
<p>最后要找到 $Ax^2+By^2+Cx+Dy+Exy$ 的最小值，并且系数可以 $O(1)$ 维护</p>
<p>先对一个变量求偏导，接出来之后带入进去，就能得到一个一元二次函数，找到极值即可</p>
<p>不能直接解俩偏导是因为分母可能为零，图像上表示为一条直线都是最小值</p>
<p><a href="https://sjzezoj.com/submission/16135">code</a></p>
<h3 id="D-线段树"><a href="#D-线段树" class="headerlink" title="D. 线段树"></a>D. 线段树</h3><p><a href="https://sjzezoj.com/problem/582">线段树</a></p>
<p>$O(n^3)$ 区间DP，问就是不可能跑满 + 常数极小</p>
<p><a href="https://sjzezoj.com/submission/16102">code</a></p>
<h2 id="2021-08-13"><a href="#2021-08-13" class="headerlink" title="2021.08.13"></a>2021.08.13</h2><h3 id="A-殖民计划"><a href="#A-殖民计划" class="headerlink" title="A.殖民计划"></a>A.殖民计划</h3><p><a href="https://sjzezoj.com/problem/617">殖民计划</a></p>
<p>没改，口胡了</p>
<p>前一半数据点暴力 dfs ，发现后一半数据点的边数和点数接近，建出 dfs 树后对每个非树边暴力分类讨论</p>
<h3 id="B-DBW的黄金"><a href="#B-DBW的黄金" class="headerlink" title="B. DBW的黄金"></a>B. DBW的黄金</h3><p><a href="https://sjzezoj.com/problem/618">DBW的黄金</a></p>
<p>考虑 $dp_{i,j}$ 表示第 $i$ 个人进贡 $j$ 黄金的方案数，有 $dp_{i,j} = \sum dp_{i-1,k} - \sum\limits_{k|j}dp_{i-1,k}$</p>
<p>观察下发现如果从 $dp_{1,p}$ 开始转移，每个数字都只会被他的素因数转移到它的指数次，并且与素因子具体是什么无关</p>
<p>所以设 $dp_{i,S} = \sum dp_{i,j}$ j 的质因子指数集合为 S</p>
<p>打个表能发现这个组合不超过 $200$ 就可以 $O(200^3\log n)$ 矩阵快速幂了</p>
<p>取模不充分挂分</p>
<p><a href="https://sjzezoj.com/submission/16492">code</a></p>
<h3 id="C-测试数据"><a href="#C-测试数据" class="headerlink" title="C. 测试数据"></a>C. 测试数据</h3><p><a href="https://sjzezoj.com/problem/619">测试数据</a></p>
<p>因为它只会问一个点的值，我们考虑一个点能被那些修改操作影响</p>
<p>把询问序列按 $S \to T$ 排列，发现这一个点向上跳，碰到有交集的区间就合并，最后查询这一个大区间的 $\max$ 即可</p>
<p>问题在于怎么快速的向上找到这个大区间</p>
<p>把左右端点分别考虑，左端点只想左右，右端点同理，所以我们把区间挂在线段树上，然后查询第一个碰到的区间就是他的上一个能合并的区间，按这个关系建树，树上倍增找到最大的左右端点即可</p>
<p><a href="https://sjzezoj.com/submission/17276">code</a></p>
<h3 id="D-电车"><a href="#D-电车" class="headerlink" title="D. 电车"></a>D. 电车</h3><p><a href="https://sjzezoj.com/problem/620">电车</a></p>
<p>贪心的考虑下坐车的顺序一定是先快再次快然后慢</p>
<p>所以快车站把区间划分成了几个子区间</p>
<p>考虑每个子区间里能坐慢车到达的点就没必要建站了，不然会浪费距离</p>
<p>在第一个慢车到不了的地方建次快车站，然后按照每个区间距离目标时间剩下时间的多少，优先给剩的贪心建站即可</p>
<p><a href="https://sjzezoj.com/submission/16388">code</a></p>
<h2 id="2021-08-14"><a href="#2021-08-14" class="headerlink" title="2021.08.14"></a>2021.08.14</h2><h3 id="A-世界线"><a href="#A-世界线" class="headerlink" title="A. 世界线"></a>A. 世界线</h3><p><a href="https://sjzezoj.com/problem/124">世界线</a></p>
<p>卡空间屑题，分成两块维护前一半和后一半的连通性就可以避免空间爆炸</p>
<p><a href="https://sjzezoj.com/submission/16692">code</a></p>
<h3 id="B-欧拉回路"><a href="#B-欧拉回路" class="headerlink" title="B. 欧拉回路"></a>B. 欧拉回路</h3><p><a href="https://sjzezoj.com/problem/539">欧拉回路</a></p>
<p>欧拉定理 $v-e+f=2$</p>
<p>计算几何把所有交点算出来去重，然后算新增的边用欧拉定理即可</p>
<p><a href="https://sjzezoj.com/submission/17168">code</a></p>
<h3 id="C-光线追踪"><a href="#C-光线追踪" class="headerlink" title="C. 光线追踪"></a>C. 光线追踪</h3><p><a href="https://sjzezoj.com/contest/111/problem/540">光线追踪</a></p>
<p>一个矩形只会有下边和左边有用，而 $x,y$ 是独立的，可以分别维护</p>
<p>所以只用解决一维的情况，加入一条线段其实就是把它的左端点到右端点这一段斜率的线覆盖住了，所以先把所有的斜率离散化下来然后线段树上覆盖即可</p>
<p>精度需要 long double，挂分</p>
<p><a href="https://sjzezoj.com/submission/17235">code</a></p>
<h3 id="D-是否"><a href="#D-是否" class="headerlink" title="D. 是否"></a>D. 是否</h3><p><a href="https://sjzezoj.com/problem/541">是否</a></p>
<p>原题 AGC 的 Yes or No</p>
<p>考虑如果 Yes 多就尽可能选 Yes 是没问题的，按照还剩下的 Yes/No 数量为坐标轴建系，我们回答的路径就是一个不断靠近 $y=x$ 的路径</p>
<p>所以 $\max(n,m)$ 是必然能猜到的，主要是计算 $y=x$ 上能对几个</p>
<p>因为有 $\dfrac{1}{2}$ 的概率猜对，所以要统计经过 $y=x$ 的路径个数，即 $\sum\limits_{i=1}^{\max(n,m)}\binom{2i}{i}\binom{n-i+m-i}{n-i}$</p>
<p><a href="https://sjzezoj.com/submission/17152">code</a></p>
<h2 id="2021-08-16"><a href="#2021-08-16" class="headerlink" title="2021.08.16"></a>2021.08.16</h2><h3 id="A-地中海气候"><a href="#A-地中海气候" class="headerlink" title="A. 地中海气候"></a>A. 地中海气候</h3><p><a href="https://sjzezoj.com/problem/545">地中海气候</a></p>
<p>先把 $S$ 中最后一个拿出来，就变成了插入 - 取出的循环，思考一下就能发现要贪心取最大值，用堆的就会 $O(nk\log n)$ TLE</p>
<p>发现其实最大值只能不断减小，因为如果下一个拿出来的比较大，下一个人会直接取走</p>
<p>所以用桶维护即可（顺便这题极致卡常，1s根本不过去，std都过不去）</p>
<p><a href="https://sjzezoj.com/submission/17617">code</a></p>
<h3 id="B-东非大裂谷"><a href="#B-东非大裂谷" class="headerlink" title="B. 东非大裂谷"></a>B. 东非大裂谷</h3><p><a href="https://sjzezoj.com/problem/546">东非大裂谷</a></p>
<p>显然划分的链的两端一定是最大最小值，而且一定是单调的，所以记录 $dp_{x,0/1}$ 表示当前点是最大/最小值，而且因为是单调的，所以可以用差分得到最大-最小的值</p>
<p><a href="https://sjzezoj.com/submission/17369">code</a></p>
<h3 id="C-地转偏向力"><a href="#C-地转偏向力" class="headerlink" title="C. 地转偏向力"></a>C. 地转偏向力</h3><p><a href="https://sjzezoj.com/problem/547">地转偏向力</a></p>
<p>数据保证边长是 $5$ 的倍数，所以可以把它划分成若干 $5 \times 5$ 的小格子，然后爆搜 $5 \times 5$ 的各种方案，拼接起来</p>
<p>实际上挺难写的，没写</p>
<h3 id="D-k子串"><a href="#D-k子串" class="headerlink" title="D. k子串"></a>D. k子串</h3><p> <a href="https://sjzezoj.com/problem/622">k子串</a></p>
<p>考虑一个大子串的 border 如果在大子串去掉头尾后自己也去掉头尾仍然是一个 border</p>
<p>也就是每次缩减答案至少是 $x-2$</p>
<p>反过来考虑每次向大拓展答案最多是 $x+2$ 类似 height 数组的复杂度，这样最多是 $O(n)$ 的</p>
<p><a href="https://sjzezoj.com/submission/17456">code</a></p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>数据结构</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>UER 6 逃跑</title>
    <url>/2021/08/19/UER-6-%E9%80%83%E8%B7%91/</url>
    <content><![CDATA[<p>模拟赛题</p>
<span id="more"></span>

<p>一句话题意：二维平面带权随机游走经过不同位置的方差</p>
<p>设 $w=\sum w_i$</p>
<p>因为 $\mathrm{Var}(X)=E(X^2)-E(X)^2$</p>
<p>所以我们仅需要求出来 $X^2$ 和 $X$ 的期望</p>
<p> $X$ 的期望我们可以考虑每个点的贡献，我们希望统计出经过某一个点然后再也不经过的方案数</p>
<p>设 $W(i,x,y)$ 为行走了 $i$ 步最终到 $(x,y)$ 的带权方案数，可以简单递推</p>
<p>$g_i$ 表示走了 $i$ 步且不经过 $(0,0)$ 的方案数</p>
<p>有 $E(X) =\sum\limits_{i}^{n}\sum\limits_{(x,y)}W(i,x,y)g_{n-i}$</p>
<p>也就是走到了 $(x,y)$ 并且剩下的步数不返回来</p>
<p>$E(X^2)$ 并不好直接统计，考虑 $x^2 = 2\binom{x}{2} +x$</p>
<p>前一部分是所有有序的相互到达点对的数量，后面就是 $X$</p>
<p>那么设 $R(i,x,y)$ 表示走了 $i$ 步，到了 $(x,y)$ 不经过 $0$ 点的方案数</p>
<p>$S(i,x,y)$ 表示走了 $i$ 步，回到 $(0,0)$ 且中间经过了 $(x,y)$ 的方案数</p>
<p>有 $R(i,x,y) = W(i,x,y) - \sum\limits_{j=1}^{i}W(j,0,0)R(i-j,x,y)$</p>
<p>$S(i,x,y) = \sum\limits_{j=1}^{i}W(j,x,y)R(i-j,-x,-y)$</p>
<p>都比较显然</p>
<p>那么设 $F(i,x,y)$  表示走了 $i$ 步，存在一个 $(a,b)$ 为第一次到达且最终第一次到达 $(a+x,b+y)$</p>
<p>这样 $E(\binom{x}{2})=\sum\limits_{i=0}^{n}\sum\limits_{(a,b)\neq(0,0)}F(i,a,b)w^{n-i}$</p>
<p>这是所有有序对的个数</p>
<p>考虑求 $F(i,x,y)$</p>
<p>一开始有 $F(i,x,y) = \sum\limits_{j=0}^{i-1}g_jW(i-j,x,y)$</p>
<p>考虑减去不合法的方案数</p>
<p>先减去 $(a+x,b+y) \to (a,b) \to (a+x,b+y)$ 的方案数</p>
<p>$F(i,x,y) \gets F(i,x,y)-\sum\limits_{j=0}^{i-1}g_jS(i-j,-x,-y)$</p>
<p>然后要减去 $(a,b) \to (a+x,b+y) \to (a,b) \to (a+x,b+y)$ 的方案</p>
<p>即 $\sum\limits_{j=0}^{i-1}F(j,x,y)W(i-j,0,0)$</p>
<p>不过第一步容斥已经减掉了一部分，要加回来，所以</p>
<p>$F(i,x,y) \gets F(i,x,y) - \sum\limits_{j=0}^{i-1}F(j,x,y)(W(i-j,0,0)-S(i-j,-x,-y))$</p>
<p>$O(n^4)$</p>
]]></content>
      <categories>
        <category>模拟赛</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>WC2019 数树</title>
    <url>/2021/08/08/WC2019-%E6%95%B0%E6%A0%91/</url>
    <content><![CDATA[<p>《从数树开始的数数生活》</p>
<span id="more"></span>

<p>求 $\sum\limits_{T_1}\sum\limits_{T_2} y^{n-|T_1 \cap T_2|}$ $T_1,T_2$ 是两个树的边集， $OP $ 为 $0,1,2$ 分别是给出两棵树，给出一颗树和不给出树</p>
<p>upd : 可能有 $y,y^{-1}$ 混用的问题，结合上下文大概能知道啥意思</p>
<h2 id="OP-0"><a href="#OP-0" class="headerlink" title="OP = 0"></a>OP = 0</h2><p>开个 set 即可</p>
<h2 id="OP-1"><a href="#OP-1" class="headerlink" title="OP = 1"></a>OP = 1</h2><p>我们先钦定选取了集合 $E$  作为交集</p>
<p>”答案“为 $\sum\limits_{E} y^{n-|E|} F(E)$  $F(E)$ 为交集为 $E$ 的方案数，当然这个 $E$ 是至少的交集，还需要容斥</p>
<p>考虑如果我们选取了某些边，那么原树一定会被分割成几个连通块，我们需要求出这几个连通块连成一个树的方案数</p>
<p>假设分割成了 $m$ 个连通块，<del>可知答案为$n^{m-2}\prod \rm{siz}_i$</del></p>
<p>把连通块看成一个点，从 purfer 序列的角度考虑，一个出现了 $d_i$ 次的点在原图中度数为 $d_i+1$</p>
<p>那么连通块之间可以连边，贡献就是 $\rm {siz}_i^{d_i+1}$</p>
<p>那么枚举 purfer 序列，就是 $\sum \limits_{\sum d_i=m-2}\dfrac{m!}{\prod\limits_{i=1}^{m} d_i!} \prod\mathrm{siz}_i^{d_i+1}$</p>
<p>$=m!\sum\limits_{\sum d_i = m-2} \prod\limits_{i=1}^{m}\dfrac{\mathrm {siz}_i^{d_i+1}}{d_i!}$</p>
<p>$=m!\prod\limits_{i=1}^{m}\mathrm{siz}_i^{d_i}\sum\limits_{\sum d_i =m-2}\prod \dfrac{\mathrm{siz}_i^{d_i}}{d_i!}$</p>
<p>考虑 $\sum\limits_{\sum d_i =m-2}$ 这个条件，如果我们给后面的 $\prod$ 加一个占位的 $x^i$ 那么就是提取了 $m-2$ 项的系数</p>
<p>那么设 $G_k(x)=\sum \dfrac{\mathrm{siz}_{k}^i}{i!}x^i=e^{\mathrm{siz}_kx}$</p>
<p>那么 $\prod G_k(x) = \exp { \sum \mathrm{siz}_i }=e^n$</p>
<p>那么原式为 $m!\prod \mathrm{siz}_i[x^{m-2}]e^n=n^{m-2}\prod \mathrm{siz}_i$</p>
<p>答案为 $\sum\limits_{E} y^{n-|E|}F(E) = \sum\limits_{E}y^{n-|E|}n^{n-|E|-2}\prod \mathrm{siz}_i=y^nn^{n-2}\sum\limits_{E}{(yn)}^{-|E|}\prod \mathrm{siz}_i$</p>
<p>枚举边集和容斥都是指数级的，先解决枚举的问题</p>
<p>考虑比较麻烦的 $ \prod \mathrm{siz}_i $ ，可以组合意义理解为每个连通块选一个点的方案数，那么设 $dp_{x,0/1}$ 表示以 $x$ 为根的子树连通块，是否已经选点的方案数乘上贡献</p>
<p>那么枚举当前边在不在 $E$ 中然后 dp 即可做到线性</p>
<p>具体的有</p>
<p>当边 $(x,v)$ 在 $E$ 中时，有</p>
<p>$$dp_{x,0} \gets dp_{x,0} \times dp_{v,0} \times (yn)^{-1} $$<br>$$dp_{x,1} \gets (dp_{x,1} \times dp_{v,0}+dp_{x,0}\times dp_{v,1}) \times (yn)^{-1} $$</p>
<p>否则，有</p>
<p>$$dp_{x,0} \gets dp_{x,0} \times dp_{v,1} $$<br>$$ dp_{x,1} \gets dp_{x,1}\times dp_{v,1}$$</p>
<p>$dp_{1,1}$ 即所求</p>
<p>然后是容斥的解决，考虑我们枚举的集合最终的真重合的边集 $S$ ，那么实际上它会被算 $\binom{|S|}{|E|}$ 次，那么因为我们枚举了所有的子集，所以他被算的答案就是 $\sum\limits_{i=0}^{|S|}\binom{|S|}{i}y^i=(y+1)^{|S|}$ 所以只要令 $y \to y-1$ 就可以得到正确的贡献</p>
<h2 id="OP-2"><a href="#OP-2" class="headerlink" title="OP = 2"></a>OP = 2</h2><p>继续考虑一棵树的做法，设 $F(E)=n^{n-|E|-2}\prod \mathrm{siz}_i$ 即方案数</p>
<p>因为两个树都没有，所以只要枚举交集就可以生成出两个树 即 $\sum \limits_{E}y^{n-|E|}f(E)^2$ 同样是指数级的</p>
<p>当然也可以用 OP = 1 的做法把 $y$ 改写成 $y-1$ 来避免容斥，以下为了方便都写得 $y$</p>
<p>考虑枚举 $E$ 的大小，设 $g_i=\sum \limits_{|E|=i}f(E)^2$  答案即为 $\sum\limits_i y^{n-i}g_i$</p>
<p>这样只要可以在合理的时间里算出来 ${g_i}$  即可</p>
<p><del>因为siz太难打了</del> 枚举每个连通块大小 $a_i$</p>
<p>显然 $g_m$ 有 $n-m$ 个连通块</p>
<p>先得让每个连通块连通，即连通块内部形成树 $\prod\limits_{i=1}^{n-m} a_i^{a_i-2}$</p>
<p>然后将每个点划分进连通块，一个多重集排列 $\prod\limits_{i=1}^{n-m} \dfrac{n!}{a_i!}$</p>
<p>然后我们枚举时赋予了顺序，但实际上连通块无序，所以除掉 $(n-m)!$ </p>
<p>然后乘上 $f(E)^2$</p>
<p>以下的 $y$ 均为 $y^{-1}$ 因为 $y \to y-1$ 的方法是在 $y^{-1}$ 下才有正确贡献</p>
<p>$g_{m} = \sum\limits_{\sum a_i =n} \dfrac{n!}{(n-m)!}\prod\limits_{i=1}^{n-m} \dfrac{a_i^{a_i-2}}{a_i!}(n^{n-m-2}\prod \limits_{i=1}^{n-m}a_i)^2$</p>
<p>$\sum\limits_{m} y^{m} \sum\limits_{\sum a_i =n} \dfrac{n!}{(n-m)!}\prod\limits_{i=1}^{n-m} \dfrac{a_i^{a_i-2}}{a_i!}(n^{n-m-2}\prod \limits_{i=1}^{n-m}a_i)^2$</p>
<p>$n!\sum\limits_{m}y^{m}\dfrac{n^{2n-2m-4}}{(n-m)!}\sum\limits_{\sum a_i = n}\prod\limits_{i=1}^{n-m}\frac{a_i^{a_i}}{a_i!}$ (合并了 $\prod a_i^2 $ 和 $\prod a_i^{a_i-2}$)</p>
<p>下标代换 $m \gets n-m$</p>
<p>$n!n^{-4}y^n\sum \limits_{m=1}^{n}y^{-m} \dfrac{n^{2m}}{m!}\sum\limits_{\sum a_i = n}\prod \limits_{i=1}^{m}\dfrac{a_i^{a_i}}{a_i!}$</p>
<p>后面和 $OP=1$ 类似还是个卷积的 $[x^n]$ </p>
<p>那么</p>
<p>$n!y^nn^{-4}\sum y^{-m}\dfrac{n^{2m}}{m!}[x^n]\left(\sum \dfrac{j^j}{j!}x^j \right)^m$</p>
<p>把前面的整合进去</p>
<p>$n!y^nn^{-4}[x^n]\sum \dfrac{\left( {n^2y^{-1} \sum \dfrac{j^j}{j!}x^j}\right)^m}{m!}$</p>
<p>后面的求和就是</p>
<p>$\exp {n^2y^{-1}\sum \frac{i^i}{i!}x^i }$</p>
<p>多项式 Exp 即可</p>
<p>最后还有一开始就提出去的 $y^n$</p>
<p><del>离谱</del></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>容斥</tag>
        <tag>多项式</tag>
        <tag>prufer序列</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.08.02模拟赛</title>
    <url>/2021/08/04/2021-08-02%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>一点浩然气，千里快哉风</p>
<span id="more"></span>

<h2 id="2021-08-02模拟赛"><a href="#2021-08-02模拟赛" class="headerlink" title="2021.08.02模拟赛"></a>2021.08.02模拟赛</h2><h3 id="T1-吊灯"><a href="#T1-吊灯" class="headerlink" title="T1 吊灯"></a>T1 吊灯</h3><p>奇异结论题</p>
<p>先分解因数，显然 有 $\dfrac{n}{d}$ 个大小为 $d$ 的倍数的子树是必要条件，充分性可以考虑每次分出来一个大小为 $d$ 的连通块的时候都不影响其他的大小为 $d$ 的倍数的子树，就可以一直分下去直到分完</p>
<p>所以就可以开个桶记录下，不用建树，直接统计大小否则会被卡</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1200005</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; factor;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">int</span> fa[N], siz[N], tmp[N], buc[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        fa[i] = (fa[i] + <span class="number">19940105</span>) % (i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i--) &#123;</span><br><span class="line">        siz[i]++;</span><br><span class="line">        siz[fa[i]] += siz[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        buc[siz[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * x &lt;= n; i++) &#123;</span><br><span class="line">        cnt += buc[i * x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (cnt * x == n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ans.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">memset</span>(siz, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(siz));</span><br><span class="line">    <span class="built_in">memset</span>(buc, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buc));</span><br><span class="line">    <span class="built_in">pre</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : factor) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(x) == <span class="number">1</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>, k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : ans) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            factor.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i * i != n) &#123;</span><br><span class="line">                factor.<span class="built_in">push_back</span>(n / i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(factor.<span class="built_in">begin</span>(), factor.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">unique</span>(factor.<span class="built_in">begin</span>(), factor.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d,&quot;</span>, &amp;fa[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;fa[n]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="built_in">output</span>(i);</span><br><span class="line">        <span class="built_in">change</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T2-小Z爱求和"><a href="#T2-小Z爱求和" class="headerlink" title="T2 小Z爱求和"></a>T2 小Z爱求和</h3><p>考虑一个数是第 $k$​ 小的就是有 $k-1$​ 个小于等于它的，所以从大向小考虑，维护一个链表，记 $pos_i$ 为 $i$ 下标的排名，这样就能按大小顺序访问</p>
<p>每次前后找到 $k-1$  个位置，然后算出答案后删掉个数字，复杂度 $O(n\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll     = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N  = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IO</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">20</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ibuf[N], *p, *q, c;</span><br><span class="line">    <span class="keyword">char</span> obuf[N], *o;</span><br><span class="line">    <span class="keyword">bool</span> s;</span><br><span class="line">    <span class="keyword">int</span> stk[<span class="number">50</span>], t;</span><br><span class="line">    <span class="built_in">IO</span>() &#123;</span><br><span class="line">        p = q = ibuf, o = obuf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == q)</span><br><span class="line">            p = ibuf, q = ibuf + <span class="built_in">fread</span>(ibuf, <span class="number">1</span>, <span class="keyword">sizeof</span> ibuf, stdin);</span><br><span class="line">        <span class="keyword">return</span> p == q ? EOF : *p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; IO &amp;<span class="keyword">operator</span>&gt;&gt;(T &amp;x) &#123;</span><br><span class="line">        x = <span class="number">0</span>, s = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            c = <span class="built_in">gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c));</span><br><span class="line">        s |= c == <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">gc</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c));</span><br><span class="line">        <span class="keyword">if</span> (s)</span><br><span class="line">            x = -x;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">fwrite</span>(obuf, <span class="number">1</span>, o - obuf, stdout);</span><br><span class="line">        o = obuf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wc</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        *o++ = x;</span><br><span class="line">        <span class="keyword">if</span> (o - obuf &gt;= N)</span><br><span class="line">            <span class="built_in">flush</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    IO &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="keyword">char</span> x) &#123;</span><br><span class="line">        <span class="built_in">wc</span>(x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; IO &amp;<span class="keyword">operator</span>&lt;&lt;(T x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">wc</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            stk[++t] = x % <span class="number">10</span>, x /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (x);</span><br><span class="line">        <span class="keyword">while</span> (t)</span><br><span class="line">            <span class="built_in">wc</span>(stk[t--] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">IO</span>() &#123;</span><br><span class="line">        <span class="built_in">flush</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; io;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> a[N], pos[N];</span><br><span class="line"><span class="keyword">int</span> pre[N], nxt[N];</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        pre[i] = i - <span class="number">1</span>;</span><br><span class="line">        nxt[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = pos[i];</span><br><span class="line">        <span class="keyword">int</span> l = x, r = x;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[l] != <span class="number">0</span>) &#123;</span><br><span class="line">                l = pre[l];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nxt[r] != n + <span class="number">1</span>) &#123;</span><br><span class="line">                r = nxt[r];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == k) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= x) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r == n + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                res +=</span><br><span class="line">                    a[x] * <span class="number">1ll</span> * (nxt[r] - r) % mod * <span class="number">1ll</span> * (l - pre[l]) % mod;</span><br><span class="line">                res %= mod;</span><br><span class="line">                l = nxt[l];</span><br><span class="line">                r = nxt[r];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nxt[pre[x]] = nxt[x];</span><br><span class="line">        pre[nxt[x]] = pre[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    io &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        io &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        pos[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(pos + <span class="number">1</span>, pos + <span class="number">1</span> + n, [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> &amp;A, <span class="keyword">const</span> <span class="keyword">int</span> &amp;B) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a[A] &lt; a[B];</span><br><span class="line">    &#125;);</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    sum += <span class="built_in">solve</span>();</span><br><span class="line">    sum %= mod;</span><br><span class="line">    <span class="built_in">reverse</span>(pos + <span class="number">1</span>, pos + <span class="number">1</span> + n);</span><br><span class="line">    sum += <span class="built_in">solve</span>();</span><br><span class="line">    sum %= mod;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours.</span></span><br></pre></td></tr></table></figure>

<h3 id="T3-关押罪犯"><a href="#T3-关押罪犯" class="headerlink" title="T3 关押罪犯"></a>T3 关押罪犯</h3><p>状压DP</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span> G[N][N];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span> &lt;&lt; N];</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        G[x][y] = G[y][x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">1</span>; S &lt; (<span class="number">1</span> &lt;&lt; n); S++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (G[i][j] &amp;&amp; (S &amp; (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))) &amp;&amp; (S &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)))) &#123;</span><br><span class="line">                    tot++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tot &lt;= k) &#123;</span><br><span class="line">            dp[S] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> T = S; T; T = (T - <span class="number">1</span>) &amp; S) &#123;</span><br><span class="line">                dp[S] = <span class="built_in">min</span>(dp[S], dp[T] + dp[S - T]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours.</span></span><br></pre></td></tr></table></figure>

<h3 id="T4-小P走迷宫"><a href="#T4-小P走迷宫" class="headerlink" title="T4 小P走迷宫"></a>T4 小P走迷宫</h3><p>容斥一下即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> ll     = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N  = <span class="number">2005</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, dp[N][N];</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="keyword">int</span> mp[N][N];</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="keyword">int</span> stx, <span class="keyword">int</span> sty, <span class="keyword">int</span> edx, <span class="keyword">int</span> edy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mp[stx][sty] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[stx][sty] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = stx; i &lt;= edx; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = sty; j &lt;= edy; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i != stx || j != sty) &amp;&amp; !mp[i][j]) &#123;</span><br><span class="line">                dp[i][j] = (dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[edx][edy];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c;</span><br><span class="line">            cin &gt;&gt; c;</span><br><span class="line">            mp[i][j] = (c == <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = ((<span class="built_in">calc</span>(<span class="number">1</span>, <span class="number">2</span>, n - <span class="number">1</span>, m) * <span class="built_in">calc</span>(<span class="number">2</span>, <span class="number">1</span>, n, m - <span class="number">1</span>) % mod) -</span><br><span class="line">              (<span class="built_in">calc</span>(<span class="number">1</span>, <span class="number">2</span>, n, m - <span class="number">1</span>) * <span class="built_in">calc</span>(<span class="number">2</span>, <span class="number">1</span>, n - <span class="number">1</span>, m) % mod) + mod) %</span><br><span class="line">             mod;</span><br><span class="line">    cout &lt;&lt; (ans + mod) % mod &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/11/IrGlw7s2Zv4mL6y.jpg" alt="-klbw3Qcqa9-awdpZcT3cSml-vx.jpg.medium.jpg"></p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>思维</tag>
        <tag>链表</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.07.13模拟赛</title>
    <url>/2021/07/14/2021-07-13%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>我最菜了/kk</p>
<span id="more"></span>

<h3 id="T1-矩阵"><a href="#T1-矩阵" class="headerlink" title="T1 矩阵"></a>T1 矩阵</h3><p>试图对每一个价值计数大失败</p>
<p>直接考虑每一个数字的能贡献答案的概率，因为每个数字都最多只会贡献 $1$ 的价值，直接对概率求和即答案</p>
<p>设 $p_i$ 为 $i+1$ 的概率，则 $p_i=p_{i-1}\times\dfrac{n^2-n-(i-1)}{n^2-i}$</p>
<p>因为前 $i-1$ 个需要不在同一列且 $i$ 不在这一列，递推即可</p>
<p>$O(n)$</p>
<h3 id="T2-欧拉"><a href="#T2-欧拉" class="headerlink" title="T2 欧拉"></a>T2 欧拉</h3><p>第二部分就是上帝与集合的正确用法，主要是对 $\varphi(i \times a)$求和</p>
<p>两种做法，一种是题解里比较优秀的做法，另一种是 RenaMoe 给出的不依赖于无平方因子的做法</p>
<p>第一种：</p>
<p>如果 $p|a$ 则必然有 $\gcd(p,\dfrac{a}{p})=1$ 由这个性质可以考虑分开计算</p>
<p>$\sum \varphi (i \times a) = \sum\limits_{p \nmid i} \varphi(i\times\frac{a}{p})\varphi(p)+\sum\limits_{i=1}^{\lfloor\frac{n}{p}\rfloor}\varphi(i\times a) \times p$ </p>
<p>$=\sum\limits_{p \nmid i} \varphi(i\times\frac{a}{p})\varphi(p)+\sum\limits_{i=1}^{\lfloor\frac{n}{p}\rfloor}\varphi(i\times a) \times (\varphi(p)+1)$</p>
<p>$\sum\limits_{p \nmid i} \varphi(i\times\frac{a}{p})\varphi(p)+\sum\limits_{i=1}^{\lfloor\frac{n}{p}\rfloor}\varphi(i\times a) \times \varphi(p)<br>+\sum\limits_{i=1}^{\lfloor\frac{n}{p}\rfloor}\varphi(i\times a) $ </p>
<p>可以通过各种方式发现前两项是互补的，即 $\varphi(p)\sum\varphi(i\times \dfrac{a}{p})$</p>
<p>然后直接递归算即可</p>
<p>第二种：<br>考虑 $ \varphi(i \times a) $ 展开式 $ ia\prod \frac{p_i-1}{p_i} $ 我们希望把 $ \varphi(a) $ 提出去，观察 $\varphi(i \times a)$ 展开式可以发现，如果我们把属于 $a$ 的部分提出去，那么剩下的是 $i$ 除去和 $a$ 共有的素因子（不计重数）</p>
<p>考虑构造 $f(a,i)$ 表示 不计重数的 $i$ 与 $a$ 的非共有素因子，则答案为</p>
<p>$\varphi(a) \sum i  \dfrac{\varphi(f(a,i))}{f(a,i)}$ </p>
<p>直接计算即可，复杂度同样 $O(n)$</p>
<h3 id="T3-标算惨遭卡飞！随机数据惨遭暴力水过！"><a href="#T3-标算惨遭卡飞！随机数据惨遭暴力水过！" class="headerlink" title="T3 标算惨遭卡飞！随机数据惨遭暴力水过！"></a>T3 标算惨遭卡飞！随机数据惨遭暴力水过！</h3><p>显然是得跑网络流，不过直接连边必然跑不过</p>
<p>考虑在如果给树做括号序映射到序列上，那么 $l,r$ 和 子树的限制就是平面上的一个矩形</p>
<p>KDT优化建图即可，复杂度 $O(玄学^2)$</p>
<p>upd：复杂度似乎有点问题，原题BZOJ3681，待补</p>
<p>Code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> meow(args...) fprintf(stderr, args)</span></span><br><span class="line"><span class="keyword">int</span> S, T;</span><br><span class="line"><span class="keyword">namespace</span> NetworkFlow &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> v, w, nxt;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;Node&gt; edge;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; head;</span><br><span class="line">    <span class="built_in">Graph</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Graph</span>(<span class="keyword">int</span> n) : <span class="built_in">head</span>(n, <span class="number">-1</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        head.<span class="built_in">resize</span>(n);</span><br><span class="line">        head.<span class="built_in">assign</span>(n, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        edge.<span class="built_in">emplace_back</span>(Node&#123;v, w, head[u]&#125;);</span><br><span class="line">        head[u] = edge.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_flow</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// meow(&quot;u:%d v:%d flow:%d\n&quot;, u, v, w);</span></span><br><span class="line">        <span class="built_in">add</span>(u, v, w);</span><br><span class="line">        <span class="built_in">add</span>(v, u, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> level[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T, <span class="keyword">const</span> Graph &amp;G)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(level, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(level));</span><br><span class="line">    level[T] = <span class="number">1</span>;</span><br><span class="line">    std::queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(T);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[now]; ~i; i = G.edge[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G.edge[i].v;</span><br><span class="line">            <span class="keyword">if</span> (!level[v] &amp;&amp; G.edge[i ^ <span class="number">1</span>].w) &#123;</span><br><span class="line">                level[v] = level[now] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">                <span class="keyword">if</span> (v == S) &#123;</span><br><span class="line">                    <span class="keyword">return</span> level[S];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level[S];</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> T, <span class="keyword">int</span> maxflow, Graph &amp;G)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == T) &#123;</span><br><span class="line">        <span class="keyword">return</span> maxflow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; ~i &amp;&amp; res &lt; maxflow; i = G.edge[i].nxt) &#123;</span><br><span class="line">        cur[x] = i;</span><br><span class="line">        <span class="keyword">int</span> v  = G.edge[i].v;</span><br><span class="line">        <span class="keyword">if</span> (G.edge[i].w &amp;&amp; level[v] == level[x] - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">dfs</span>(v, T, std::<span class="built_in">min</span>(G.edge[i].w, maxflow - res), G);</span><br><span class="line">            <span class="keyword">if</span> (x) &#123;</span><br><span class="line">                G.edge[i].w -= x;</span><br><span class="line">                G.edge[i ^ <span class="number">1</span>].w += x;</span><br><span class="line">                res += x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; maxflow) &#123;</span><br><span class="line">        level[x] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFlow</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> S, <span class="keyword">const</span> <span class="keyword">int</span> T, <span class="keyword">const</span> Graph &amp;G)</span> </span>&#123;</span><br><span class="line">    cur.<span class="built_in">resize</span>(G.head.<span class="built_in">size</span>());</span><br><span class="line">    Graph tmpG = G;</span><br><span class="line">    <span class="keyword">int</span> res    = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>(S, T, tmpG)) &#123;</span><br><span class="line">        cur.<span class="built_in">assign</span>(tmpG.head.<span class="built_in">begin</span>(), tmpG.head.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">while</span> (x = <span class="built_in">dfs</span>(S, T, INF, tmpG)) &#123;</span><br><span class="line">            res += x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace NetworkFlow</span></span><br><span class="line">array&lt;<span class="keyword">int</span>, N&gt; id, pos;</span><br><span class="line">NetworkFlow::Graph G;</span><br><span class="line"><span class="keyword">namespace</span> KDT &#123;</span><br><span class="line"><span class="keyword">using</span> NetworkFlow::INF;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">int</span> &amp;x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">int</span> &amp;x) &#123;</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; p[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line">    Point l, r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Rectangle range;</span><br><span class="line">    Point p;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> ls, rs;</span><br><span class="line">&#125; tr[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        tr[x].range.l[i] = tr[x].range.r[i] = tr[x].p[i];</span><br><span class="line">        <span class="keyword">if</span> (tr[x].ls) &#123;</span><br><span class="line">            tr[x].range.l[i] = <span class="built_in">min</span>(tr[x].range.l[i], tr[tr[x].ls].range.l[i]);</span><br><span class="line">            tr[x].range.r[i] = <span class="built_in">max</span>(tr[x].range.r[i], tr[tr[x].ls].range.r[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tr[x].rs) &#123;</span><br><span class="line">            tr[x].range.l[i] = <span class="built_in">min</span>(tr[x].range.l[i], tr[tr[x].rs].range.l[i]);</span><br><span class="line">            tr[x].range.r[i] = <span class="built_in">max</span>(tr[x].range.r[i], tr[tr[x].rs].range.r[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">bool</span> d)</span> </span>&#123;</span><br><span class="line">    id[rt] = ++tot;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tr[rt].range.l[<span class="number">0</span>] = tr[rt].range.r[<span class="number">0</span>] = p[l].p[<span class="number">0</span>];</span><br><span class="line">        tr[rt].range.l[<span class="number">1</span>] = tr[rt].range.r[<span class="number">1</span>] = p[l].p[<span class="number">1</span>];</span><br><span class="line">        pos[l]                                = id[rt];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    std::<span class="built_in">nth_element</span>(p + l, p + mid, p + r,</span><br><span class="line">                     [&amp;](<span class="keyword">const</span> Point &amp;A, <span class="keyword">const</span> Point &amp;B) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">                         <span class="keyword">return</span> A[d] &lt; B[d];</span><br><span class="line">                     &#125;);</span><br><span class="line">    <span class="built_in">build</span>(rt &lt;&lt; <span class="number">1</span>, l, mid, d ^ <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, d ^ <span class="number">1</span>);</span><br><span class="line">    G.<span class="built_in">add_flow</span>(id[rt], id[rt &lt;&lt; <span class="number">1</span>], INF);</span><br><span class="line">    G.<span class="built_in">add_flow</span>(id[rt], id[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], INF);</span><br><span class="line">    tr[rt].ls = rt * <span class="number">2</span>;</span><br><span class="line">    tr[rt].rs = rt * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        tr[rt].range.l[i] =</span><br><span class="line">            <span class="built_in">min</span>(tr[tr[rt].ls].range.l[i], tr[tr[rt].rs].range.l[i]);</span><br><span class="line">        tr[rt].range.r[i] =</span><br><span class="line">            <span class="built_in">max</span>(tr[tr[rt].ls].range.r[i], tr[tr[rt].rs].range.r[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">In</span><span class="params">(<span class="keyword">const</span> Rectangle &amp;A, <span class="keyword">const</span> Rectangle &amp;B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (A.l[<span class="number">0</span>] &lt;= B.l[<span class="number">0</span>] &amp;&amp; A.l[<span class="number">1</span>] &lt;= B.l[<span class="number">1</span>] &amp;&amp; A.r[<span class="number">0</span>] &gt;= B.r[<span class="number">0</span>] &amp;&amp;</span><br><span class="line">            A.r[<span class="number">1</span>] &gt;= B.r[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">At</span><span class="params">(<span class="keyword">const</span> Rectangle &amp;A, <span class="keyword">const</span> Rectangle &amp;B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(A.l[<span class="number">0</span>] &gt; B.r[<span class="number">0</span>] || A.r[<span class="number">0</span>] &lt; B.l[<span class="number">0</span>] || A.l[<span class="number">1</span>] &gt; B.r[<span class="number">1</span>] ||</span><br><span class="line">             A.r[<span class="number">1</span>] &lt; B.l[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">const</span> Rectangle &amp;A, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">In</span>(A, tr[rt].range)) &#123;</span><br><span class="line">        G.<span class="built_in">add_flow</span>(pos, id[rt], INF);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">At</span>(A, tr[tr[rt].ls].range)) &#123;</span><br><span class="line">        <span class="built_in">link</span>(tr[rt].ls, A, pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">At</span>(A, tr[tr[rt].rs].range)) &#123;</span><br><span class="line">        <span class="built_in">link</span>(tr[rt].rs, A, pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace KDT</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; edge[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        edge[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Tr;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">array&lt;<span class="keyword">int</span>, N&gt; st, ed, p;</span><br><span class="line"><span class="keyword">int</span> tim;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">const</span> Graph &amp;G)</span> </span>&#123;</span><br><span class="line">    st[x]            = ++tim;</span><br><span class="line">    KDT::p[tim].p[<span class="number">1</span>] = p[x];</span><br><span class="line">    KDT::p[tim].p[<span class="number">0</span>] = tim;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G.edge[x]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(v, G);</span><br><span class="line">    &#125;</span><br><span class="line">    ed[x] = tim;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> root;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fa;</span><br><span class="line">        cin &gt;&gt; fa;</span><br><span class="line">        Tr.<span class="built_in">add</span>(fa, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, Tr);</span><br><span class="line">    G.<span class="built_in">resize</span>(<span class="built_in">max</span>(<span class="number">5</span> * n, <span class="number">10000</span>));</span><br><span class="line">    KDT::<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">    S = ++KDT::tot;</span><br><span class="line">    T = ++KDT::tot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        G.<span class="built_in">add_flow</span>(pos[i], T, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, d, mx;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; d &gt;&gt; mx;</span><br><span class="line">        KDT::Rectangle nya;</span><br><span class="line">        nya.l[<span class="number">1</span>] = l;</span><br><span class="line">        nya.r[<span class="number">1</span>] = r;</span><br><span class="line">        nya.l[<span class="number">0</span>] = st[d];</span><br><span class="line">        nya.r[<span class="number">0</span>] = ed[d];</span><br><span class="line">        ++KDT::tot;</span><br><span class="line">        KDT::<span class="built_in">link</span>(<span class="number">1</span>, nya, KDT::tot);</span><br><span class="line">        G.<span class="built_in">add_flow</span>(S, KDT::tot, mx);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; NetworkFlow::<span class="built_in">MaxFlow</span>(S, T, G) &lt;&lt; endl;</span><br><span class="line">    cout.<span class="built_in">flush</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T4-区间GCD"><a href="#T4-区间GCD" class="headerlink" title="T4 区间GCD"></a>T4 区间GCD</h3><p>线段树随便搞就行，甚至能带修</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">80100</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = (ll)<span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> sum[N], len, q;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">namespace</span> SegmentTree &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) (x * 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) (x * 2 + 1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ll g, c, d, gc, cd, gcd;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">&#125; tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls = <span class="built_in">ls</span>(rt), rs = <span class="built_in">rs</span>(rt);</span><br><span class="line">    tr[rt].g   = tr[ls].g + tr[rs].g;</span><br><span class="line">    tr[rt].c   = tr[ls].c + tr[rs].c;</span><br><span class="line">    tr[rt].d   = tr[ls].d + tr[rs].d;</span><br><span class="line">    tr[rt].cd  = (tr[ls].cd + tr[rs].cd + tr[ls].c * tr[rs].d) % mod;</span><br><span class="line">    tr[rt].gc  = (tr[ls].gc + tr[rs].gc + tr[ls].g * tr[rs].c) % mod;</span><br><span class="line">    tr[rt].gcd = (tr[ls].gcd + tr[rs].gcd + tr[ls].gc * tr[rs].d +</span><br><span class="line">                  tr[ls].g * tr[rs].cd) %</span><br><span class="line">                 mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tr[rt].l = l, tr[rt].r = r;</span><br><span class="line">        tr[rt].g = tr[rt].d = tr[rt].c = tr[rt].gc = tr[rt].cd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[l] == <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">            tr[rt].g = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[l] == <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">            tr[rt].c = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[l] == <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">            tr[rt].d = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tr[rt].l = l, tr[rt].r = r;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(rt), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(rt), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = tr[rt].l, R = tr[rt].r, mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == L &amp;&amp; r == R) &#123;</span><br><span class="line">        <span class="keyword">return</span> tr[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(rt), l, r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(rt), l, r);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node ls = <span class="built_in">query</span>(<span class="built_in">ls</span>(rt), l, mid), rs = <span class="built_in">query</span>(<span class="built_in">rs</span>(rt), mid + <span class="number">1</span>, r), res;</span><br><span class="line">        res.g   = ls.g + rs.g;</span><br><span class="line">        res.c   = ls.c + rs.c;</span><br><span class="line">        res.d   = ls.d + rs.d;</span><br><span class="line">        res.cd  = (ls.cd + rs.cd + ls.c * rs.d) % mod;</span><br><span class="line">        res.gc  = (ls.gc + rs.gc + ls.g * rs.c) % mod;</span><br><span class="line">        res.gcd = (ls.gcd + rs.gcd + ls.gc * rs.d + ls.g * rs.cd) % mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace SegmentTree</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> SegmentTree;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">    len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, len);</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, l, r).gcd % mod &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>数论</tag>
        <tag>KDT</tag>
        <tag>网络流</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.07.08模拟赛</title>
    <url>/2021/07/10/2021-07-08%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>T4不知道为啥乱入</p>
<span id="more"></span>

<h2 id="2021-07-08-模拟赛"><a href="#2021-07-08-模拟赛" class="headerlink" title="2021.07.08 模拟赛"></a>2021.07.08 模拟赛</h2><h3 id="T1-超级计算机-amp-T3-土地购买问题"><a href="#T1-超级计算机-amp-T3-土地购买问题" class="headerlink" title="T1 超级计算机 &amp; T3 土地购买问题"></a>T1 超级计算机 &amp; T3 土地购买问题</h3><p><a href="https://www.luogu.com.cn/problem/P5785">T1原题</a><br><a href="https://www.luogu.com.cn/problem/P2900">T3原题</a></p>
<p>都是经典老题了</p>
<h3 id="T2-赛马问题"><a href="#T2-赛马问题" class="headerlink" title="T2 赛马问题"></a>T2 赛马问题</h3><p>其实也是<a href="https://www.luogu.com.cn/problem/P4859">原题</a></p>
<p>但是我没做过</p>
<p>考虑 $dp_{i,j}$ 表示前 $i$ 个数字 $j$ 个 $a &gt; b $ 的</p>
<p>转移的时候就是 $dp_{i,j}=dp_{i-1,j}+dp_{i-1,j-1}\times(l_i-j+1)$</p>
<p>$l_i$ 是 $b$ 中小于 $a_i$ 的数量</p>
<p>设 $g_i=dp_{n,i}(n-i)!$</p>
<p>即至少有 $i$ 个满足条件的，$(n-i)!$ 即随便排</p>
<p>然后至少恰好反演即可</p>
<h3 id="T4-时代的眼泪·SP"><a href="#T4-时代的眼泪·SP" class="headerlink" title="T4 时代的眼泪·SP"></a>T4 时代的眼泪·SP</h3><p>伟大的分块</p>
<p>$2\times10^5 $ 8s 和题目名都在提醒我们分块</p>
<p>但是区间向上跳这个操作很离谱，感觉不太好维护</p>
<p>主要考虑整块修改，散点暴力重构即可</p>
<p>考虑如果一个点要跳过去的点已经被访问过了，那访问过的点一定永远比他高，也永远比他优</p>
<p>那么这个点就没用了，我们需要维护所有的有用的点，一开始用的带删除队列被卡爆了</p>
<p>用 dfs 序来判断虽然多个 $\log$ 但是能跑过</p>
<p>$O(n\log n)-O(1)$ 的长链剖分求 $k$ 级祖先效果不太好，直接倍增也可以</p>
<p>另外这题的数据巨水，基本上块越小跑的越快</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> ll    = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, rt;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x   = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        x  = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace IO</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="keyword">namespace</span> Tree &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LOG_LIM = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">int</span> lg[N], p2[<span class="number">55</span>];</span><br><span class="line">ll dis[N];</span><br><span class="line"><span class="keyword">int</span> fa[N][LOG_LIM + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> maxdep[N], son[N], top[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; up[N], down[N];</span><br><span class="line"><span class="keyword">int</span> dfn[N], dfn_cnt;</span><br><span class="line"><span class="keyword">int</span> siz[N], dep[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        ll w;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector&lt;Node&gt; edge[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        edge[u].<span class="built_in">emplace_back</span>(Node&#123;v, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Tr, preTr;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lg[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">25</span>; i++) &#123;</span><br><span class="line">        p2[i] = p2[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_dfn</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dfn[x] = ++dfn_cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : preTr.edge[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.v == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs_dfn</span>(e.v, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= LOG_LIM; i++) &#123;</span><br><span class="line">        fa[x][i] = fa[fa[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : Tr.edge[x]) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;v = e.v;</span><br><span class="line">        <span class="keyword">if</span> (v == fa[x][<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fa[v][<span class="number">0</span>] = x;</span><br><span class="line">        dis[v]   = dis[x] + e.w;</span><br><span class="line">        dep[v]   = dep[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v);</span><br><span class="line">        siz[x] += siz[v];</span><br><span class="line">        maxdep[x] = <span class="built_in">max</span>(maxdep[x], maxdep[v] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!son[x] || maxdep[v] &gt; maxdep[son[x]]) &#123;</span><br><span class="line">            son[x] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">    top[x] = topf;</span><br><span class="line">    <span class="keyword">if</span> (!son[x])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : Tr.edge[x]) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;v = e.v;</span><br><span class="line">        <span class="keyword">if</span> (v != son[x] &amp;&amp; v != fa[x][<span class="number">0</span>])</span><br><span class="line">            <span class="built_in">dfs2</span>(e.v, e.v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (top[x] == x) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = x;</span><br><span class="line">        <span class="keyword">while</span> (now) &#123;</span><br><span class="line">            down[x].<span class="built_in">push_back</span>(now);</span><br><span class="line">            now = son[now];</span><br><span class="line">        &#125;</span><br><span class="line">        now = x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxdep[x]; i++) &#123;</span><br><span class="line">            up[x].<span class="built_in">push_back</span>(now);</span><br><span class="line">            now = fa[now][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    x = fa[x][lg[k]];</span><br><span class="line">    <span class="keyword">if</span> (!x)</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    k -= p2[lg[k]];</span><br><span class="line">    k -= maxdep[top[x]] - maxdep[x];</span><br><span class="line">    x = top[x];</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; up[x].<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> up[x][k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> down[x][-k];</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace Tree</span></span><br><span class="line"><span class="keyword">namespace</span> SqrtDS &#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Tree;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">4005</span>;</span><br><span class="line"><span class="keyword">int</span> belong[N], lb[N], rb[N];</span><br><span class="line"><span class="keyword">int</span> BLOCK_SIZE, cnt;</span><br><span class="line">ll mmin[B];</span><br><span class="line">ll tag[B];</span><br><span class="line"><span class="keyword">int</span> lim[N], s[N], t[N], b[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lb[id]; i &lt;= rb[id]; i++) &#123;</span><br><span class="line">        a[i] = <span class="built_in">LA</span>(a[i], tag[id]);</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    mmin[id] = (<span class="number">1ll</span> &lt;&lt; <span class="number">60</span>);</span><br><span class="line">    tag[id]  = <span class="number">0</span>;</span><br><span class="line">    s[id]    = lb[id];</span><br><span class="line">    t[id]    = rb[id];</span><br><span class="line">    <span class="built_in">sort</span>(b + s[id], b + t[id] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> uplim = t[id];</span><br><span class="line">    t[id]     = s[id];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s[id] + <span class="number">1</span>; i &lt;= uplim; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt; lim[b[t[id]]]) &#123;</span><br><span class="line">            b[++t[id]] = b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s[id]; i &lt;= t[id]; i++) &#123;</span><br><span class="line">        mmin[id] = <span class="built_in">min</span>(mmin[id], dis[b[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    mmin[id] = (<span class="number">1ll</span> &lt;&lt; <span class="number">60</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s[id]; i &lt;= t[id]; i++)</span><br><span class="line">        b[i] = fa[b[i]][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">sort</span>(b + s[id], b + t[id] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> uplim = t[id];</span><br><span class="line">    t[id]     = s[id];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s[id] + <span class="number">1</span>; i &lt;= uplim; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt; lim[b[t[id]]]) &#123;</span><br><span class="line">            b[++t[id]] = b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s[id]; i &lt;= t[id]; i++) &#123;</span><br><span class="line">        mmin[id] = <span class="built_in">min</span>(mmin[id], dis[b[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BLOCK_SIZE = <span class="number">52</span>;</span><br><span class="line">    <span class="keyword">int</span> tot    = n / BLOCK_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (n % BLOCK_SIZE)</span><br><span class="line">        tot++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)</span><br><span class="line">        lb[i] = rb[i - <span class="number">1</span>] + <span class="number">1</span>, rb[i] = rb[i - <span class="number">1</span>] + BLOCK_SIZE;</span><br><span class="line">    rb[tot] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = lb[i]; j &lt;= rb[i]; j++)</span><br><span class="line">            belong[j] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)</span><br><span class="line">        <span class="built_in">build</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = belong[l], R = belong[r];</span><br><span class="line">    ll res = (<span class="number">1ll</span> &lt;&lt; <span class="number">60</span>);</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res, dis[<span class="built_in">LA</span>(a[i], tag[L])]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= rb[L]; i++) &#123;</span><br><span class="line">        res = <span class="built_in">min</span>(res, dis[<span class="built_in">LA</span>(a[i], tag[L])]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lb[R]; i &lt;= r; i++) &#123;</span><br><span class="line">        res = <span class="built_in">min</span>(res, dis[<span class="built_in">LA</span>(a[i], tag[R])]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L + <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line">        res = <span class="built_in">min</span>(res, mmin[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = belong[l], R = belong[r];</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            a[i] = fa[a[i]][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>(L);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= rb[L]; i++) &#123;</span><br><span class="line">        a[i] = fa[a[i]][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lb[R]; i &lt;= r; i++) &#123;</span><br><span class="line">        a[i] = fa[a[i]][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(L);</span><br><span class="line">    <span class="built_in">build</span>(R);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L + <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line">        tag[i]++;</span><br><span class="line">        <span class="built_in">update</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace SqrtDS</span></span><br><span class="line"><span class="keyword">using</span> Tree::dfn;</span><br><span class="line"><span class="keyword">using</span> Tree::preTr;</span><br><span class="line"><span class="keyword">using</span> Tree::Tr;</span><br><span class="line"><span class="keyword">int</span> u[N], v[N], w[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;rt);</span></span><br><span class="line">    n  = <span class="built_in">read</span>();</span><br><span class="line">    m  = <span class="built_in">read</span>();</span><br><span class="line">    rt = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// scanf(&quot;%d%d%d&quot;, &amp;u[i], &amp;v[i], &amp;w[i]);</span></span><br><span class="line">        u[i] = <span class="built_in">read</span>();</span><br><span class="line">        v[i] = <span class="built_in">read</span>();</span><br><span class="line">        w[i] = <span class="built_in">read</span>();</span><br><span class="line">        preTr.<span class="built_in">add</span>(u[i], v[i], w[i]);</span><br><span class="line">        preTr.<span class="built_in">add</span>(v[i], u[i], w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Tree::<span class="built_in">init</span>();</span><br><span class="line">    Tree::<span class="built_in">dfs_dfn</span>(rt, <span class="number">0</span>);</span><br><span class="line">    rt = dfn[rt];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Tr.<span class="built_in">add</span>(dfn[u[i]], dfn[v[i]], w[i]);</span><br><span class="line">        Tr.<span class="built_in">add</span>(dfn[v[i]], dfn[u[i]], w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Tree::<span class="built_in">dfs1</span>(rt);</span><br><span class="line">    Tree::<span class="built_in">dfs2</span>(rt, rt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// scanf(&quot;%d&quot;, &amp;a[i]);</span></span><br><span class="line">        a[i]           = <span class="built_in">read</span>();</span><br><span class="line">        a[i]           = dfn[a[i]];</span><br><span class="line">        SqrtDS::lim[i] = i + Tree::siz[i] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SqrtDS::<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt, l, r;</span><br><span class="line">        <span class="comment">// scanf(&quot;%d%d%d&quot;, &amp;opt, &amp;l, &amp;r);</span></span><br><span class="line">        opt = <span class="built_in">read</span>();</span><br><span class="line">        l   = <span class="built_in">read</span>();</span><br><span class="line">        r   = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            SqrtDS::<span class="built_in">modify</span>(l, r);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, SqrtDS::<span class="built_in">query</span>(l, r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>计数</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.07.07模拟赛</title>
    <url>/2021/07/10/2021-07-07%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>难度倒序（</p>
<span id="more"></span>

<h2 id="2021-07-07-模拟赛"><a href="#2021-07-07-模拟赛" class="headerlink" title="2021.07.07 模拟赛"></a>2021.07.07 模拟赛</h2><h3 id="T1-Bracketの模拟器日常-生于黑夜"><a href="#T1-Bracketの模拟器日常-生于黑夜" class="headerlink" title="T1 [Bracketの模拟器日常]生于黑夜"></a>T1 [Bracketの模拟器日常]生于黑夜</h3><p>原学军网络赛C题病毒研究</p>
<p>比较怪的题目</p>
<p>先做一一遍背包来得到每个减少的代价</p>
<p>设 $dp_{l,r}$ 表示 $ [l,r] $ 的期望代价</p>
<p>暴力转移不可取，考虑只有把这个区间减到某个分界点上才会知道额外的信息（判断原区间的每个数的范围）</p>
<p>或者说把被分割的点当作关键节点，因为如果一个转移没经过关键点，一定是直接减到了 $1$ 状态，那和之间减到 $1$ 状态没有区别（因为做过背包），只有关键点才会带来影响</p>
<p>按这个思路记忆话搜索，因为分界点状态是 $O(n)$，只有 $O(n^2)$ 的复杂度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll     = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = (<span class="number">1ll</span> &lt;&lt; <span class="number">48</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N  = <span class="number">2005</span>;</span><br><span class="line">array&lt;<span class="keyword">int</span>, N&gt; belong, a;</span><br><span class="line">array&lt;ll, N&gt; v, sum;</span><br><span class="line">array&lt;array&lt;ll, N&gt;, N&gt; dp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[l][r] != INF)</span><br><span class="line">        <span class="keyword">return</span> dp[l][r];</span><br><span class="line">    <span class="keyword">if</span> (belong[l] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = INF + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i] == INF)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> L = l - i, R = r - i;</span><br><span class="line">        <span class="keyword">if</span> (belong[L] == belong[R]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (belong[R] == <span class="number">1</span>) &#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res, v[i] * (r - l + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll sum = <span class="built_in">solve</span>(L, a[belong[L]]);</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">for</span> (k = belong[L] + <span class="number">1</span>; a[k] &lt; R; k++) &#123;</span><br><span class="line">            sum += <span class="built_in">solve</span>(a[k - <span class="number">1</span>] + <span class="number">1</span>, a[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        sum += <span class="built_in">solve</span>(a[k - <span class="number">1</span>] + <span class="number">1</span>, R) + v[i] * (r - l + <span class="number">1</span>);</span><br><span class="line">        res = <span class="built_in">min</span>(sum, res);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[l][r] = <span class="built_in">min</span>(INF, res);</span><br><span class="line">    <span class="keyword">return</span> dp[l][r];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;Data&gt; <span class="title">q</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            cin &gt;&gt; q[i].v &gt;&gt; q[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        v.<span class="built_in">fill</span>(INF);</span><br><span class="line">        v[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = q[i].w; j &lt;= a[n]; j++) &#123;</span><br><span class="line">                v[j] = <span class="built_in">min</span>(v[j], v[j - q[i].w] + q[i].v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = a[i] + <span class="number">1</span>; j &lt;= a[i + <span class="number">1</span>]; ++j) &#123;</span><br><span class="line">                belong[j] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[n] + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i].<span class="built_in">fill</span>(INF);</span><br><span class="line">        &#125;</span><br><span class="line">        sum[<span class="number">0</span>]    = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + <span class="built_in">solve</span>(a[i] + <span class="number">1</span>, a[i + <span class="number">1</span>]);</span><br><span class="line">            flag &amp;= (sum[i] &lt; INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; sum[n - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T2-区间dp"><a href="#T2-区间dp" class="headerlink" title="T2 区间dp"></a>T2 区间dp</h3><p>$O(n^2)$ 的做法比较显然，设 $dp_{l,r}$ 是 $[l,r]$ 区间要多少个区间才能拼起来</p>
<p>转移的时候记录下当前访问的位置，如果新加入的值在一个区间的某一端那么不变，如果不在任何一侧那么 $+1$ 同时在两个区间的两端则 $-1$</p>
<p>考虑优化这个转移，钦定右端点不变，考虑加入的新右端点会带来什么影响</p>
<p>如果新的右端点在排列的位置的两侧有且仅有一个位置小于它，那么说明在这个值之后的左端点 $l$ 会 $+1$ ，因为只要左端点大于这个数字就会断开与 $r$ 的连接</p>
<p>如果均大于那么说明是个孤立点，全 $+1$ </p>
<p>如果均小于则是在较小的位置 $-1$ 较大的到 $r$ $+1$</p>
<p>线段树维护即可</p>
<p><strong>可以改成找 $k$ 个区间 分块维护</strong></p>
<p><del>虽然题目没说但是 $[x,x]$ 是不算答案的</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">namespace</span> SegmentTree &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) (x * 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) (x * 2 + 1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val, cnt;</span><br><span class="line">        Data <span class="keyword">operator</span>+(<span class="keyword">const</span> Data &amp;B) <span class="keyword">const</span> &#123;</span><br><span class="line">            Data res;</span><br><span class="line">            <span class="keyword">if</span> (val == B.val) &#123;</span><br><span class="line">                res.val = val;</span><br><span class="line">                res.cnt = cnt + B.cnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; B.val) &#123;</span><br><span class="line">                res.val = val;</span><br><span class="line">                res.cnt = cnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.val = B.val;</span><br><span class="line">                res.cnt = B.cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Data &amp;B) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> val &lt; B.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Data &amp;B) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> val &gt; B.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Data min, semin;</span><br><span class="line">    <span class="keyword">int</span> l, r, tag;</span><br><span class="line">&#125; tr[N * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    tr[x].min = tr[<span class="built_in">ls</span>(x)].min + tr[<span class="built_in">rs</span>(x)].min;</span><br><span class="line">    <span class="keyword">if</span> (tr[<span class="built_in">ls</span>(x)].min &lt; tr[<span class="built_in">rs</span>(x)].min) &#123;</span><br><span class="line">        tr[x].semin = tr[<span class="built_in">ls</span>(x)].semin + tr[<span class="built_in">rs</span>(x)].min;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tr[<span class="built_in">ls</span>(x)].min &gt; tr[<span class="built_in">rs</span>(x)].min) &#123;</span><br><span class="line">        tr[x].semin = tr[<span class="built_in">ls</span>(x)].min + tr[<span class="built_in">rs</span>(x)].semin;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tr[x].semin = tr[<span class="built_in">ls</span>(x)].semin + tr[<span class="built_in">rs</span>(x)].semin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[x].tag) &#123;</span><br><span class="line">        tr[<span class="built_in">ls</span>(x)].tag += tr[x].tag;</span><br><span class="line">        tr[<span class="built_in">ls</span>(x)].min.val += tr[x].tag;</span><br><span class="line">        tr[<span class="built_in">ls</span>(x)].semin.val += tr[x].tag;</span><br><span class="line">        tr[<span class="built_in">rs</span>(x)].tag += tr[x].tag;</span><br><span class="line">        tr[<span class="built_in">rs</span>(x)].min.val += tr[x].tag;</span><br><span class="line">        tr[<span class="built_in">rs</span>(x)].semin.val += tr[x].tag;</span><br><span class="line">        tr[x].tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    tr[rt].l = l;</span><br><span class="line">    tr[rt].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tr[rt].min   = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        tr[rt].semin = &#123;<span class="number">1</span> &lt;&lt; <span class="number">28</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(rt), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(rt), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;l = tr[rt].l;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = tr[rt].r;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= L &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">        tr[rt].min.val += v;</span><br><span class="line">        tr[rt].semin.val += v;</span><br><span class="line">        tr[rt].tag += v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid) &#123;</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">ls</span>(rt), L, R, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; R) &#123;</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">rs</span>(rt), L, R, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;l = tr[rt].l;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = tr[rt].r;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= L &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">return</span> (tr[rt].min.val &lt;= <span class="number">2</span> ? tr[rt].min.cnt : <span class="number">0</span>) +</span><br><span class="line">               (tr[rt].semin.val &lt;= <span class="number">2</span> ? tr[rt].semin.cnt : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid) &#123;</span><br><span class="line">        res += <span class="built_in">query</span>(<span class="built_in">ls</span>(rt), L, R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; R) &#123;</span><br><span class="line">        res += <span class="built_in">query</span>(<span class="built_in">rs</span>(rt), L, R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rs</span></span><br><span class="line">&#125; <span class="comment">// namespace SegmentTree</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N], p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        p[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    SegmentTree::<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt;= n; r++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0x3f3f3f3f</span>, y = <span class="number">0x3f3f3f3f</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = p[r];</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; <span class="number">1</span> &amp;&amp; a[pos - <span class="number">1</span>] &lt; r) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            x = a[pos - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; n &amp;&amp; a[pos + <span class="number">1</span>] &lt; r) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            y = a[pos + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">            SegmentTree::<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, r, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">1</span>) &#123;</span><br><span class="line">            SegmentTree::<span class="built_in">update</span>(<span class="number">1</span>, x + <span class="number">1</span>, r, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            SegmentTree::<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, x, <span class="number">-1</span>);</span><br><span class="line">            SegmentTree::<span class="built_in">update</span>(<span class="number">1</span>, y + <span class="number">1</span>, r, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += SegmentTree::<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans - n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T3-成绩单"><a href="#T3-成绩单" class="headerlink" title="T3 成绩单"></a>T3 成绩单</h3><p>原题 THUSC2016 同名</p>
<p>发现只有 $l,r$ 是没法做的，考虑再记一个 $x,y$ 表示当前还剩的最大是 $y$ ，最小的 $x$ </p>
<p>转移暴力转移 $dp_{l,r,\min(x,a_r),\max(y,a_r)} \gets dp_{l,r-1,x,y}$ </p>
<p>即加入一个数字</p>
<p>然后合并到 $g_{l,r}$ 的答案，同时转移 $dp_{l,r,<em>,</em>} \gets dp_{l,k,<em>,</em>}+g_{k+1,r}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll A, B;</span><br><span class="line">ll dp[N][N][N][N];</span><br><span class="line">ll nya[N][N];</span><br><span class="line">ll a[N];</span><br><span class="line">ll b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; A &gt;&gt; B;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		b[i] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">	<span class="built_in">memset</span>(nya, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(nya));</span><br><span class="line">	<span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n);</span><br><span class="line">	<span class="keyword">int</span> tot=<span class="built_in">unique</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n) - b - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		a[i] = <span class="built_in">lower_bound</span>(b + <span class="number">1</span>,b + <span class="number">1</span> + tot, a[i]) - b;</span><br><span class="line">		dp[i][i][a[i]][a[i]] = <span class="number">0</span>;</span><br><span class="line">		nya[i][i] = A;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; len++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l + len - <span class="number">1</span> &lt;= n ; l++) &#123;</span><br><span class="line">			<span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (ll x = <span class="number">1</span>; x &lt;= tot; x++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (ll y = x; y &lt;= tot; y++) &#123;</span><br><span class="line">					<span class="keyword">auto</span> &amp;val = dp[l][r][<span class="built_in">min</span>(x, a[r])][<span class="built_in">max</span>(y, a[r])];</span><br><span class="line">					val = <span class="built_in">min</span>(val, dp[l][r - <span class="number">1</span>][x][y]);</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> k = l; k &lt; r; k++)&#123;</span><br><span class="line">						dp[l][r][x][y] = <span class="built_in">min</span>(dp[l][r][x][y], dp[l][k][x][y] + nya[k + <span class="number">1</span>][r]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= tot; x++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> y = x; y &lt;= tot; y++) &#123;</span><br><span class="line">					nya[l][r] = <span class="built_in">min</span>(nya[l][r], dp[l][r][x][y] + A + B * (b[y] - b[x]) * (b[y] - b[x]));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; nya[<span class="number">1</span>][n] &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Asusetic eru quionours.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="T4-周期性字串计数"><a href="#T4-周期性字串计数" class="headerlink" title="T4 周期性字串计数"></a>T4 周期性字串计数</h3><p>考虑设 $f(n)$ 表示长度为 $n$ 的不周期字串</p>
<p>那么有 $f(n)=26^n-\sum\limits_{d|n}f(d)+f(n)$</p>
<p>因为所有的周期字串都是由某个非周期的字串的倍数来的，同时减去自己的 $1$ 倍串</p>
<p>可得 $26^n=\sum\limits_{d|n}f(d)$</p>
<p>二项式反演即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll n, factor[<span class="number">2333333</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll k)</span> </span>&#123;</span><br><span class="line">    ll base = a, ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k&amp;<span class="number">1</span>) &#123;</span><br><span class="line">			ans = ans * base % mod;</span><br><span class="line">		&#125;</span><br><span class="line">        base = <span class="number">1ll</span> * base * base % mod;</span><br><span class="line">		k /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">mu</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">2</span>; i * i &lt;= k; i++) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(k % i == <span class="number">0</span>)&#123;</span><br><span class="line">    		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    		<span class="keyword">while</span>(k % i == <span class="number">0</span>) &#123;</span><br><span class="line">    			cnt++;</span><br><span class="line">    			k /= i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(cnt &gt; <span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				ans = -ans;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(k &gt; <span class="number">1</span>)&#123;</span><br><span class="line">		ans = -ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fcnt;</span><br><span class="line">ll sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (n % i == <span class="number">0</span>)&#123;</span><br><span class="line">    		factor[++fcnt] = i;</span><br><span class="line">    		<span class="keyword">if</span>(<span class="number">1ll</span> * i * i != n)&#123;</span><br><span class="line">    			factor[++fcnt] = n/i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sum = <span class="built_in">qpow</span>(<span class="number">26ll</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= fcnt; i++)&#123;</span><br><span class="line">    	sum = (sum + (mod - <span class="built_in">qpow</span>(<span class="number">26ll</span>, factor[i]) * <span class="number">1ll</span> * <span class="built_in">mu</span>(n / factor[i]))) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Asusetic eru quionours.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>区间DP</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.07.02模拟赛</title>
    <url>/2021/07/02/2021-07-02%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>这里不知道写啥</p>
<span id="more"></span>

<h2 id="2021-07-02-模拟赛"><a href="#2021-07-02-模拟赛" class="headerlink" title="2021.07.02 模拟赛"></a>2021.07.02 模拟赛</h2><h3 id="T1-走夜路"><a href="#T1-走夜路" class="headerlink" title="T1 走夜路"></a>T1 走夜路</h3><p>首先肯定是在价格低的地方多充，价格高的少充</p>
<p>那么用ST表二分找到下一个小于它的电站，这一站充到能走过去就行</p>
<p>如果没有比他小的了就充满然后走，无解很好判 $O(n \log n)$</p>
<p>可以用单调栈去维护这个下一个小于他的电站，就是 $O(n)$ 的了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll    = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500005</span>;</span><br><span class="line">ll d[N], p[N];</span><br><span class="line"><span class="keyword">namespace</span> ST &#123;</span><br><span class="line"><span class="keyword">int</span> lg2[N];</span><br><span class="line">ll st[N][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    lg2[<span class="number">1</span>] = <span class="number">0</span>, lg2[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        st[i][<span class="number">0</span>] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> lim = n - (<span class="number">1</span> &lt;&lt; i) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lim; ++j)</span><br><span class="line">            st[j][i] = <span class="built_in">min</span>(st[j][i - <span class="number">1</span>], st[j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)][i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lg2[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(st[l][i], st[r - (<span class="number">1</span> &lt;&lt; i) + <span class="number">1</span>][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace ST</span></span><br><span class="line"></span><br><span class="line">ll n, t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; d[i] &gt;&gt; p[i - <span class="number">1</span>];</span><br><span class="line">        d[i] += d[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ST::<span class="built_in">init</span>(n);</span><br><span class="line">    ll pos = <span class="number">0</span>, now = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (now &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll l = pos + <span class="number">1</span>, r = n, res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            ll mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (ST::<span class="built_in">query</span>(pos + <span class="number">1</span>, mid) &lt;= p[pos]) &#123;</span><br><span class="line">                r   = mid - <span class="number">1</span>;</span><br><span class="line">                res = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d[res] - d[pos] &gt; t) &#123;</span><br><span class="line">            ans += (t - now) * p[pos];</span><br><span class="line">            now = t - (d[pos + <span class="number">1</span>] - d[pos]);</span><br><span class="line">            pos++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ll tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (now &gt; d[res] - d[pos])</span><br><span class="line">                tmp = now - d[res] + d[pos];</span><br><span class="line">            ans += (d[res] - d[pos] - <span class="built_in">min</span>(now, d[res] - d[pos])) * p[pos];</span><br><span class="line">            now = tmp;</span><br><span class="line">            pos = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T2-t2"><a href="#T2-t2" class="headerlink" title="T2 t2"></a>T2 t2</h3><p>数位DP</p>
<p>注意前导 $0$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">ll l, r;</span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> dig[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> X, Y;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pre, <span class="keyword">int</span> lim, <span class="keyword">bool</span> zero)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;%d %d %d\n&quot;, x, pre, lim);</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!lim &amp;&amp; ~dp[x][pre]) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[x][pre];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> up = lim ? dig[x] : <span class="number">9</span>;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= up; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == X &amp;&amp; i == Y) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += <span class="built_in">dfs</span>(x - <span class="number">1</span>, (zero &amp; (i == <span class="number">0</span>)) ? <span class="number">11</span> : i, lim &amp;&amp; (i == up),</span><br><span class="line">                   zero &amp; (i == <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!lim) &#123;</span><br><span class="line">        dp[x][pre] = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        dig[len++] = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(len - <span class="number">1</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r &gt;&gt; X &gt;&gt; Y;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">solve</span>(r) - <span class="built_in">solve</span>(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T3-奇怪的集训队"><a href="#T3-奇怪的集训队" class="headerlink" title="T3 奇怪的集训队"></a>T3 奇怪的集训队</h3><p>先钦定 $k$ 种元素，有 $\binom{n}{k}$ 种选择</p>
<p>要求剩下的 $n-k$ 元素的集合个交集为空</p>
<p>考虑 恰好 和 至少 的二项式反演</p>
<p>就能得到答案为 $\sum(-1)^i\binom{n-k}{i}(2^{2^{n-k-i}}-1)$</p>
<h3 id="T4-最短路"><a href="#T4-最短路" class="headerlink" title="T4 最短路"></a>T4 最短路</h3><p>首先这两个点肯定在 $S,T$ 的同一条最短路上</p>
<p>然后考虑 $S,T$ 之间所有最短路构成的最短路图，是个DAG，然后拓扑+bitset跑每个点能到达的点即可</p>
<p>$O(n\log n+m+\frac{nm}{w})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll     = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N  = <span class="number">3e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = (<span class="number">1ll</span> &lt; <span class="number">48</span>);</span><br><span class="line">array&lt;<span class="keyword">bool</span>, N&gt; mark, vis;</span><br><span class="line">array&lt;<span class="keyword">int</span>, N&gt; in, siz;</span><br><span class="line">bitset&lt;N&gt; nya[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; pre[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> v, w;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;Node&gt; edge[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        edge[u].<span class="built_in">emplace_back</span>(Node&#123;v, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G, G0;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    ll dis;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;B) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; B.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">ShortestPath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> S, <span class="keyword">const</span> Graph &amp;G)</span> </span>&#123;</span><br><span class="line">    vector&lt;ll&gt; dis;</span><br><span class="line">    dis.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    dis.<span class="built_in">assign</span>(n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    priority_queue&lt;Node&gt; q;</span><br><span class="line">    dis[S] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(Node&#123;S, dis[S]&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.<span class="built_in">top</span>().v;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e : G.edge[now]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e.v;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] == <span class="number">-1</span> || dis[v] &gt; dis[now] + e.w) &#123;</span><br><span class="line">                dis[v] = dis[now] + e.w;</span><br><span class="line">                pre[v].<span class="built_in">clear</span>();</span><br><span class="line">                pre[v].<span class="built_in">push_back</span>(now);</span><br><span class="line">                q.<span class="built_in">push</span>(Node&#123;v, dis[v]&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dis[v] == dis[now] + e.w) &#123;</span><br><span class="line">                pre[v].<span class="built_in">push_back</span>(now);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        G.<span class="built_in">add</span>(u, v, w);</span><br><span class="line">        G.<span class="built_in">add</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ShortestPath</span>(<span class="number">1</span>, G);</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(n);</span><br><span class="line">    in.<span class="built_in">fill</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (~in[x]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        in[x]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : pre[x]) &#123;</span><br><span class="line">            G0.<span class="built_in">add</span>(v, x, <span class="number">1</span>);</span><br><span class="line">            ++in[x];</span><br><span class="line">            q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; topo;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        topo.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e : G0.edge[x]) &#123;</span><br><span class="line">            --in[e.v];</span><br><span class="line">            <span class="keyword">if</span> (!in[e.v]) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(e.v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(topo.<span class="built_in">begin</span>(), topo.<span class="built_in">end</span>());</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : topo) &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">        nya[x][x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e : G0.edge[x]) &#123;</span><br><span class="line">            nya[x] |= nya[e.v];</span><br><span class="line">        &#125;</span><br><span class="line">        ans += nya[x].<span class="built_in">count</span>() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>最短路</tag>
        <tag>数位DP</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1030G Linear Congruential Generator</title>
    <url>/2021/07/01/CF1030G-Linear-Congruential-Generator/</url>
    <content><![CDATA[<p>奇妙</p>
<span id="more"></span>

<p>因为每个点都是在$\bmod p_i$意义下进行的运算，所以直觉上最多$p_i$次后一定会出现循环，但是不一定是纯循环，可能会有一个留下的“柄”，如果记每一个“柄”的长度为$l_i$，循环长度为$c_i$，那最终答案是$max(l_i)+lcm(c_i)$</p>
<p>我们细致的考察一下这个循环关系</p>
<h5 id="I-a-i-0"><a href="#I-a-i-0" class="headerlink" title="I. $a_i=0$"></a>I. $a_i=0$</h5><p>最简单的情况，$c_i=1$，当$x_i=b_i$时候$l_i=0$，否则$l_i=1$</p>
<h5 id="II-a-i-1"><a href="#II-a-i-1" class="headerlink" title="II $a_i=1$"></a>II $a_i=1$</h5><p>此时$f_i^{(k)}=(x_i+(k-1)b_i)\bmod p_i$，$l_i=0$当$b_i=0$时$c_i=1$，否则$c_i=p_i$</p>
<h5 id="III-otherwise"><a href="#III-otherwise" class="headerlink" title="III otherwise"></a>III otherwise</h5><p>$a_i&gt;1$，因为$p_i$是质数，所以$a_i^{-1},(a_i-1)^{-1}$均存在，那么就一定能回来，所以$l_i=0$</p>
<p>既然$l_i=0$了，那么$x_i\equiv a_i^{c_i}x_i+b_i\sum_{j=0}^{k-1}a_i^j\equiv x_i\equiv a_i^{c_i}x_i+b_i(a_i^{c_i}-1)(a_i-1)^{-1} \bmod p_i$</p>
<p>即$(a_i^{c_i}-1)\left(x_i+b_i(a_i-1)^{-1}\right) \equiv 0 \bmod p_i$</p>
<p>也即$(a^{c_i}-1)\equiv0$或$\left(x_i+b_i(a_i-1)^{-1}\right) \equiv 0$</p>
<p>第二个式子与$c_i$无关，所以$c_i=1$，考虑到$c_i$需要求$lcm$所以这样一定不优</p>
<p>第一个式子中的$c_i$就是$a_i$关于$p_i$的阶，即$c_i=p_i-1$</p>
<h5 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h5><p>整理一下</p>
<p>$a_i=0 \Rightarrow l_i=1，c_i=1$</p>
<p>$a_i=1 \Rightarrow l_i=0，c_i=p_i$</p>
<p>$a_i&gt;1 \Rightarrow l_i=0，c_i=p_i-1$</p>
<p>现在我们需要决定一组$a_i$，最大化$max(l_i)+lcm(c_i)$</p>
<p>直觉上因为$l_i\le1$，所以最大化$lcm$是比较优的，所以我们可以先考虑最大化$lcm$，然后看看能不能选$1$(因为每去一个因子$lcm$至少除二，所以损失lcm换$l_i$是亏的)</p>
<p>最大化$lcm$是很容易的，降序考虑每个$p_i$，如果当前的$lcm$包含了$p_i$，就选择$a_i&gt;1$否则选择$a_i=1$</p>
<p>同时记录下$lcm$每个质因子的最高次幂被几个$c_i$达到了，检查选择的$c_i$，如果有一个$c_i$的全部质因子都被达到不止一次，那就选上一个$1$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N   = <span class="number">2000005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">ll p[N];</span><br><span class="line"><span class="keyword">int</span> max_p[N], cnt[N];</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">555555</span>], pcnt;</span><br><span class="line"><span class="keyword">bool</span> pvis[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getP</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pvis[i]) &#123;</span><br><span class="line">            prime[++pcnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prime[j] * i &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            pvis[prime[j] * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>, base = a;</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            res = (res * base) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        base = (base * base) % mod;</span><br><span class="line">        k /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; max_p[p]) &#123;</span><br><span class="line">        max_p[p] = k;</span><br><span class="line">        cnt[p]   = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == max_p[p]) &#123;</span><br><span class="line">        ++cnt[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pvis[x]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pcnt; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prime[i] * prime[i] &gt; x) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % prime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                x /= prime[i];</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (max_p[prime[i]] == k &amp;&amp; cnt[prime[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">1</span> &amp;&amp; max_p[x] == <span class="number">1</span> &amp;&amp; cnt[x] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (max_p[x] == <span class="number">1</span> &amp;&amp; cnt[x] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll lcm  = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> nya = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">getP</span>(p[n]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max_p[p[i]]) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = p[i] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prime[j] * prime[j] &gt; val)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (val % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    val /= prime[j];</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                k != <span class="number">0</span> ? <span class="built_in">update</span>(prime[j], k) : (<span class="keyword">void</span>)nya;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">update</span>(val, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">update</span>(p[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pcnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max_p[prime[i]]) &#123;</span><br><span class="line">            lcm = <span class="number">1ll</span> * lcm * <span class="built_in">qpow</span>(prime[i], max_p[prime[i]]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((vis[i] &amp;&amp; <span class="built_in">check</span>(p[i] - <span class="number">1</span>)) || (!vis[i] &amp;&amp; <span class="built_in">check</span>(p[i]))) &#123;</span><br><span class="line">            lcm = (lcm + <span class="number">1</span>) % mod;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; lcm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#数学<br>#数论</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>CF793F Julia the snail</title>
    <url>/2021/07/01/CF793F-Julia-the-snail/</url>
    <content><![CDATA[<p>优雅的非分块做法</p>
<span id="more"></span>

<p>询问先离线下来，按右端点排个序，然后考虑当右端点移动的时候答案怎么变化</p>
<p>记点 $x$ 点的答案为 $r_x$</p>
<p>当从 $r \rightarrow r+1$ 的时候，如果这个点有绳子 $[l,r+1]$ 那么考虑在 $l$ 左边的点如果它的答案在 $[l+1,r]$ 之间（事实上不可能超过 $r$）</p>
<p>那就将其更新为 $r+1$ ，那么我们要快速找到 $[1,l]$ 的点中大于 $l$ 的点并将其修改为 $r+1$</p>
<p>这个东西可以用势能线段树做，具体来说记录一个两元的标记 $tag(x,y)$ 表示大于等于 $y$ 的点修改为 $x$ 就可以做了，下放注意下要取最小的 $y$</p>
<p>其他操作和势能线段树一样，复杂度 $O(m\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N   = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">namespace</span> SegmentBeats &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) (x * 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) (x * 2 + 1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> max, sem;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tag;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">&#125;;</span><br><span class="line">array&lt;Node, N * 4&gt; tr;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">merge</span><span class="params">(<span class="keyword">const</span> Node &amp;A, <span class="keyword">const</span> Node &amp;B)</span> </span>&#123;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (B.max &gt; A.max) &#123;</span><br><span class="line">        res.first  = B.max;</span><br><span class="line">        res.second = <span class="built_in">max</span>(A.max, B.sem);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (B.max &lt; A.max) &#123;</span><br><span class="line">        res.first  = A.max;</span><br><span class="line">        res.second = <span class="built_in">max</span>(A.sem, B.max);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.first  = A.max;</span><br><span class="line">        res.second = <span class="built_in">max</span>(A.sem, B.sem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// apply B -&gt; A</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply_tag</span><span class="params">(Node &amp;A, <span class="keyword">const</span> Node &amp;B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.max &gt;= B.tag.second) &#123;</span><br><span class="line">        A.max = B.tag.first;</span><br><span class="line">        <span class="keyword">if</span> (!A.tag.second) &#123;</span><br><span class="line">            A.tag.second = B.tag.second;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A.tag.second = <span class="built_in">min</span>(A.tag.second, B.tag.second);</span><br><span class="line">        &#125;</span><br><span class="line">        A.tag.first = B.tag.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply_tag</span><span class="params">(Node &amp;A, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.max &gt;= B.second) &#123;</span><br><span class="line">        A.max = B.first;</span><br><span class="line">        <span class="keyword">if</span> (!A.tag.second) &#123;</span><br><span class="line">            A.tag.second = B.second;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A.tag.second = <span class="built_in">min</span>(A.tag.second, B.second);</span><br><span class="line">        &#125;</span><br><span class="line">        A.tag.first = B.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;&amp;res = <span class="built_in">merge</span>(tr[<span class="built_in">ls</span>(x)], tr[<span class="built_in">rs</span>(x)]);</span><br><span class="line">    tr[x].max  = res.first;</span><br><span class="line">    tr[x].sem  = res.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[x].tag.first) &#123;</span><br><span class="line">        <span class="built_in">apply_tag</span>(tr[<span class="built_in">ls</span>(x)], tr[x]);</span><br><span class="line">        <span class="built_in">apply_tag</span>(tr[<span class="built_in">rs</span>(x)], tr[x]);</span><br><span class="line">        tr[x].tag = <span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    tr[rt].l = l;</span><br><span class="line">    tr[rt].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tr[rt].max = l;</span><br><span class="line">        tr[rt].sem = -INF;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(rt), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(rt), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;l = tr[rt].l;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = tr[rt].r;</span><br><span class="line">    <span class="keyword">if</span> (tr[rt].max &lt; y) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= L &amp;&amp; r &lt;= R &amp;&amp; tr[rt].sem &lt; y) &#123;</span><br><span class="line">        <span class="built_in">apply_tag</span>(tr[rt], <span class="built_in">make_pair</span>(x, y));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid) &#123;</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">ls</span>(rt), L, R, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; R) &#123;</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">rs</span>(rt), L, R, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;l = tr[rt].l;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = tr[rt].r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> tr[rt].max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(rt), pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(rt), pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rs</span></span><br><span class="line">&#125; <span class="comment">// namespace SegmentBeats</span></span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line">array&lt;<span class="keyword">int</span>, N&gt; lb, ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, id;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Query&gt; qr[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        lb[r] = l;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        qr[r].<span class="built_in">emplace_back</span>(Query&#123;l, i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    SegmentBeats::<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lb[i]) &#123;</span><br><span class="line">            SegmentBeats::<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, lb[i], i, lb[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : qr[i]) &#123;</span><br><span class="line">            ans[p.id] = SegmentBeats::<span class="built_in">query</span>(<span class="number">1</span>, p.l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>势能线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>CF793G Oleg and chess</title>
    <url>/2021/07/01/CF793G-Oleg-and-chess/</url>
    <content><![CDATA[<p>比较套路的题</p>
<span id="more"></span>

<p>如果没有矩阵的限制就是每行每列互相连边跑最大匹配，禁止的点不能连边，但是 $n^2$ 的边数会 T</p>
<p>观察连边可以发现绝大部分边都是一个点连向某一个区间，那就考虑线段树优化建图</p>
<p>具体的可以用扫描线的思路，把矩阵左边界的 $(y_1,y_2)$ 置为不能选，右边界再去掉限制，新建点向这一列内连边即可</p>
<p>注意需要先加后删</p>
<p>边数为 $n\log n$ 级别，网络流跑不满所以能过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N   = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> v, w, nxt;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; head;</span><br><span class="line">    std::vector&lt;Node&gt; edge;</span><br><span class="line">    <span class="built_in">Graph</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Graph</span>(<span class="keyword">int</span> n) : <span class="built_in">head</span>(n + <span class="number">1</span>, <span class="number">-1</span>)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        head.<span class="built_in">assign</span>(n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.<span class="built_in">size</span>() &lt; u) &#123;</span><br><span class="line">            head.<span class="built_in">reserve</span>(u * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        edge.<span class="built_in">emplace_back</span>(Node&#123;v, w, head[u]&#125;);</span><br><span class="line">        head[u] = edge.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_flow</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">add</span>(u, v, w);</span><br><span class="line">        <span class="built_in">add</span>(v, u, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> NetworkFlow &#123;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T, <span class="keyword">const</span> Graph &amp;G)</span> </span>&#123;</span><br><span class="line">    level.<span class="built_in">assign</span>(G.head.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">    level[S] = <span class="number">1</span>;</span><br><span class="line">    std::queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(S);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[now]; ~i; i = G.edge[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G.edge[i].v;</span><br><span class="line">            <span class="keyword">if</span> (!level[v] &amp;&amp; G.edge[i].w) &#123;</span><br><span class="line">                level[v] = level[now] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level[T];</span><br><span class="line">&#125;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> T, <span class="keyword">int</span> maxflow, Graph &amp;G)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == T) &#123;</span><br><span class="line">        <span class="keyword">return</span> maxflow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; ~i &amp;&amp; res &lt; maxflow; i = G.edge[i].nxt) &#123;</span><br><span class="line">        cur[x] = i;</span><br><span class="line">        <span class="keyword">int</span> v  = G.edge[i].v;</span><br><span class="line">        <span class="keyword">if</span> (G.edge[i].w &amp;&amp; level[v] == level[x] + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">dfs</span>(v, T, std::<span class="built_in">min</span>(G.edge[i].w, maxflow - res), G);</span><br><span class="line">            <span class="keyword">if</span> (x) &#123;</span><br><span class="line">                G.edge[i].w -= x;</span><br><span class="line">                G.edge[i ^ <span class="number">1</span>].w += x;</span><br><span class="line">                res += x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; maxflow) &#123;</span><br><span class="line">        level[x] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFlow</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> S, <span class="keyword">const</span> <span class="keyword">int</span> T, <span class="keyword">const</span> Graph &amp;G)</span> </span>&#123;</span><br><span class="line">    cur.<span class="built_in">resize</span>(G.head.<span class="built_in">size</span>());</span><br><span class="line">    level.<span class="built_in">resize</span>(G.head.<span class="built_in">size</span>());</span><br><span class="line">    Graph tmpG = G;</span><br><span class="line">    <span class="keyword">int</span> res    = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>(S, T, tmpG)) &#123;</span><br><span class="line">        cur.<span class="built_in">assign</span>(tmpG.head.<span class="built_in">begin</span>(), tmpG.head.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">while</span> (x = <span class="built_in">dfs</span>(S, T, INF, tmpG)) &#123;</span><br><span class="line">            res += x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace NetworkFlow</span></span><br><span class="line"><span class="keyword">int</span> S, T;</span><br><span class="line">Graph G;</span><br><span class="line">array&lt;<span class="keyword">int</span>, N * 20&gt; id, col;</span><br><span class="line"><span class="keyword">int</span> idcnt;</span><br><span class="line"><span class="keyword">namespace</span> SegmentTree &#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> NetworkFlow;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) (x * 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) (x * 2 + 1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        id[rt] = l;</span><br><span class="line">        G.<span class="built_in">add_flow</span>(l, T, <span class="number">1</span>);</span><br><span class="line">        col[rt] = l;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    id[rt] = col[rt] = ++idcnt;</span><br><span class="line">    <span class="keyword">int</span> mid          = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(rt), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(rt), mid + <span class="number">1</span>, r);</span><br><span class="line">    G.<span class="built_in">add_flow</span>(col[rt], col[<span class="built_in">ls</span>(rt)], INF);</span><br><span class="line">    G.<span class="built_in">add_flow</span>(col[rt], col[<span class="built_in">rs</span>(rt)], INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v) &#123;</span><br><span class="line">            id[rt] = col[rt];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            id[rt] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    id[rt]  = ++idcnt;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid) &#123;</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">ls</span>(rt), l, mid, L, R, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; R) &#123;</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">rs</span>(rt), mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (id[<span class="built_in">ls</span>(rt)] != <span class="number">-1</span>) &#123;</span><br><span class="line">        G.<span class="built_in">add_flow</span>(id[rt], id[<span class="built_in">ls</span>(rt)], INF);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (id[<span class="built_in">rs</span>(rt)] != <span class="number">-1</span>) &#123;</span><br><span class="line">        G.<span class="built_in">add_flow</span>(id[rt], id[<span class="built_in">rs</span>(rt)], INF);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rs</span></span><br><span class="line">&#125; <span class="comment">// namespace SegmentTree</span></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; st[N], ed[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    G.<span class="built_in">resize</span>(n * <span class="number">80</span>);</span><br><span class="line">    S = idcnt = n + <span class="number">1</span>;</span><br><span class="line">    T         = S + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">        st[x1].<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(y1, y2));</span><br><span class="line">        ed[x2 + <span class="number">1</span>].<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(y1, y2));</span><br><span class="line">    &#125;</span><br><span class="line">    SegmentTree::<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : ed[i]) &#123;</span><br><span class="line">            SegmentTree::<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, v.first, v.second, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : st[i]) &#123;</span><br><span class="line">            SegmentTree::<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, v.first, v.second, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (id[<span class="number">1</span>] != <span class="number">-1</span>)</span><br><span class="line">            G.<span class="built_in">add_flow</span>(S, id[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; NetworkFlow::<span class="built_in">MaxFlow</span>(S, T, G);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>线段树优化建图</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.06.20模拟赛</title>
    <url>/2021/06/21/2021-06-20%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>咕咕咕</p>
<span id="more"></span>

<h2 id="2021-06-20-模拟赛"><a href="#2021-06-20-模拟赛" class="headerlink" title="2021.06.20 模拟赛"></a>2021.06.20 模拟赛</h2><h3 id="T1-城市建设"><a href="#T1-城市建设" class="headerlink" title="T1 城市建设"></a>T1 城市建设</h3><p><a href="https://sjzezoj.com/problem/405">城市建设</a></p>
<p>非常裸的并查集</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line">ll w[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, t;</span><br><span class="line">&#125; e[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> t, id;</span><br><span class="line">&#125; qy[N];</span><br><span class="line">ll ans[N];</span><br><span class="line"><span class="keyword">int</span> fa[N], siz[N];</span><br><span class="line">ll val[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = <span class="built_in">find</span>(x);</span><br><span class="line">    y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if (siz[x] &lt; siz[y]) &#123;</span></span><br><span class="line">        <span class="comment">// swap(x, y);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// siz[x] += siz[y];</span></span><br><span class="line">    val[x] += val[y];</span><br><span class="line">    fa[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;build.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;build.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;w[i]);</span><br><span class="line">        fa[i]  = i;</span><br><span class="line">        val[i] = w[i];</span><br><span class="line">        siz[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;e[i].t, &amp;e[i].u, &amp;e[i].v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(e + <span class="number">1</span>, e + <span class="number">1</span> + m, [&amp;](<span class="keyword">const</span> Edge &amp;A, <span class="keyword">const</span> Edge &amp;B) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> A.t &lt; B.t;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        cin &gt;&gt; qy[i].t;</span><br><span class="line">        qy[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(qy + <span class="number">1</span>, qy + <span class="number">1</span> + q, [&amp;](<span class="keyword">const</span> Query &amp;A, <span class="keyword">const</span> Query &amp;B) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> A.t &lt; B.t;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">    ll res  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (e[cur].t &lt;= qy[i].t &amp;&amp; cur &lt;= m) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = e[cur].u;</span><br><span class="line">            <span class="keyword">int</span> v = e[cur].v;</span><br><span class="line">            u     = <span class="built_in">find</span>(u);</span><br><span class="line">            v     = <span class="built_in">find</span>(v);</span><br><span class="line">            <span class="keyword">if</span> (u == v) &#123;</span><br><span class="line">                cur++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += <span class="number">1ll</span> * val[u] * val[v];</span><br><span class="line">                <span class="built_in">merge</span>(u, v);</span><br><span class="line">            &#125;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[qy[i].id] = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fclose(stdin);</span></span><br><span class="line">    <span class="comment">// fclose(stdout);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours.</span></span><br></pre></td></tr></table></figure>

<h3 id="T2-矩形"><a href="#T2-矩形" class="headerlink" title="T2 矩形"></a>T2 矩形</h3><p><a href="https://sjzezoj.com/problem/406">矩形2</a></p>
<p>扫描线板子，n为啥老找板子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], c[N];</span><br><span class="line"><span class="keyword">int</span> id[N], h[N];</span><br><span class="line">ll val[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    ll h;</span><br><span class="line">    <span class="keyword">int</span> typ;</span><br><span class="line">&#125; q[N * <span class="number">2</span>];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="keyword">namespace</span> SegmentTree &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) x * 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) x * 2 + 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ll sum, tag;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">&#125;;</span><br><span class="line">array&lt;Node, N &lt;&lt; 2&gt; tr;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    tr[x].l = l;</span><br><span class="line">    tr[x].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(x), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(x), mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    tr[x].sum = tr[<span class="built_in">ls</span>(x)].sum + tr[<span class="built_in">rs</span>(x)].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;l  = tr[x].l;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r  = tr[x].r;</span><br><span class="line">    <span class="keyword">auto</span> mid = (<span class="keyword">int</span>)(l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr[x].tag) &#123;</span><br><span class="line">        tr[<span class="built_in">ls</span>(x)].sum += tr[x].tag * <span class="number">1ll</span> * (mid - l + <span class="number">1</span>);</span><br><span class="line">        tr[<span class="built_in">rs</span>(x)].sum += tr[x].tag * <span class="number">1ll</span> * (r - mid);</span><br><span class="line">        tr[<span class="built_in">ls</span>(x)].tag += tr[x].tag;</span><br><span class="line">        tr[<span class="built_in">rs</span>(x)].tag += tr[x].tag;</span><br><span class="line">        tr[x].tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;l  = tr[rt].l;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r  = tr[rt].r;</span><br><span class="line">    <span class="keyword">auto</span> mid = (<span class="keyword">int</span>)(l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) &#123;</span><br><span class="line">        tr[rt].sum += <span class="number">1ll</span> * v * <span class="number">1ll</span> * (r - l + <span class="number">1</span>);</span><br><span class="line">        tr[rt].tag += v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid) &#123;</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">ls</span>(rt), L, R, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; R) &#123;</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">rs</span>(rt), L, R, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;l  = tr[rt].l;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r  = tr[rt].r;</span><br><span class="line">    <span class="keyword">auto</span> mid = (<span class="keyword">int</span>)(l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[rt].sum)</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> l - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="keyword">if</span> (!tr[<span class="built_in">rs</span>(rt)].sum)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(rt));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(rt));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rs</span></span><br><span class="line">&#125; <span class="comment">// namespace SegmentTree</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;horizon.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;horizon.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a[i], &amp;b[i], &amp;c[i]);</span><br><span class="line">        id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(id + <span class="number">1</span>, id + <span class="number">1</span> + n, [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> &amp;A, <span class="keyword">const</span> <span class="keyword">int</span> &amp;B) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c[A] &lt; c[B];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        h[id[i]] = i;</span><br><span class="line">        val[i]   = c[id[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    SegmentTree::<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        q[++tot] = &#123;a[i], h[i], <span class="number">1</span>&#125;;</span><br><span class="line">        q[++tot] = &#123;b[i], h[i], <span class="number">2</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + tot, [&amp;](<span class="keyword">const</span> Data &amp;A, <span class="keyword">const</span> Data &amp;B) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A.pos == B.pos) &#123;</span><br><span class="line">            <span class="keyword">return</span> A.typ &lt; B.typ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A.pos &lt; B.pos;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        ans += <span class="number">1ll</span> * val[last] * (q[i].pos - q[i - <span class="number">1</span>].pos);</span><br><span class="line">        <span class="keyword">if</span> (q[i].typ == <span class="number">1</span>) &#123;</span><br><span class="line">            SegmentTree::<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, q[i].h, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            SegmentTree::<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, q[i].h, <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        last = SegmentTree::<span class="built_in">query</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// fclose(stdin);</span></span><br><span class="line">    <span class="comment">// fclose(stdout);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours.</span></span><br></pre></td></tr></table></figure>

<h3 id="T3-新型计算机"><a href="#T3-新型计算机" class="headerlink" title="T3 新型计算机"></a>T3 新型计算机</h3><p>除了数据范围大了十倍以外和 4.20 的方舟系统完全一致，没懂n的找题思路</p>
<h3 id="T4-邮箱"><a href="#T4-邮箱" class="headerlink" title="T4 邮箱"></a>T4 邮箱</h3><p><a href="https://sjzezoj.com/problem/408">邮箱</a></p>
<p>当时没看懂题/kk</p>
<p>其实就是两个区间 $[a,b] \ [c,d]$ 从 $a \rightarrow b$ 依次随机向 $[c,d]$ 中的某个位置放球，球有颜色，每个位置有，求颜色匹配的的期望个数</p>
<p>首先每个球不论先后放下其实放对的概率是一样的，都是 $\dfrac{\mathrm{cnt}(\mathrm{col_i})}{d-c+1}$</p>
<p>基础的概率论结论，所以这个问题就是区间内颜色相同的点对的数量</p>
<p>区间容斥+大力莫队</p>
<p>卡常实实现:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll    = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>, Q = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">// const int BLOCK_SIZE = 893;</span></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">char</span> _getchar() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1</span> &lt;&lt; <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *fs, *ft, fbuf[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">if</span> (fs == ft) &#123;</span><br><span class="line">        ft = (fs = fbuf) + <span class="built_in">fread</span>(fbuf, <span class="number">1</span>, BUFFER_SIZE, stdin);</span><br><span class="line">        <span class="keyword">if</span> (fs == ft)</span><br><span class="line">            <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *fs++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x     = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch = _getchar())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>; ch = _getchar())</span><br><span class="line">        x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">        x = ~x + <span class="number">1</span>, <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">9</span>)</span><br><span class="line">        <span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(T &amp;x, Args &amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">write</span>(x);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="built_in">write</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace IO</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;ll, ll&gt; simply(ll x, ll y) &#123;</span><br><span class="line">    ll g = <span class="built_in">gcd</span>(x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(x / g, y / g);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line">array&lt;<span class="keyword">int</span>, N&gt; a, b;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, opt, id;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Data&gt; op;</span><br><span class="line">array&lt;<span class="keyword">int</span>, N&gt; len, belong, cnta, cntb;</span><br><span class="line">array&lt;ll, Q&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">read</span>(b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">read</span>(q);</span><br><span class="line">    op.<span class="built_in">resize</span>(<span class="number">4</span> * q);</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, x, y;</span><br><span class="line">        <span class="built_in">read</span>(l, r, x, y);</span><br><span class="line">        op[tot++] = (Data&#123;r, y, <span class="number">1</span>, i&#125;);</span><br><span class="line">        op[tot++] = (Data&#123;l - <span class="number">1</span>, y, <span class="number">-1</span>, i&#125;);</span><br><span class="line">        op[tot++] = (Data&#123;r, x - <span class="number">1</span>, <span class="number">-1</span>, i&#125;);</span><br><span class="line">        op[tot++] = (Data&#123;l - <span class="number">1</span>, x - <span class="number">1</span>, <span class="number">1</span>, i&#125;);</span><br><span class="line">        len[i]    = y - x + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> BLOCK_SIZE = (n / <span class="built_in">sqrt</span>(<span class="number">4</span> * q) + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">max</span>(n, m); i++) &#123;</span><br><span class="line">        belong[i] = (i - <span class="number">1</span>) / BLOCK_SIZE + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(op.<span class="built_in">begin</span>(), op.<span class="built_in">end</span>(), [&amp;](<span class="keyword">const</span> Data &amp;A, <span class="keyword">const</span> Data &amp;B) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (belong[A.l] == belong[B.l]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (belong[A.l] &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> belong[A.r] &gt; belong[B.r];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> belong[A.r] &lt; belong[B.r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A.l &lt; B.l;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="function">ll <span class="title">now</span><span class="params">(<span class="number">0ll</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> change_a = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> v) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">        now += cntb[a[x]] * v;</span><br><span class="line">        cnta[a[x]] += v;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> change_b = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> v) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">        now += cnta[b[x]] * v;</span><br><span class="line">        cntb[b[x]] += v;</span><br><span class="line">    &#125;;</span><br><span class="line">    for_each(op.<span class="built_in">begin</span>(), op.<span class="built_in">end</span>(), [&amp;](<span class="keyword">const</span> Data &amp;x) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; x.l) &#123;</span><br><span class="line">            l++;</span><br><span class="line">            <span class="built_in">change_a</span>(l, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; x.l) &#123;</span><br><span class="line">            <span class="built_in">change_a</span>(l, <span class="number">-1</span>);</span><br><span class="line">            l--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; x.r) &#123;</span><br><span class="line">            ++r;</span><br><span class="line">            <span class="built_in">change_b</span>(r, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &gt; x.r) &#123;</span><br><span class="line">            <span class="built_in">change_b</span>(r, <span class="number">-1</span>);</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[x.id] += now * x.opt;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">simply</span>(ans[i], len[i]);</span><br><span class="line">        <span class="built_in">write</span>(res.first, res.second);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>莫队</tag>
        <tag>并查集</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.06.13模拟赛</title>
    <url>/2021/06/15/2021-06-13%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>忘了写了，补一下</p>
<span id="more"></span>

<h2 id="2021-06-13-模拟赛"><a href="#2021-06-13-模拟赛" class="headerlink" title="2021.06.13 模拟赛"></a>2021.06.13 模拟赛</h2><h3 id="T1-理想路径"><a href="#T1-理想路径" class="headerlink" title="T1 理想路径"></a>T1 理想路径</h3><p><a href="https://sjzezoj.com/problem/122">理想路径</a></p>
<p>找路径直接贪心找是没问题的，但是有问题的是查询太大了</p>
<p>所以考虑二进制拆分一下记录倍增点，空间比较离谱，需要用 <code>short</code> 卡一波</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> v, nxt;</span><br><span class="line">    &#125; edge[N * <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N];</span><br><span class="line">    <span class="keyword">int</span> ecnt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        edge[++ecnt].v = v;</span><br><span class="line">        edge[ecnt].nxt = head[u];</span><br><span class="line">        head[u]        = ecnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G;</span><br><span class="line"><span class="keyword">bool</span> vis[N], inq[N];</span><br><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> fa[N][N][<span class="number">12</span>], dis[N][N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> _fa, <span class="keyword">int</span> dep, <span class="keyword">const</span> <span class="keyword">int</span> &amp;now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]) &#123;</span><br><span class="line">        <span class="keyword">return</span> inq[x];</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x] = inq[x] = <span class="number">1</span>;</span><br><span class="line">    fa[now][x][<span class="number">0</span>]   = _fa;</span><br><span class="line">    dis[now][x]     = dep;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">11</span>; i++) &#123;</span><br><span class="line">        fa[now][x][i] = fa[now][fa[now][x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[x]; i; i = G.edge[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G.edge[i].v;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(v, x, dep + <span class="number">1</span>, now)) &#123;</span><br><span class="line">            inq[x] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    inq[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">bool</span> g[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        g[u][v] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[i][j]) &#123;</span><br><span class="line">                G.<span class="built_in">add</span>(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(dis[i], <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis[i]));</span><br><span class="line">        <span class="built_in">dfs</span>(i, <span class="number">0</span>, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> s, t, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;s, &amp;t, &amp;k);</span><br><span class="line">        <span class="keyword">if</span> (dis[s][t] - k + <span class="number">1</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k = dis[s][t] - k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">11</span>; ~i; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((k &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                t = fa[s][t][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T2-旅游观光"><a href="#T2-旅游观光" class="headerlink" title="T2 旅游观光"></a>T2 旅游观光</h3><p><a href="https://sjzezoj.com/problem/402">旅游观光</a></p>
<p>缩点板子题啊..</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; edge[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        edge[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G, G1;</span><br><span class="line"><span class="keyword">int</span> c[N], v[N];</span><br><span class="line">set&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line"><span class="keyword">namespace</span> Tarjan &#123;</span><br><span class="line"><span class="keyword">int</span> dfn[N], low[N], dfnid, st[N], top;</span><br><span class="line"><span class="keyword">int</span> scc[N], scc_cnt, siz[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++dfnid;</span><br><span class="line">    st[++top]       = x;</span><br><span class="line">    vis[x]          = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G.edge[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">            <span class="built_in">Tarjan</span>(v);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[v]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vis[v]) &#123;</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low[x] == dfn[x]) &#123;</span><br><span class="line">        scc_cnt++;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            now      = st[top];</span><br><span class="line">            vis[now] = <span class="number">0</span>;</span><br><span class="line">            scc[now] = scc_cnt;</span><br><span class="line">            siz[scc_cnt] += v[now];</span><br><span class="line">            top--;</span><br><span class="line">        &#125; <span class="keyword">while</span> (now != x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace Tarjan</span></span><br><span class="line"><span class="keyword">int</span> in[N], ans[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; c[i] &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G.<span class="built_in">add</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Tarjan::dfn[i]) &#123;</span><br><span class="line">            Tarjan::<span class="built_in">Tarjan</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">using</span> Tarjan::scc;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : G.edge[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (scc[v] != scc[i] &amp;&amp; !g.<span class="built_in">count</span>(<span class="built_in">make_pair</span>(scc[i], scc[v]))) &#123;</span><br><span class="line">                g.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(scc[i], scc[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        G.edge[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : g) &#123;</span><br><span class="line">        G.<span class="built_in">add</span>(p.first, p.second);</span><br><span class="line">        in[p.second]++;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Tarjan::scc_cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!in[i]) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; topo;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        topo.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : G.edge[x]) &#123;</span><br><span class="line">            --in[v];</span><br><span class="line">            <span class="keyword">if</span> (!in[v]) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(topo.<span class="built_in">begin</span>(), topo.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : topo) &#123;</span><br><span class="line">        ans[x] += Tarjan::siz[x];</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : G.edge[x]) &#123;</span><br><span class="line">            tmp = <span class="built_in">max</span>(tmp, ans[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans[x] += tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="number">1.0</span> * ans[Tarjan::scc[i]] / (<span class="number">1.0</span> * c[i]));</span><br><span class="line">        <span class="comment">// printf(&quot;%d %d\n&quot;, i, ans[Tarjan::scc[i]]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T3-抵抗白宇（雾）"><a href="#T3-抵抗白宇（雾）" class="headerlink" title="T3 抵抗白宇（雾）"></a>T3 抵抗白宇（雾）</h3><p><a href="https://sjzezoj.com/problem/403">抵抗白蚁</a></p>
<p>虚树板子，同SDOI消耗战</p>
<p>数据范围看起来很鬼但其实时间开大了十倍</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x     = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch = <span class="built_in">getchar</span>())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>; ch = <span class="built_in">getchar</span>())</span><br><span class="line">        x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace IO</span></span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500004</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> v, w, nxt;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;Node&gt; edge;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; head;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        edge.<span class="built_in">emplace_back</span>(Node&#123;v, w, head[u]&#125;);</span><br><span class="line">        head[u] = edge.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Tr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph_QAQ</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">int</span> w, nxt;</span><br><span class="line">    &#125; edge[N * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N * <span class="number">2</span>], ecnt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        edge[++ecnt].v = v;</span><br><span class="line">        edge[ecnt].w   = w;</span><br><span class="line">        edge[ecnt].nxt = head[u];</span><br><span class="line">        head[u]        = ecnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; vTr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> tim, id[N], dep[N];</span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">20</span>];</span><br><span class="line">ll mmin[N][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> _fa)</span> </span>&#123;</span><br><span class="line">    dep[x]   = dep[_fa] + <span class="number">1</span>;</span><br><span class="line">    id[x]    = ++tim;</span><br><span class="line">    fa[x][<span class="number">0</span>] = _fa;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">19</span>; i++) &#123;</span><br><span class="line">        fa[x][i]   = fa[fa[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        mmin[x][i] = <span class="built_in">min</span>(mmin[x][i - <span class="number">1</span>], mmin[fa[x][i - <span class="number">1</span>]][i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Tr.head[x]; ~i; i = Tr.edge[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;e = Tr.edge[i];</span><br><span class="line">        <span class="keyword">int</span> v   = e.v;</span><br><span class="line">        <span class="keyword">if</span> (v == _fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        fa[v][<span class="number">0</span>]   = x;</span><br><span class="line">        mmin[v][<span class="number">0</span>] = e.w;</span><br><span class="line">        <span class="built_in">dfs1</span>(v, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y]) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[fa[x][i]] &gt;= dep[y]) &#123;</span><br><span class="line">            x = fa[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == y)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[x][i] != fa[y][i]) &#123;</span><br><span class="line">            x = fa[x][i];</span><br><span class="line">            y = fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">querymin</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t  = dep[x] - dep[y];</span><br><span class="line">    ll res = (<span class="number">1ll</span> &lt;&lt; <span class="number">62</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">19</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res, mmin[x][i]);</span><br><span class="line">            x   = fa[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> st[N], top, lca[N];</span><br><span class="line"><span class="keyword">bool</span> mark[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_tr</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + k + <span class="number">1</span>, [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> &amp;A, <span class="keyword">const</span> <span class="keyword">int</span> &amp;B) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id[A] &lt; id[B];</span><br><span class="line">    &#125;);</span><br><span class="line">    top       = <span class="number">0</span>;</span><br><span class="line">    st[++top] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">0</span>]      = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        lca[i]         = <span class="built_in">LCA</span>(a[i], a[i - <span class="number">1</span>]);</span><br><span class="line">        vTr.head[a[i]] = vTr.head[lca[i]] = <span class="number">-1</span>;</span><br><span class="line">        mark[lca[i]]                      = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        mark[a[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; dep[lca[i]] &lt; dep[st[top - <span class="number">1</span>]]) &#123;</span><br><span class="line">            vTr.<span class="built_in">add</span>(st[top - <span class="number">1</span>], st[top], <span class="built_in">querymin</span>(st[top], st[top - <span class="number">1</span>]));</span><br><span class="line">            --top;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lca[i] != st[top]) &#123;</span><br><span class="line">            vTr.<span class="built_in">add</span>(lca[i], st[top], <span class="built_in">querymin</span>(st[top], lca[i]));</span><br><span class="line">            --top;</span><br><span class="line">            <span class="keyword">if</span> (lca[i] != st[top]) &#123;</span><br><span class="line">                st[++top] = lca[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[i] != st[top]) &#123;</span><br><span class="line">            st[++top] = a[i];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        vTr.<span class="built_in">add</span>(st[top - <span class="number">1</span>], st[top], <span class="built_in">querymin</span>(st[top], st[top - <span class="number">1</span>]));</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll dp[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    dp[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = vTr.head[x]; ~i; i = vTr.edge[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;e = vTr.edge[i];</span><br><span class="line">        <span class="built_in">dfs2</span>(e.v);</span><br><span class="line">        dp[x] += mark[e.v] ? e.w : <span class="built_in">min</span>(dp[e.v], <span class="number">1ll</span> * e.w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    Tr.head.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">read</span>(a, b, c);</span><br><span class="line">        Tr.<span class="built_in">add</span>(a, b, c);</span><br><span class="line">        Tr.<span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        vTr.ecnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">read</span>(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="built_in">read</span>(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build_tr</span>(k);</span><br><span class="line">        <span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;U&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, dp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T4-兔兔与蛋蛋的游戏"><a href="#T4-兔兔与蛋蛋的游戏" class="headerlink" title="T4 兔兔与蛋蛋的游戏"></a>T4 兔兔与蛋蛋的游戏</h3><p>原题 NOI2011 兔兔与蛋蛋的游戏</p>
<p>挺妙的题</p>
<p>第一个性质是空白点一定没办法转回来，因为转回来意味着它移动了偶数次，而这一次的黑白手是互换的，所以不可能做到</p>
<p>那么空白点的移动就没有环，同时因为每次都是黑白交替的，可以理解为在一个二分图上增广的过程</p>
<p>二分图上博弈如果先手落入最大匹配中的点中则先手必败，因为后手仅需走最大匹配即可</p>
<p>那么如果一个点是所有最大匹配的必选点则必胜</p>
<p>所以删掉这个点如果它的匹配点还能找到别的匹配说明存在一个最大匹配不包含他</p>
<p>兔兔犯错意味着当前是必胜的走完蛋蛋是必胜的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">45</span>, K = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; edge[N * N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        edge[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_two</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">add</span>(u, v);</span><br><span class="line">        <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G;</span><br><span class="line"><span class="keyword">const</span> array&lt;<span class="keyword">int</span>, 4&gt; dx = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dy = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">array&lt;<span class="keyword">char</span>, N&gt; s;</span><br><span class="line">array&lt;array&lt;<span class="keyword">int</span>, N&gt;, N&gt; mp;</span><br><span class="line">array&lt;<span class="keyword">bool</span>, N * N&gt; ban;</span><br><span class="line">array&lt;<span class="keyword">int</span>, N * N&gt; vis, link;</span><br><span class="line">array&lt;<span class="keyword">bool</span>, 2 * K&gt; win;</span><br><span class="line">array&lt;<span class="keyword">int</span>, K&gt; ans;</span><br><span class="line"><span class="keyword">int</span> vistim;</span><br><span class="line"><span class="keyword">int</span> sx, sy;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">const</span> Graph &amp;G)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ban[x]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G.edge[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[v] == vistim || ban[v]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[v] = vistim;</span><br><span class="line">        <span class="keyword">if</span> (!link[v] || <span class="built_in">match</span>(link[v], G)) &#123;</span><br><span class="line">            link[v] = x;</span><br><span class="line">            link[x] = v;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * m + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_bound</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; (s.<span class="built_in">data</span>() + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                mp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[j] == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                mp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mp[i][j] = <span class="number">1</span>;</span><br><span class="line">                sx       = i;</span><br><span class="line">                sy       = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mp[i][j]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = i + dx[k], ny = j + dy[k];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check_bound</span>(nx, ny) &amp;&amp; !mp[nx][ny]) &#123;</span><br><span class="line">                    G.<span class="built_in">add_two</span>(<span class="built_in">id</span>(i, j), <span class="built_in">id</span>(nx, ny));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp[i][j]) &#123;</span><br><span class="line">                ++vistim;</span><br><span class="line">                <span class="built_in">match</span>(<span class="built_in">id</span>(i, j), G);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    k *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> now  = <span class="built_in">id</span>(sx, sy);</span><br><span class="line">        ban[now] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (link[now]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y     = link[now];</span><br><span class="line">            link[now] = link[y] = <span class="number">0</span>;</span><br><span class="line">            ++vistim;</span><br><span class="line">            win[i] = !<span class="built_in">match</span>(y, G);</span><br><span class="line">        &#125;</span><br><span class="line">        cin &gt;&gt; sx &gt;&gt; sy;</span><br><span class="line">    &#125;</span><br><span class="line">    k /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (win[i * <span class="number">2</span> - <span class="number">1</span>] &amp;&amp; win[i * <span class="number">2</span>]) &#123;</span><br><span class="line">            ans[++tot] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; tot &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>缩点</tag>
        <tag>虚树</tag>
        <tag>博弈论</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.06.06模拟赛</title>
    <url>/2021/06/07/2021-06-06%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>怎么看都很毒瘤</p>
<p><del>瑕光天下第一</del></p>
<span id="more"></span>

<h2 id="2021-06-06-模拟赛"><a href="#2021-06-06-模拟赛" class="headerlink" title="2021.06.06 模拟赛"></a>2021.06.06 模拟赛</h2><h3 id="T1-背包"><a href="#T1-背包" class="headerlink" title="T1 背包"></a>T1 背包</h3><p><a href="https://sjzezoj.com/problem/388">Link</a></p>
<p>同余最短路</p>
<p>先贪心拿最大的先尽可能地装，因为背包容量太大了所以最优解肯定绝大部分都是这么拿的</p>
<p>记他为 $p$，在 $\bmod p$ 意义下转移，就是同于最短路</p>
<p>如果拿一个新的物品 $x$ ，如果 $now+x  &lt; p$ 直接更新消耗 $1$ 代价，否则可以考虑拿去一个 $p$ 换上 $now+x \bmod p$ 消耗 $0$ 代价</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> T, dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x7f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(dis[<span class="number">0</span>]);</span><br><span class="line">    vis[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x  = q.<span class="built_in">front</span>();</span><br><span class="line">        vis[x] = <span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : a) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = x + p;</span><br><span class="line">            <span class="keyword">int</span> w = (v &gt;= a[n - <span class="number">1</span>]) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (v &gt;= a[n - <span class="number">1</span>]) &#123;</span><br><span class="line">                v %= a[n - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[x] + w) &#123;</span><br><span class="line">                dis[v] = dis[x] + w;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    vis[v] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">        a.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : a) &#123;</span><br><span class="line">            cin &gt;&gt; v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">spfa</span>();</span><br><span class="line">        <span class="keyword">if</span> (dis[m % a[n - <span class="number">1</span>]] &gt;= (<span class="number">1ll</span> &lt;&lt; <span class="number">30</span>)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;IMPOSSIBLE&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; (m / a[n - <span class="number">1</span>]) + dis[m % a[n - <span class="number">1</span>]] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Asusetic eru quionours.</span></span><br></pre></td></tr></table></figure>

<h3 id="T2-推箱子"><a href="#T2-推箱子" class="headerlink" title="T2 推箱子"></a>T2 推箱子</h3><p><a href="https://sjzezoj.com/problem/389">Link</a></p>
<p>毒瘤之一</p>
<p>先连好图的模型，然后考虑从终点往回倒着推，人只能在箱子的某一侧并且是确定的</p>
<p>人的行为只能是</p>
<ul>
<li>推箱子</li>
<li>从某一侧走到某一侧以便于推箱子</li>
</ul>
<p>第一个行为没有问题，第二个行为就是找到一条不过箱子的路径到达箱子的另一侧，思考一下就能发现要求这两个位置在一个点双里</p>
<p>现在我们找出来了所有可行状态，然后就是考虑初始状态人可以从某一个点走到箱子旁边</p>
<p>现在需要统计这个点有多少个，也就是删掉一个点后有几个点与之联通，也就是删点后人所在连通块的大小</p>
<p>先把圆方树建出来（人比较菜不会建圆方树，不在点双里的点直接挂到了相邻点上，但是最终效果是一样的，正确的圆方树可以看 $\color{black}\text{R}\color{red}\text{enamoe}$ 的<a href="https://sjzezoj.com/submission/10745">代码</a>）</p>
<p>如果人在箱子的子树里，就只能走到自己的点双里的点</p>
<p>如果在箱子的点的外面，就可以走除去终点和箱子子树的所有点</p>
<p>码成一坨的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1055</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"><span class="keyword">char</span> mp[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_bound</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * m + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; edge[N * N * <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        edge[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G, Tr;</span><br><span class="line"><span class="keyword">int</span> dep[N * N * <span class="number">2</span>], vis[N * N], low[N * N], dfn[N * N], dfnid, fa[N * N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> st[N * N], top, dcc[N * N];</span><br><span class="line"><span class="keyword">bool</span> reach[N][N][<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    low[x] = dfn[x] = ++dfnid;</span><br><span class="line">    st[++top]       = x;</span><br><span class="line">    dcc[x]          = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G.edge[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == fa[x]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">            fa[v] = x;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[v]);</span><br><span class="line">            <span class="keyword">if</span> (low[v] == dfn[x]) &#123;</span><br><span class="line">                <span class="keyword">while</span> (st[top] != v) &#123;</span><br><span class="line">                    dcc[st[top]] = x;</span><br><span class="line">                    top--;</span><br><span class="line">                &#125;</span><br><span class="line">                top--;</span><br><span class="line">                dcc[v] = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (low[v] &gt; dfn[x]) &#123;</span><br><span class="line">                <span class="keyword">while</span> (st[top] != v) &#123;</span><br><span class="line">                    --top;</span><br><span class="line">                &#125;</span><br><span class="line">                --top;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> siz[N * N * <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    dep[x] = dep[fa[x]] + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; fa[x] &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt;= n * m)</span><br><span class="line">        siz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G.edge[x]) &#123;</span><br><span class="line">        fa[v] = x;</span><br><span class="line">        <span class="built_in">dfs2</span>(v);</span><br><span class="line">        siz[x] += siz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sx, sy;</span><br><span class="line"><span class="keyword">bool</span> qvis[N][N][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y, p;</span><br><span class="line">    &#125;;</span><br><span class="line">    queue&lt;Node&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check_bound</span>(sx + dx[i], sy + dy[i]) &amp;&amp; !a[sx + dx[i]][sy + dy[i]]) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(Node&#123;sx, sy, i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> p  = now.p;</span><br><span class="line">        <span class="keyword">int</span> nx = now.x + dx[p], ny = now.y + dy[p];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check_bound</span>(nx + dx[p], ny + dy[p]) &amp;&amp; !a[nx + dx[p]][ny + dy[p]] &amp;&amp;</span><br><span class="line">            !qvis[nx][ny][p]) &#123;</span><br><span class="line">            qvis[nx][ny][p] = <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(Node&#123;nx, ny, p&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (reach[now.x][now.y][p][i] &amp;&amp; !qvis[now.x][now.y][i]) &#123;</span><br><span class="line">                qvis[now.x][now.y][i] = <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(Node&#123;now.x, now.y, i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; mp + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp[j] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                a[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mp[j] == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                sx = i;</span><br><span class="line">                sy = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="built_in">id</span>(sx, sy);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!a[i][j]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = i + dx[k], ny = j + dy[k];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">check_bound</span>(nx, ny) &amp;&amp; !a[nx][ny]) &#123;</span><br><span class="line">                        G.<span class="built_in">add</span>(<span class="built_in">id</span>(i, j), <span class="built_in">id</span>(nx, ny));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">tarjan</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[<span class="built_in">id</span>(i, j)]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = k + <span class="number">1</span>; l &lt; <span class="number">4</span>; l++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!<span class="built_in">check_bound</span>(i + dx[k], j + dy[k]) ||</span><br><span class="line">                            !<span class="built_in">check_bound</span>(i + dx[l], j + dy[l]))</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">int</span> a = <span class="built_in">id</span>(i + dx[k], j + dy[k]);</span><br><span class="line">                        <span class="keyword">int</span> b = <span class="built_in">id</span>(i + dx[l], j + dy[l]);</span><br><span class="line">                        <span class="keyword">if</span> (dcc[a] == dcc[b] || dcc[a] == b || dcc[b] == a) &#123;</span><br><span class="line">                            reach[i][j][k][l] = reach[i][j][l][k] = <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * m; i++) &#123;</span><br><span class="line">        G.edge[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) &#123;</span><br><span class="line">            ++tot;</span><br><span class="line">            G.<span class="built_in">add</span>(i, i + n * m);</span><br><span class="line">            <span class="keyword">if</span> (dcc[i] != i) &#123;</span><br><span class="line">                G.<span class="built_in">add</span>(dcc[i] + n * m, i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                G.<span class="built_in">add</span>(fa[i], i);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; fa[i] &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs2</span>(s);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[<span class="built_in">id</span>(i, j)] &amp;&amp; (i != sx || j != sy)) &#123;</span><br><span class="line">                <span class="keyword">int</span> p   = <span class="built_in">id</span>(i, j);</span><br><span class="line">                <span class="keyword">bool</span> f1 = <span class="number">0</span>, f2 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (qvis[i][j][k]) &#123;</span><br><span class="line">                        <span class="keyword">int</span> x = <span class="built_in">id</span>(i + dx[k], j + dy[k]);</span><br><span class="line">                        <span class="keyword">if</span> (fa[x] == p) &#123;</span><br><span class="line">                            ans += <span class="number">1ll</span> * siz[x];</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dep[x] &gt; dep[p]) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!f1) &#123;</span><br><span class="line">                                ans += <span class="number">1ll</span> * siz[p + n * m];</span><br><span class="line">                                f1 = <span class="number">1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (fa[p] == x) &#123;</span><br><span class="line">                                ans += <span class="number">1ll</span> * tot - <span class="number">1</span> - siz[p];</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (!f2) &#123;</span><br><span class="line">                                    ans += <span class="number">1ll</span> * tot - <span class="number">1</span> - siz[p];</span><br><span class="line">                                    f2 = <span class="number">1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours.</span></span><br></pre></td></tr></table></figure>

<h3 id="T3-家训是『不畏苦暗』"><a href="#T3-家训是『不畏苦暗』" class="headerlink" title="T3 家训是『不畏苦暗』"></a>T3 家训是『不畏苦暗』</h3><p><del>瑕光天下第一！</del></p>
<p><del>看std这个题大概是叫Blemishine</del></p>
<p>毒瘤之二</p>
<p>暴力做法是直接大力拓扑然后确定每个点能够达到的异或值，复杂度 $O(2^{10}n)$</p>
<p>虽然是常数但是肯定过不去..</p>
<p>用<del>从来没见过</del>的压位来优化一下这个复杂度</p>
<p>设我们把点权低 $l$ 位压起来，一共有 $2^{2^l}$ 种可能，预处理 $trans[i,j]$ 表示低 $l$ 位权值为状态位 $i$ 时，异或 $j$ 的结果</p>
<p>转移的时候设 $dp_{i,j}$ 表示点 $i$ 高 $10-l$ 位为 $j$ 时，低 $l$ 位的可能状态，通过 $trans$ 转移</p>
<p>$trans$ 还可以高低位拆开处理 复杂度 $O(2^{2^{l-1}}2^{2l}+n2^{10-l})$</p>
<p>代码取得 $l=4$ ，不过看起来 $5$ 更优</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; edge[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        edge[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G;</span><br><span class="line"><span class="keyword">int</span> in[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">low</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; ((<span class="number">1</span> &lt;&lt; bit) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">high</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;&gt; bit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[N][(<span class="number">1</span> &lt;&lt; <span class="number">8</span>) + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> tmp[(<span class="number">1</span> &lt;&lt; <span class="number">8</span>) + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> hight[(<span class="number">1</span> &lt;&lt; <span class="number">8</span>) + <span class="number">5</span>][(<span class="number">1</span> &lt;&lt; <span class="number">4</span>) + <span class="number">5</span>], lowt[(<span class="number">1</span> &lt;&lt; <span class="number">8</span>) + <span class="number">5</span>][(<span class="number">1</span> &lt;&lt; <span class="number">4</span>) + <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> lg[(<span class="number">1</span> &lt;&lt; <span class="number">8</span>) + <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    lg[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">8</span>); i++) &#123;</span><br><span class="line">        lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">8</span>); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; <span class="number">4</span>); ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">7</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; k)) &#123;</span><br><span class="line">                    lowt[i][j] |= <span class="number">1</span> &lt;&lt; (k ^ j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">8</span>); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; <span class="number">4</span>); ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">8</span>; k &lt;= <span class="number">15</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; (k - <span class="number">8</span>))) &#123;</span><br><span class="line">                    hight[i][j] |= <span class="number">1</span> &lt;&lt; (k ^ j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        in[v]++;</span><br><span class="line">        G.<span class="built_in">add</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; topo;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!in[i]) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        topo.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : G.edge[x]) &#123;</span><br><span class="line">            --in[v];</span><br><span class="line">            <span class="keyword">if</span> (!in[v]) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">1</span>][a[<span class="number">1</span>] &gt;&gt; <span class="number">4</span>] = <span class="number">1</span> &lt;&lt; (a[<span class="number">1</span>] &amp; <span class="number">15</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : topo) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">8</span>); i++) &#123;</span><br><span class="line">            tmp[i ^ (a[x] &gt;&gt; <span class="number">4</span>)] = hight[<span class="built_in">high</span>(dp[x][i], <span class="number">8</span>)][<span class="built_in">low</span>(a[x], <span class="number">4</span>)] |</span><br><span class="line">                                   lowt[<span class="built_in">low</span>(dp[x][i], <span class="number">8</span>)][<span class="built_in">low</span>(a[x], <span class="number">4</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">8</span>); i++) &#123;</span><br><span class="line">            dp[x][i] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : G.edge[x]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">8</span>); i++) &#123;</span><br><span class="line">                dp[v][i] |= dp[x][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">10</span>); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[n][<span class="built_in">high</span>(i, <span class="number">4</span>)] &amp; (<span class="number">1</span> &lt;&lt; (<span class="built_in">low</span>(i, <span class="number">4</span>)))) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T4-边"><a href="#T4-边" class="headerlink" title="T4 边"></a>T4 边</h3><p>也许是唯一可做题</p>
<p>求最小生成树的过程里把相同边权的在不连通块的边全都加进去跑 tarjan，割边必然选，其他边随意</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Type</span> &#123;</span> VOID, ANY, ALO, NONE &#125;;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">turn</span><span class="params">(Type typ)</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (typ) &#123;</span><br><span class="line">    <span class="keyword">case</span> ANY:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;any&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> ALO:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;at least one&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> NONE:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;none&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;none&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Type ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> u, v, w, id;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;Node&gt; edge;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        edge.<span class="built_in">emplace_back</span>(Node&#123;u, v, w, id&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G;</span><br><span class="line"><span class="keyword">namespace</span> Tarjan &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, id;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Node&gt; edge[N];</span><br><span class="line"><span class="keyword">int</span> dfn[N], low[N], dfn_id;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_two</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    edge[u].<span class="built_in">emplace_back</span>(Node&#123;v, id&#125;);</span><br><span class="line">    edge[v].<span class="built_in">emplace_back</span>(Node&#123;u, id&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++dfn_id;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : edge[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.id == fa) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[e.v]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(e.v, e.id);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[e.v]);</span><br><span class="line">            <span class="keyword">if</span> (low[e.v] &gt; dfn[x]) &#123;</span><br><span class="line">                ans[e.id] = ANY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], dfn[e.v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace Tarjan</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">namespace</span> MST &#123;</span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mst</span><span class="params">(Graph &amp;G)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> Tarjan::add_two;</span><br><span class="line">    <span class="keyword">using</span> Tarjan::dfn;</span><br><span class="line">    <span class="keyword">using</span> Tarjan::dfn_id;</span><br><span class="line">    <span class="keyword">using</span> Tarjan::low;</span><br><span class="line">    <span class="keyword">using</span> Tarjan::tarjan;</span><br><span class="line">    <span class="keyword">auto</span> &amp;edge = G.edge;</span><br><span class="line">    <span class="built_in">sort</span>(edge.<span class="built_in">begin</span>(), edge.<span class="built_in">end</span>(),</span><br><span class="line">         [&amp;](<span class="keyword">const</span> Graph::Node &amp;A, <span class="keyword">const</span> Graph::Node &amp;B) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> A.w &lt; B.w;</span><br><span class="line">         &#125;);</span><br><span class="line">    <span class="keyword">typedef</span> vector&lt;Graph::Node&gt;::iterator iter;</span><br><span class="line">    iter r;</span><br><span class="line">    <span class="keyword">for</span> (iter l = edge.<span class="built_in">begin</span>(); l != edge.<span class="built_in">end</span>(); l = r) &#123;</span><br><span class="line">        r = l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (r != edge.<span class="built_in">end</span>() &amp;&amp; r-&gt;w == l-&gt;w) &#123;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        for_each(l, r, [&amp;](Graph::Node x) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = <span class="built_in">find</span>(x.u), v = <span class="built_in">find</span>(x.v);</span><br><span class="line">            <span class="keyword">if</span> (u == v) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">add_two</span>(u, v, x.id);</span><br><span class="line">            dfn[u] = dfn[v] = <span class="number">0</span>;</span><br><span class="line">            ans[x.id]       = ALO;</span><br><span class="line">        &#125;);</span><br><span class="line">        for_each(l, r, [&amp;](Graph::Node x) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = <span class="built_in">find</span>(x.u), v = <span class="built_in">find</span>(x.v);</span><br><span class="line">            <span class="keyword">if</span> (u == v) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[u]) &#123;</span><br><span class="line">                dfn_id = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">tarjan</span>(u, <span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        for_each(l, r, [&amp;](Graph::Node x) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = <span class="built_in">find</span>(x.u), v = <span class="built_in">find</span>(x.v);</span><br><span class="line">            <span class="keyword">if</span> (u == v) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Tarjan::edge[u].<span class="built_in">clear</span>();</span><br><span class="line">            Tarjan::edge[v].<span class="built_in">clear</span>();</span><br><span class="line">            fa[u] = v;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace MST</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        ans[i]     = NONE;</span><br><span class="line">        MST::fa[i] = i;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        G.<span class="built_in">add</span>(u, v, w, i);</span><br><span class="line">    &#125;</span><br><span class="line">    MST::<span class="built_in">mst</span>(G);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="built_in">turn</span>(ans[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours.</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>压位</tag>
        <tag>圆方树</tag>
        <tag>同余最短路</tag>
        <tag>缩点</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1526D Kill Anton</title>
    <url>/2021/06/02/CF1526D-Kill-Anton/</url>
    <content><![CDATA[<p>CF1526D Kill Anton</p>
<span id="more"></span>

<p>应该能发现交换次数是和逆序对有关的，具体来说是原串的字符在构造的串中下一次出现的位置的数组的逆序对</p>
<p>比如 $s=\mathrm{ANTON} \ t=\mathrm{NNOTA}$ 位置数组为 $P=[5,1,4,3,2]$ 逆序对数为 $7$ 需要交换七次</p>
<p>手玩或者口胡一下会发现如果相同的字符放在一起不会更劣</p>
<p>证明：</p>
<p>设我们现在找到的字符串长这样 $\mathrm{….AAA_x….A_yAA…}$ ($A_x,A_y$ 仅用于标记，这两个字符 $P$ 中分别位于 $i,j$)</p>
<p>考虑两种合并方式 $\mathrm{….AAA_{x}A_{y}…AA…}$ 和 $\mathrm{…AA…A_{x}A_{y}AA}$ </p>
<p>考虑第一种产生/消除的逆序对数量和为 $D_1=\sum\limits_{k=i+1}^{j-1} \mathrm{sign}(P_k-P_i)$</p>
<p>其中 $\mathrm{sign}(x)=\dfrac{x}{|x|}$ 就是取符号</p>
<p>第二种为 $D_2=\sum\limits_{k=i+1}^{j-1}\mathrm{sign}(P_j-P_k)$</p>
<p>事实上不可能有 $D_1+D_2 &lt; 0$</p>
<p>这样就意味着至少存在有某个 $k$ 使得 $\mathrm{sign}(P_k-P_i)+\mathrm{sign}(P_j-P_k) &lt; 0$</p>
<p>即 $P_k &lt; P_i $ 且 $P_k &gt; P_j \Rightarrow P_j &lt;P_i$ 矛盾</p>
<p>那么有 $D_1+D_2 \ge 0$ 意味着这两者中至少有一个大于等于 $0$ </p>
<p>那么按同样的方法把所有的相同字符放在一起不会更劣</p>
<p>枚举放每种字符的顺序共 $4!$ 种，每种 $n\log n$ 求逆序对比较大小即可</p>
<p>复杂度 $O(n\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100004</span>;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> tmp[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> qres;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">msort</span>(l, m);</span><br><span class="line">    <span class="built_in">msort</span>(m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">int</span> i = l, j = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">            tmp[k++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[k++] = a[j++];</span><br><span class="line">            qres += <span class="number">1ll</span> * m - i + <span class="number">1ll</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m)</span><br><span class="line">        tmp[k++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">        tmp[k++] = a[j++];</span><br><span class="line">    <span class="keyword">for</span> (i = l, k = <span class="number">0</span>; i &lt;= r; i++, k++)</span><br><span class="line">        a[i] = tmp[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">auto</span> turn = [&amp;](<span class="keyword">char</span> c) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;N&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;T&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; v[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            v[<span class="built_in">turn</span>(s[i])].<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> chr[]     = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;T&#x27;</span>&#125;;</span><br><span class="line">        string ans     = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mmax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            qres       = <span class="number">0</span>;</span><br><span class="line">            string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt    = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> p : v[<span class="built_in">turn</span>(chr[i])]) &#123;</span><br><span class="line">                    res += chr[i];</span><br><span class="line">                    a[++cnt] = p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">msort</span>(<span class="number">1</span>, cnt);</span><br><span class="line">            <span class="keyword">if</span> (qres &gt;= mmax) &#123;</span><br><span class="line">                mmax = qres;</span><br><span class="line">                ans  = res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(chr, chr + <span class="number">4</span>));</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.05.30模拟赛</title>
    <url>/2021/06/01/2021-05-30%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>原题场（确信）</p>
<span id="more"></span>

<h2 id="2021-05-30-模拟赛"><a href="#2021-05-30-模拟赛" class="headerlink" title="2021.05.30 模拟赛"></a>2021.05.30 模拟赛</h2><h3 id="T1-识别子串"><a href="#T1-识别子串" class="headerlink" title="T1 识别子串"></a>T1 识别子串</h3><p><a href="https://sjzezoj.com/problem/381">识别子串</a></p>
<p>考虑仅出现一次的子串在 SAM 上就是 $endpos$ 大小为 $1$ 的点</p>
<p>建出来 SAM 后找到所有大小为 $1$ 的点 $x$ ，他们在原串上对应的点为 $pos$</p>
<p>那么他能更新的是 </p>
<p>$[pos-\mathrm{minlen}(x),pos] \rightarrow \mathrm{minlen}(x)$ 和</p>
<p>$[pos-\mathrm{maxlen}(x)+1,pos-\mathrm{minlen}(x)] \rightarrow pos-i+1$</p>
<p>后面那个 $pos-i+1$ 不可能一个个更新去，但是可以开两个线段树，一个更新 $\mathrm{minlen}(x)$ 的，另一个负责更新 $pos-i+1$ 的</p>
<p>查询的时候把第二个线段树 $-i$ 和第一个取 $\min$ 即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> siz[N * <span class="number">2</span>], c[N * <span class="number">2</span>], pos[N * <span class="number">2</span>], a[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">namespace</span> SAM &#123;</span><br><span class="line"><span class="keyword">int</span> nxt[N * <span class="number">2</span>][<span class="number">27</span>], link[N * <span class="number">2</span>], len[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>, last = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur  = ++cnt;</span><br><span class="line">    <span class="keyword">int</span> p    = last;</span><br><span class="line">    last     = cur;</span><br><span class="line">    len[cur] = len[p] + <span class="number">1</span>;</span><br><span class="line">    siz[cur] = <span class="number">1</span>;</span><br><span class="line">    pos[cur] = len[cur];</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; !nxt[p][c]) &#123;</span><br><span class="line">        nxt[p][c] = cur;</span><br><span class="line">        p         = link[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">        link[cur] = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q = nxt[p][c];</span><br><span class="line">        <span class="keyword">if</span> (len[p] + <span class="number">1</span> == len[q]) &#123;</span><br><span class="line">            link[cur] = q;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> cq  = ++cnt;</span><br><span class="line">            len[cq] = len[p] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(nxt[cq], nxt[q], <span class="built_in"><span class="keyword">sizeof</span></span>(nxt[q]));</span><br><span class="line">            link[cq] = link[q];</span><br><span class="line">            link[q] = link[cur] = cq;</span><br><span class="line">            <span class="keyword">while</span> (p &amp;&amp; nxt[p][c] == q) &#123;</span><br><span class="line">                nxt[p][c] = cq;</span><br><span class="line">                p         = link[p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace SAM</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> SAM;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) x * 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) x * 2 + 1</span></span><br><span class="line">    <span class="keyword">int</span> tree[N &lt;&lt; <span class="number">2</span>], tag[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="built_in">Segment_Tree</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tag, <span class="number">0x3f3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(tag));</span><br><span class="line">        <span class="built_in">memset</span>(tree, <span class="number">0x3f3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(tree));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        tag[<span class="built_in">ls</span>(x)]  = <span class="built_in">min</span>(tag[<span class="built_in">ls</span>(x)], tag[x]);</span><br><span class="line">        tag[<span class="built_in">rs</span>(x)]  = <span class="built_in">min</span>(tag[<span class="built_in">rs</span>(x)], tag[x]);</span><br><span class="line">        tree[<span class="built_in">ls</span>(x)] = <span class="built_in">min</span>(tree[<span class="built_in">ls</span>(x)], tag[x]);</span><br><span class="line">        tree[<span class="built_in">rs</span>(x)] = <span class="built_in">min</span>(tree[<span class="built_in">rs</span>(x)], tag[x]);</span><br><span class="line">        tag[x]      = INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; R || r &lt; L)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= L &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">            tree[x] = <span class="built_in">min</span>(tree[x], d);</span><br><span class="line">            tag[x]  = <span class="built_in">min</span>(tag[x], d);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">ls</span>(x), l, mid, L, R, d);</span><br><span class="line">        <span class="built_in">update</span>(<span class="built_in">rs</span>(x), mid + <span class="number">1</span>, r, L, R, d);</span><br><span class="line">        tree[x] = <span class="built_in">min</span>(tree[<span class="built_in">ls</span>(x)], tree[<span class="built_in">rs</span>(x)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> tree[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= mid) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(x), l, mid, pos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(x), mid + <span class="number">1</span>, r, pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rs</span></span><br><span class="line">&#125; A, B;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        SAM::<span class="built_in">insert</span>(s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">        ++c[len[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">        c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">        a[c[len[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt; i; --i) &#123;</span><br><span class="line">        siz[link[a[i]]] += siz[a[i]];</span><br><span class="line">        pos[link[a[i]]] = <span class="built_in">max</span>(pos[link[a[i]]], pos[a[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (siz[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = len[link[i]], r = len[i];</span><br><span class="line">            A.<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, pos[i] - l, pos[i], l + <span class="number">1</span>);</span><br><span class="line">            B.<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, pos[i] - r + <span class="number">1</span>, pos[i] - l, pos[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">min</span>(A.<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, i), B.<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, i) - i) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T2-解密运算"><a href="#T2-解密运算" class="headerlink" title="T2 解密运算"></a>T2 解密运算</h3><p>原题 [THUSC2015] 解密运算</p>
<p>找规律题</p>
<p>先考虑 $O(n^2)$ 的暴力</p>
<p>对于 </p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">5 </span><span class="number">3</span> </span><br><span class="line"><span class="symbol">3 </span><span class="number">0</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这个数据</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>?<span class="string">??</span><span class="string">?3</span></span><br><span class="line"><span class="number">1</span>?<span class="string">??</span><span class="string">?0</span></span><br><span class="line"><span class="number">1</span>?<span class="string">??</span><span class="string">?2</span></span><br><span class="line"><span class="number">2</span>?<span class="string">??</span><span class="string">?1</span></span><br><span class="line"><span class="number">2</span>?<span class="string">??</span><span class="string">?1</span></span><br><span class="line"><span class="number">3</span>?<span class="string">??</span><span class="string">?2</span></span><br></pre></td></tr></table></figure>

<p>因为第一列和最后一列确定，加密排序之后的矩阵大概长这个样子</p>
<p>因为原字符串当作环处理，所以可以确定一些关系 </p>
<p>上面的可以确定 <code> x -&gt; y</code> 代表 <code>x </code> 后面可能是 <code>y</code></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">3 </span>-&gt; <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span>-&gt; <span class="number">1</span></span><br><span class="line"><span class="symbol">2 </span>-&gt; <span class="number">1</span></span><br><span class="line"><span class="symbol">2 </span>-&gt; <span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span>-&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>然后因为是字典序排序，可以推出来第二列</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">01</span>???<span class="number">3</span></span><br><span class="line"><span class="attribute">12</span>???<span class="number">0</span></span><br><span class="line"><span class="attribute">12</span>???<span class="number">2</span></span><br><span class="line"><span class="attribute">21</span>???<span class="number">1</span></span><br><span class="line"><span class="attribute">23</span>???<span class="number">1</span></span><br><span class="line"><span class="attribute">30</span>???<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>然后大力递推就能得到整个矩阵</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">012123</span><br><span class="line">121230</span><br><span class="line">123012</span><br><span class="line">212301</span><br><span class="line">230121</span><br><span class="line">301212</span><br></pre></td></tr></table></figure>

<p>考虑优化这个过程</p>
<p>发现暴力递推的时候，每一个串一定是同一个串的可能关系推出来的</p>
<p>比如第四行全是由第三行给出的可能的顺序推出来的，这样如果我们知道他是从那个串递推就可以 $O(n)$ 解决了</p>
<p>画个图感性理解一下就是按照权值排序跳 $id$ 就是原串的递推过程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, rk;</span><br><span class="line">&#125; a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i].val;</span><br><span class="line">        a[i].rk = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, [&amp;](<span class="keyword">const</span> Data &amp;A, <span class="keyword">const</span> Data &amp;B) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A.val == B.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> A.rk &lt; B.rk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A.val &lt; B.val;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">int</span> now = a[<span class="number">1</span>].rk;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[now].val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        now = a[now].rk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Asusetic eru quionours</span></span><br></pre></td></tr></table></figure>

<h3 id="T3-树"><a href="#T3-树" class="headerlink" title="T3 树"></a>T3 树</h3><p>原题 2020省选A卷 树</p>
<p>我还做过（然而是精妙的差分做法，考场上只会大力合并 Trie</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6e5</span> + <span class="number">10</span>, K = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeNode</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    EdgeNode *nxt;</span><br><span class="line">    <span class="built_in">EdgeNode</span>(EdgeNode *p) &#123;</span><br><span class="line">        nxt = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span> :</span> <span class="keyword">public</span> iterator&lt;input_iterator_tag, T&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ListIterator</span>(T *p) &#123;</span><br><span class="line">        _ptr = p;</span><br><span class="line">    &#125;</span><br><span class="line">    ListIterator &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ListIterator &amp;iter) &#123;</span><br><span class="line">        _ptr = iter._ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> ListIterator &amp;iter) &#123;</span><br><span class="line">        <span class="keyword">return</span> _ptr != iter._ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> ListIterator &amp;iter) &#123;</span><br><span class="line">        <span class="keyword">return</span> _ptr == iter._ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    ListIterator &amp;<span class="keyword">operator</span>++() &#123;</span><br><span class="line">        _ptr = _ptr-&gt;nxt;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListIterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        ListIterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">        _ptr             = _ptr-&gt;nxt;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() &#123;</span><br><span class="line">        <span class="keyword">return</span> *_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> ListIterator&lt;EdgeNode&gt; iterator;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    EdgeNode *head;</span><br><span class="line">    <span class="built_in">Edge</span>() &#123;</span><br><span class="line">        head = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        head    = <span class="keyword">new</span> <span class="built_in">EdgeNode</span>(head);</span><br><span class="line">        head-&gt;v = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Edge head[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    head[u].<span class="built_in">add</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Trie &#123;</span><br><span class="line"><span class="keyword">int</span> ch[N * K][<span class="number">2</span>], cnt[N * K], tot, dcnt[N][K];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> rt, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = rt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = (v &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        dcnt[x][i] += u;</span><br><span class="line">        <span class="keyword">if</span> (!ch[now][u])</span><br><span class="line">            ch[now][u] = ++tot;</span><br><span class="line">        now = ch[now][u];</span><br><span class="line">        cnt[now]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = rt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!now)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        dcnt[x][i] += cnt[ch[now][<span class="number">0</span>]];</span><br><span class="line">        dcnt[x][i] -= cnt[ch[now][<span class="number">1</span>]];</span><br><span class="line">        <span class="built_in">swap</span>(ch[now][<span class="number">1</span>], ch[now][<span class="number">0</span>]);</span><br><span class="line">        now = ch[now][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y)</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    cnt[x] += cnt[y];</span><br><span class="line">    ch[x][<span class="number">0</span>] = <span class="built_in">merge</span>(ch[x][<span class="number">0</span>], ch[y][<span class="number">0</span>]);</span><br><span class="line">    ch[x][<span class="number">1</span>] = <span class="built_in">merge</span>(ch[x][<span class="number">1</span>], ch[y][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace Trie</span></span><br><span class="line">ll v[N], rt[N], val[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Trie;</span><br><span class="line">    rt[u] = ++tot;</span><br><span class="line">    <span class="built_in">insert</span>(v[u], rt[u], u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : head[u]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = p.v;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        <span class="built_in">merge</span>(rt[u], rt[v]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; j++) &#123;</span><br><span class="line">            dcnt[u][j] += dcnt[v][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dcnt[u][i] &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            val[u] += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add1</span>(rt[u], u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="built_in">add</span>(x, i);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans += val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Trie</tag>
        <tag>SAM</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.05.23模拟赛</title>
    <url>/2021/05/24/2021-05-23%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>字符串场（存疑）</p>
<span id="more"></span>

<h2 id="2021-05-23-模拟赛"><a href="#2021-05-23-模拟赛" class="headerlink" title="2021.05.23 模拟赛"></a>2021.05.23 模拟赛</h2><h3 id="T1-序列的故事"><a href="#T1-序列的故事" class="headerlink" title="T1 序列的故事"></a>T1 序列的故事</h3><p>比较拉跨的Hash水题，人均切</p>
<p>原题同名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N     = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> ull Base1 = <span class="number">19260817</span>;</span><br><span class="line"><span class="keyword">int</span> n, prime[N], mindiv[N];</span><br><span class="line"><span class="keyword">int</span> pcnt;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> factor[N];</span><br><span class="line">ull pw[N], Hash[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            prime[++pcnt] = i;</span><br><span class="line">            mindiv[i]     = prime[pcnt];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt &amp;&amp; prime[j] * i &lt;= x; j++) &#123;</span><br><span class="line">            vis[prime[j] * i]    = <span class="number">1</span>;</span><br><span class="line">            mindiv[prime[j] * i] = prime[j];</span><br><span class="line">            <span class="keyword">if</span> (!(i % prime[j])) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ull <span class="title">getHash</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Hash[r] - Hash[l - <span class="number">1</span>] * pw[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getHash</span>(l, r - len) == <span class="built_in">getHash</span>(l + len, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pre</span>(N);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        pw[i]   = pw[i - <span class="number">1</span>] * Base1;</span><br><span class="line">        Hash[i] = Hash[i - <span class="number">1</span>] * Base1 + s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(l, r, <span class="number">1</span>)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> fcnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (len != <span class="number">1</span>) &#123;</span><br><span class="line">                factor[++fcnt] = mindiv[len];</span><br><span class="line">                len            = len / mindiv[len];</span><br><span class="line">            &#125;</span><br><span class="line">            len = r - l + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= fcnt; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(l, r, len / factor[i])) &#123;</span><br><span class="line">                    len /= factor[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T2-大-big"><a href="#T2-大-big" class="headerlink" title="T2 大(big)"></a>T2 大(big)</h3><p><a href="https://sjzezoj.com/problem/378">题面</a></p>
<p>其实明白了操作是啥就蛮好想的</p>
<p>实际上那个 $\lfloor\frac{2x}{2^n}\rfloor+(2x \bmod 2^n)$ 就是循环左移一位</p>
<p>对于异或这种按位的操作其实根本没啥影响</p>
<p>在 $i$ 后面操作就相当于把 $i$ 前面的所以数字全都循环左移一位</p>
<p>一共就 $m+1$ 种可能的异或值，全插进 Trie 里扫就行，如果有俩儿子说明不管怎么选都有一种方法把这一位变成 $0$ 反之不能</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="keyword">namespace</span> Trie &#123;</span><br><span class="line"><span class="keyword">int</span> ch[N * <span class="number">25</span>][<span class="number">2</span>], tot, rt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = rt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = (x &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ch[now][id]) &#123;</span><br><span class="line">            ch[now][id] = ++tot;</span><br><span class="line">        &#125;</span><br><span class="line">        now = ch[now][id];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace Trie</span></span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="function">ll <span class="title">lshift</span><span class="params">(ll s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((s &lt;&lt; <span class="number">1ll</span>) / (<span class="number">1ll</span> &lt;&lt; n) + (s &lt;&lt; <span class="number">1ll</span>) % (<span class="number">1ll</span> &lt;&lt; n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> dep, ll sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Trie;</span><br><span class="line">    <span class="keyword">if</span> (dep == n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; ans) &#123;</span><br><span class="line">            ans = sum;</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum == ans) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ch[now][<span class="number">0</span>] &amp;&amp; ch[now][<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(ch[now][<span class="number">0</span>], dep + <span class="number">1</span>, sum);</span><br><span class="line">        <span class="built_in">dfs</span>(ch[now][<span class="number">1</span>], dep + <span class="number">1</span>, sum);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch[now][<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(ch[now][<span class="number">0</span>], dep + <span class="number">1</span>, sum | (<span class="number">1ll</span> &lt;&lt; (n - dep - <span class="number">1</span>)));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch[now][<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(ch[now][<span class="number">1</span>], dep + <span class="number">1</span>, sum | (<span class="number">1ll</span> &lt;&lt; (n - dep - <span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll xors = <span class="number">0</span>, xorp = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">        xors ^= a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Trie::<span class="built_in">insert</span>(xors);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        xorp ^= <span class="built_in">lshift</span>(a[i]);</span><br><span class="line">        xors ^= a[i];</span><br><span class="line">        Trie::<span class="built_in">insert</span>(xorp ^ xors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n%d\n&quot;</span>, ans, cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T3-最长重复子串"><a href="#T3-最长重复子串" class="headerlink" title="T3 最长重复子串"></a>T3 最长重复子串</h3><p><a href="https://sjzezoj.com/problem/379">题面</a></p>
<p>$n^2$ 过 $10^5$ 绝了</p>
<p>考虑分治做法</p>
<p>对于 $S$ 的重复子串 $S_{l,r}$  $mid$ 为分治中点，当 $r \le mid$ 或 $l \ge mid$ 都可以直接分治处理</p>
<p>中间的合并这样考虑</p>
<p>如果这个重复子串长度为 $2k$</p>
<p>那 $S_{l,r}=AA=S_{l,l+k}S_{r-k,r}$</p>
<p>当 $l+k \le mid$  时</p>
<p>有 $S_{l,mid-k}=S_{l+k,mid}$ 且 $S_{mid-k,l+k}=S_{mid,r}$</p>
<p>即 $mid-k-l \le LCS(S_{mid-l},S_{mid})$</p>
<p>$l+2k-m\le LCP(S_{mid-k,n},S_{mid,n})$</p>
<p>整理的</p>
<p>$k\le LCP(S_{mid-k,n},S_{mid,n})+LCS(S_{mid-k},S_{mid})$</p>
<p>另一种情况 $l+k &gt; mid$</p>
<p>同理得 $k \le LCP(S_{mid,n},S_{mid+k,n})+LCS(S_{mid},S_{mid+k})$</p>
<p>枚举长度即可</p>
<p>至于 LCP or LCS 能求就行 exKMP或者SA均可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> len, ans;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SA</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> sa[N], rk[N], oldrk[N], cnt[N], id[N], px[N], height[N];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> oldrk[x] == oldrk[y] &amp;&amp; oldrk[x + w] == oldrk[y + w];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">127</span>, p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            rk[i] = s[i];</span><br><span class="line">            ++cnt[rk[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            sa[cnt[rk[i]]--] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>;; w *= <span class="number">2</span>, m = p) &#123;</span><br><span class="line">            p = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt; len - w; i--) &#123;</span><br><span class="line">                id[++p] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sa[i] &gt; w) &#123;</span><br><span class="line">                    id[++p] = sa[i] - w;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">                px[i] = rk[id[i]];</span><br><span class="line">                ++cnt[px[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">                cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">                sa[cnt[px[i]]--] = id[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(oldrk, rk, <span class="built_in"><span class="keyword">sizeof</span></span>(rk));</span><br><span class="line">            p = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">                rk[sa[i]] = <span class="built_in">cmp</span>(sa[i], sa[i - <span class="number">1</span>], w) ? p : ++p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p == len) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">                    sa[rk[i]] = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getHeight</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k)</span><br><span class="line">                --k;</span><br><span class="line">            <span class="keyword">int</span> j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (s[i + k] == s[j + k])</span><br><span class="line">                ++k;</span><br><span class="line">            height[rk[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> st[N][<span class="number">21</span>], lg[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        len = n;</span><br><span class="line">        <span class="built_in">build</span>(s);</span><br><span class="line">        <span class="built_in">getHeight</span>(s);</span><br><span class="line">        lg[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; ++i)</span><br><span class="line">            lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">            st[i][<span class="number">0</span>] = height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) &lt;= len; ++i) &#123;</span><br><span class="line">                st[i][j + <span class="number">1</span>] = std::<span class="built_in">min</span>(st[i][j], st[i + (<span class="number">1</span> &lt;&lt; j)][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = lg[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(st[l][t], st[r - (<span class="number">1</span> &lt;&lt; t) + <span class="number">1</span>][t]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lcp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == y)</span><br><span class="line">            <span class="keyword">return</span> len - x + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = rk[x], r = rk[y];</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">            <span class="built_in">swap</span>(l, r);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(l + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; S, revS;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.<span class="built_in">lcp</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> revS.<span class="built_in">lcp</span>(revS.len - x + <span class="number">1</span>, revS.len - y + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r || r - l + <span class="number">1</span> &lt;= ans * <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid - l + <span class="number">1</span>; i &gt; ans; --i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= <span class="built_in">lcs</span>(mid - i, mid) + <span class="built_in">lcp</span>(mid - i + <span class="number">1</span>, mid + <span class="number">1</span>))</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r - mid; i &gt; ans; --i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= <span class="built_in">lcs</span>(mid, mid + i) + <span class="built_in">lcp</span>(mid + <span class="number">1</span>, mid + i + <span class="number">1</span>))</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i);</span><br><span class="line">    <span class="built_in">solve</span>(l, mid);</span><br><span class="line">    <span class="built_in">solve</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    S.<span class="built_in">init</span>(s, len);</span><br><span class="line">    <span class="built_in">reverse</span>(s + <span class="number">1</span>, s + len + <span class="number">1</span>);</span><br><span class="line">    revS.<span class="built_in">init</span>(s, len);</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>, len);</span><br><span class="line">    cout &lt;&lt; ans * <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T4-卷积神经网络"><a href="#T4-卷积神经网络" class="headerlink" title="T4 卷积神经网络"></a>T4 卷积神经网络</h3><p><a href="https://sjzezoj.com/problem/380">题面</a> </p>
<p>肯定是得数不合法的方案，然后看到 $c$ 这么小必然得把状态压下来</p>
<p><del>然后不会了</del></p>
<p>先大力设 dp 式子 $dp[x][y][S][i][j]$ 表示 $(x,y)$ 轮廓线上的点能否匹配第一个模板串的末尾的状态 $S$ ，第一行匹配到 $i$ 第二行匹配到 $j$ 的方案数</p>
<p>考虑从 $(x,y) \rightarrow (x,y+1)$ 的转移</p>
<p>枚举这一位填啥，如果填对了那么对应的 $i/j$ 会加一，否则应该不断的跳 $border$ ，$S$ 仅需判断是否为 $c$ 即可</p>
<p>仅有当 $S$ 的 $j$ 位为 $1$ 且 $j=c$ 时不能转移，其他均可</p>
<p>上一行到下一行仅需把上一行的状态全加进去即可</p>
<p>前两维完全可以滚动掉</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>, M = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, c, q;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][(<span class="number">1</span> &lt;&lt; M)][<span class="number">7</span>][<span class="number">7</span>];</span><br><span class="line"><span class="keyword">char</span> c1[<span class="number">7</span>], c2[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">int</span> a1[<span class="number">7</span>], a2[<span class="number">7</span>], nxt1[<span class="number">7</span>], nxt2[<span class="number">7</span>], to1[<span class="number">7</span>][<span class="number">4</span>], to2[<span class="number">7</span>][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">(<span class="keyword">int</span> *s, <span class="keyword">int</span> *nxt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= c; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &amp;&amp; s[j + <span class="number">1</span>] != s[i]) &#123;</span><br><span class="line">            j = nxt[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[j + <span class="number">1</span>] == s[i]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        nxt[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> *s, <span class="keyword">int</span> *nxt, <span class="keyword">int</span> to[][<span class="number">4</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = i;</span><br><span class="line">            <span class="keyword">while</span> (k &amp;&amp; s[k + <span class="number">1</span>] != j) &#123;</span><br><span class="line">                k = nxt[k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[k + <span class="number">1</span>] == j) &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            to[i][j] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            res = res * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; c &gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> U      = <span class="number">1</span> &lt;&lt; (m - c + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> trans = [](<span class="keyword">char</span> c) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;W&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        cin &gt;&gt; c1 + <span class="number">1</span> &gt;&gt; c2 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; i++) &#123;</span><br><span class="line">            a1[i] = <span class="built_in">trans</span>(c1[i]);</span><br><span class="line">            a2[i] = <span class="built_in">trans</span>(c2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">KMP</span>(a1, nxt1);</span><br><span class="line">        <span class="built_in">KMP</span>(a2, nxt2);</span><br><span class="line">        <span class="built_in">pre</span>(a1, nxt1, to1);</span><br><span class="line">        <span class="built_in">pre</span>(a2, nxt2, to2);</span><br><span class="line">        <span class="built_in">memset</span>(dp[<span class="number">0</span>], <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp[<span class="number">0</span>]));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> now        = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(dp[now], <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp[now]));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; U; s++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; c; a++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; c; b++) &#123;</span><br><span class="line">                        dp[now][s][<span class="number">0</span>][<span class="number">0</span>] += dp[now ^ <span class="number">1</span>][s][a][b];</span><br><span class="line">                        dp[now][s][<span class="number">0</span>][<span class="number">0</span>] %= mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            now ^= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(dp[now], <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp[now]));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; U; s++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; c; a++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; c; b++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!dp[now ^ <span class="number">1</span>][s][a][b])</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt;= <span class="number">2</span>; p++) &#123;</span><br><span class="line">                                <span class="keyword">int</span> pa = to1[a][p];</span><br><span class="line">                                <span class="keyword">int</span> pb = to2[b][p];</span><br><span class="line">                                <span class="keyword">int</span> S  = s;</span><br><span class="line">                                <span class="keyword">if</span> (j &gt;= c) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((S &gt;&gt; (j - c)) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                                        S ^= <span class="number">1</span> &lt;&lt; (j - c);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (pa == c) &#123;</span><br><span class="line">                                    S ^= <span class="number">1</span> &lt;&lt; (j - c);</span><br><span class="line">                                    pa = nxt1[c];</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (pb == c) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((s &gt;&gt; (j - c)) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    pb = nxt2[c];</span><br><span class="line">                                &#125;</span><br><span class="line">                                dp[now][S][pa][pb] += dp[now ^ <span class="number">1</span>][s][a][b];</span><br><span class="line">                                dp[now][S][pa][pb] %= mod;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                now ^= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="built_in">qpow</span>(<span class="number">3</span>, n * m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; U; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; c; k++) &#123;</span><br><span class="line">                    ans = (ans - dp[now ^ <span class="number">1</span>][i][j][k] + mod) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours</span></span><br></pre></td></tr></table></figure>

<p><del>我知道这图超大，但我就是想试一下</del></p>
<p><img src="https://i.loli.net/2021/05/25/y2hpaLqbdVmwYXU.jpg" alt="Kal&#39;tsit.jpeg"></p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>KMP</tag>
        <tag>轮廓线DP</tag>
        <tag>Hash</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC008E Next or Nextnext</title>
    <url>/2021/05/21/AGC008E-Next-or-Nextnext/</url>
    <content><![CDATA[<p>AGC好题</p>
<span id="more"></span>

<p>因为我是从图论题单发现的所以就按图论思考了</p>
<p>先按套路 $i \rightarrow p_i$ 连边，会构成若干个环</p>
<p><img src="/upload/Case0.png" alt="Case0"></p>
<p>发现没啥能用的性质</p>
<p>然后 $a_i$ 的个很好的东西，因为 $p_i$ 要么是 $a_i$ 要么下一个是 $a_i$ 图上表示就类似</p>
<p><img src="/upload/Case1.png" alt="Case1"></p>
<p>如果每个 $p_i=a_i$ 都成立，那就是原图了</p>
<p>同样的每个 $p_{p_i}=a_i$ 都成立就是</p>
<p><img src="/upload/Case1.png" alt="Case1"></p>
<p>这里需要讨论一下，环长位偶数的话像上图会把原图拆成两个大小为一半的环</p>
<p>如果是奇数则</p>
<p><img src="/upload/Case3.1.png" alt="Case1"></p>
<p>拉平看一下</p>
<p><img src="/upload/Case3.2.png" alt="Case1"></p>
<p>可以发现这个结构和原图是一样的</p>
<p>最后如果既有 $p_i=a_i$ $p_{p_i}=a_i$ 就是</p>
<p><img src="/upload/Case4.1.png" alt="Case1"></p>
<p>拉直</p>
<p><img src="/upload/Case4.2.png" alt="Case1"></p>
<p>是一个内向基环树</p>
<p>现在我们拿到了变换完的 $i \rightarrow a_i$ 的图，求原图的方案数</p>
<p>环和基环树没啥关系也不能相互作用</p>
<p>所以分别处理</p>
<p>环的部分考虑dp</p>
<p> $dp_{s,k}$ 表示大小为 $s$ 的环考虑到第 $k$ 个，如果 $s$ 是奇数那么可以有一个和原图同构的图和原图，即 $dp_{s,k-1}+dp_{s,k-1}$</p>
<p>同时也可以向上合并成大环，最后乘起来</p>
<p>基环树的部分</p>
<p>基环树上的链肯定是得压到环里的，对着图手玩一会就能发现</p>
<p>这个链长度为 $l_1$ ，到下一个链长度为 $l_2$</p>
<p>如果 $l_2 &lt; l_1$ 必然塞不下</p>
<p>如果 $l_1=l_2$ 刚刚好一种方案</p>
<p>否则的话第一个点隔一个点链和直接连有两种方案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N  = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N], in[N], st[N], top;</span><br><span class="line"><span class="keyword">bool</span> inst[N], vis[N], cyc[N];</span><br><span class="line"><span class="keyword">int</span> len[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inst[x]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">                cyc[st[i]] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (st[i] == x) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x] = inst[x] = <span class="number">1</span>;</span><br><span class="line">    st[++top]        = x;</span><br><span class="line">    <span class="built_in">dfs</span>(a[x]);</span><br><span class="line">    inst[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line">ll ans = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>, fr = <span class="number">0</span>, ed = <span class="number">0</span>, frid;</span><br><span class="line">    <span class="keyword">while</span> (cyc[x]) &#123;</span><br><span class="line">        ++tot;</span><br><span class="line">        cyc[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (len[x]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!fr) &#123;</span><br><span class="line">                fr   = tot;</span><br><span class="line">                ed   = tot;</span><br><span class="line">                frid = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> pm = (len[x] &lt; tot - ed) + (len[x] &lt;= tot - ed);</span><br><span class="line">                ans    = <span class="number">1ll</span> * ans * pm % mod;</span><br><span class="line">                ed     = tot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        x = a[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!fr) &#123;</span><br><span class="line">        ++cnt[tot];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> kl = (len[frid] &lt; tot - ed + fr) + (len[frid] &lt;= tot - ed + fr);</span><br><span class="line">        ans    = <span class="number">1ll</span> * ans * kl % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        ++in[a[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (!in[i]) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((cyc[i] &amp;&amp; in[i] &gt; <span class="number">2</span>) || (!cyc[i] &amp;&amp; in[i] &gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        len[a[x]] = len[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!cyc[a[x]]) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(a[x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cyc[i]) &#123;</span><br><span class="line">            <span class="built_in">pre</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> ll num[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[i]) &#123;</span><br><span class="line">            num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt[i]; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    num[j] = (num[j - <span class="number">1</span>] + num[j - <span class="number">1</span>]) % mod;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    num[j] = num[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    num[j] =</span><br><span class="line">                        (<span class="number">1ll</span> * num[j] + <span class="number">1ll</span> * num[j - <span class="number">2</span>] * <span class="number">1ll</span> * (j - <span class="number">1ll</span>) %</span><br><span class="line">                                            mod * <span class="number">1ll</span> * i % mod) %</span><br><span class="line">                        mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="number">1ll</span> * ans * num[cnt[i]] % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>AtCoder</category>
        <category>题解</category>
        <category>AGC</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>思维</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-05-16模拟赛</title>
    <url>/2021/05/16/2021-05-16%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>咕咕咕</p>
<span id="more"></span>

<h2 id="2021-05-16-模拟赛"><a href="#2021-05-16-模拟赛" class="headerlink" title="2021.05.16 模拟赛"></a>2021.05.16 模拟赛</h2><h3 id="T1-LCS-Again"><a href="#T1-LCS-Again" class="headerlink" title="T1 LCS Again"></a>T1 LCS Again</h3><p>原题 CF578D</p>
<p>玩了很长时间玩出来了</p>
<p>不算很难搞的数数题</p>
<p>考虑如果是类似 $aaaaaa\dots$ 的串那么随便去一个位置填一个其他字符答案就是 $n(m-1)$</p>
<p>进一步的，如果是类似 $aaabbccc\dots$ 这样的因为相邻的两个同样的字符没有区别，所以每组相邻的相同字符就只有一个 $n(m-1)$ 的贡献</p>
<p>但是想 $aab$ 这样的串 $aa+b$ 和 $ab+a$ 是一样的，拓展一下考虑到 $ababab\dots$ 这样的串所有子串都会被算重一遍，所以统计这样的极长串减掉子串就好</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000005</span>;</span><br><span class="line">ll n, m, ans;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cin &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    s[<span class="number">0</span>]   = <span class="string">&quot;/QAQ&quot;</span>[<span class="number">0</span>];</span><br><span class="line">    ans    = <span class="number">1ll</span> * n * (m - <span class="number">1</span>);</span><br><span class="line">    ll len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            ans += n * (m - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">                len++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[i - <span class="number">2</span>]) &#123;</span><br><span class="line">                len++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans -= len * (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    len = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    len = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; len &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">1</span>)</span><br><span class="line">        ans -= <span class="number">1ll</span> * len * (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Asusetic eru quionours.</span></span><br></pre></td></tr></table></figure>

<h3 id="T2-赢家"><a href="#T2-赢家" class="headerlink" title="T2 赢家"></a>T2 赢家</h3><p><a href="https://sjzezoj.com/problem/355">赢家</a></p>
<p>纯暴力 45pts 血赚</p>
<p>反向统计不合法的方案</p>
<p>不合法的方案一定有从 $1$ 能到的点集 $S$ ，和从 $2$ 能到的点集 $T$</p>
<p>有 $S \cap T =\phi$</p>
<p>显然 $S$ 与 $T$ 直接不能有边</p>
<p>同时对于剩下的点 $P={x\in V|x\notin S \ \mathrm{and} \ x \notin T}$</p>
<p>一定是从 $P$ 向 $S,T$ 连边的，这里的方案是固定的</p>
<p>所以统计 $S$ 的方案即可</p>
<p>对于 $S$ 的方案同样反向统计</p>
<p>总方案是 $2^{|E(S)|}$</p>
<p>不合法的方案就是 $S$ 的子集的方案数乘上两个点集中间边的方案数</p>
<p>即 $dp_S=2^{|E(s)|}-\sum\limits_{t \in S} 2^{E(S-t)}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">16</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> G[N][N];</span><br><span class="line"><span class="keyword">int</span> p2[N * N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll dp[(<span class="number">1</span> &lt;&lt; N)][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[(<span class="number">1</span> &lt;&lt; N)];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        u--;</span><br><span class="line">        v--;</span><br><span class="line">        G[u][v] = G[v][u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * n; i++) &#123;</span><br><span class="line">        p2[i] = p2[i - <span class="number">1</span>] * <span class="number">2</span> % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); s++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((s &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                cnt[s] = cnt[s ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((s &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                        cnt[s] += G[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); s++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            dp[s][<span class="number">0</span>] = p2[cnt[s]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = (s - <span class="number">1</span>) &amp; s; t; t = s &amp; (t - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[s][<span class="number">0</span>] = (dp[s][<span class="number">0</span>] - dp[t][<span class="number">0</span>] * p2[cnt[s ^ t]]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s &amp; <span class="number">2</span>) &#123;</span><br><span class="line">            dp[s][<span class="number">1</span>] = p2[cnt[s]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = (s - <span class="number">1</span>) &amp; s; t; t = s &amp; (t - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[s][<span class="number">1</span>] = (dp[s][<span class="number">1</span>] - dp[t][<span class="number">1</span>] * p2[cnt[s ^ t]]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = p2[m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); s++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[s][<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = s + <span class="number">1</span>; t &lt; (<span class="number">1</span> &lt;&lt; n); t = (t + <span class="number">1</span>) | s) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[s ^ t][<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> z = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span> - t;</span><br><span class="line">                    <span class="keyword">if</span> (cnt[s ^ z] + cnt[s ^ z ^ t] - cnt[z] == m) &#123;</span><br><span class="line">                        ans =</span><br><span class="line">                            (ans -</span><br><span class="line">                             dp[s][<span class="number">0</span>] * dp[s ^ t][<span class="number">1</span>] % mod * p2[cnt[z]] % mod +</span><br><span class="line">                             mod) %</span><br><span class="line">                            mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (ans + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Asusetic  eru quionours.</span></span><br></pre></td></tr></table></figure>

<h3 id="T3-障碍赛车"><a href="#T3-障碍赛车" class="headerlink" title="T3 障碍赛车"></a>T3 障碍赛车</h3><p><a href="https://sjzezoj.com/problem/356">障碍赛车</a></p>
<p>题面太长没看</p>
<p>发现只要障碍确定那么下一层的时间很好推</p>
<p>考虑记录 $dp_{i,S}$ 表示第 $i$ 层距离分别为 $S$ 的答案，暴力转移复杂度挂掉</p>
<p>思考一下距离记下来这么多没必要，因为左右两个点距离只会差一，差分一下</p>
<p>为了避免 $-1$ 以中间点为界，左边的 $0$ 表示比右边点多一， $1$ 表示少一，反之同理</p>
<p>口胡一下会发现不可能有一样的距离</p>
<p>这样状态为 $dp[i][t][S]$ 表示 $i$ 层，终点距离 $t$ 差分为 $S$ 的状态，大力转移即可，需要预处理各个状态的距离和差分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, k, t, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigNumber</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">18</span>], len;</span><br><span class="line">    <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">zero</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> len == <span class="number">0</span> &amp;&amp; a[<span class="number">0</span>] == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> BigNumber &amp;x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span> &amp;&amp; a[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            *<span class="keyword">this</span> = x;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; x.len)</span><br><span class="line">            len = x.len;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">            a[i] += x.a[i];</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt;= <span class="number">1000000000</span>)</span><br><span class="line">                ++a[i + <span class="number">1</span>], a[i] -= <span class="number">1000000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[len + <span class="number">1</span>])</span><br><span class="line">            ++len;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[len]);</span><br><span class="line">        <span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%09d&quot;</span>, a[i]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; dp[<span class="number">108</span>][<span class="number">501</span>][<span class="number">18</span>], ans;</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">110</span>], dis[<span class="number">18</span>][<span class="number">36</span>], d0[<span class="number">5</span>], d1[<span class="number">5</span>], state[<span class="number">18</span>][<span class="number">36</span>];</span><br><span class="line"><span class="keyword">int</span> lim, U;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">        d0[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            d0[<span class="number">0</span>] = (i &amp; <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            d0[<span class="number">2</span>] = (i &amp; <span class="number">2</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">7</span>; ++x) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++) &#123;</span><br><span class="line">                    d1[j] = (x &amp; (<span class="number">1</span> &lt;&lt; j)) ? <span class="number">9</span> : d0[j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span>; j++) &#123;</span><br><span class="line">                    d1[j] = <span class="built_in">min</span>(d1[j], d1[j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    d1[j] = <span class="built_in">min</span>(d1[j], d1[j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                dis[i][x]   = d1[<span class="number">1</span>];</span><br><span class="line">                state[i][x] = (d1[<span class="number">0</span>] &gt; d1[<span class="number">1</span>] ? <span class="number">1</span> : <span class="number">0</span>) | (d1[<span class="number">2</span>] &gt; d1[<span class="number">1</span>] ? <span class="number">2</span> : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        d0[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j, x &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">                d0[j] = (x &amp; <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span>; j &lt; <span class="number">5</span>; ++j, x &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">                d0[j] = (x &amp; <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            d0[<span class="number">0</span>] += d0[<span class="number">1</span>], d0[<span class="number">4</span>] += d0[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">31</span>; ++s) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">4</span>; ++j)</span><br><span class="line">                    d1[j] = (s &amp; (<span class="number">1</span> &lt;&lt; j)) ? <span class="number">9</span> : d0[j] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">                    d1[j + <span class="number">1</span>] = <span class="built_in">min</span>(d1[j + <span class="number">1</span>], d1[j] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">4</span>; j; --j)</span><br><span class="line">                    d1[j - <span class="number">1</span>] = <span class="built_in">min</span>(d1[j - <span class="number">1</span>], d1[j] + <span class="number">1</span>);</span><br><span class="line">                dis[i][s] = d1[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">int</span> S     = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j)</span><br><span class="line">                    <span class="keyword">if</span> (d1[j] &gt; d1[j + <span class="number">1</span>])</span><br><span class="line">                        S |= <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">                    <span class="keyword">if</span> (d1[j + <span class="number">1</span>] &gt; d1[j])</span><br><span class="line">                        S |= <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">                state[i][s] = S;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; t &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        p[x] |= (<span class="number">1</span> &lt;&lt; (y + k));</span><br><span class="line">    &#125;</span><br><span class="line">    lim = (<span class="number">1</span> &lt;&lt; (<span class="number">2</span> * k)) - <span class="number">1</span>;</span><br><span class="line">    U   = lim * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pre</span>();</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][lim][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= t; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= lim; s++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j][s].<span class="built_in">zero</span>())</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> X = p[i]; X &lt; U; X = (X + <span class="number">1</span>) | p[i]) &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][<span class="built_in">min</span>(j + dis[s][X], t)][state[s][X]] +=</span><br><span class="line">                        dp[i][j][s];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= lim; ++s)</span><br><span class="line">        ans += dp[n][t][s];</span><br><span class="line">    ans.<span class="built_in">pr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="T4-Haiku"><a href="#T4-Haiku" class="headerlink" title="T4 Haiku"></a>T4 Haiku</h3><p>原题 ARC058E</p>
<p>考场上硬计数整数拆分没数出来，吃饭突然想到该状压搞</p>
<p>思考一下发现直接统计方案很难保证不重</p>
<p>所以统计不合法的</p>
<p>数据范围就很状压，考虑 $x+y+z \le 17$ 所以得用 $2^{x+y+z}$ 个状态</p>
<p>考虑直接把数字放在对应的位置上，比如</p>
<p> $4 \rightarrow 1000$ $3 \rightarrow 100$</p>
<p>那么符合条件的就是 $x+y+z-1$ $y+z-1$ $z-1$ 位都是 $1$ </p>
<p>$dp$ 统计不合法的 $dp_{i,S}$ 就是前 $i$ 个数字状态是 $S$ 的方案，只要不合法就转移就可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">さびしさや</span></span><br><span class="line"><span class="comment">一尺消えて</span></span><br><span class="line"><span class="comment">ゆくほたる</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            res = res * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">ll n, x, y, z;</span><br><span class="line">ll S;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function">ll <span class="title">bitadd</span><span class="params">(ll x, ll i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x &lt;&lt; i) | (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))) &amp; (S - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ll mask;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((state &amp; mask) == mask);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">42</span>][(<span class="number">1</span> &lt;&lt; <span class="number">18</span>)];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    ans  = <span class="built_in">qpow</span>(<span class="number">10</span>, n);</span><br><span class="line">    mask = (<span class="number">1</span> &lt;&lt; (x + y + z - <span class="number">1</span>));</span><br><span class="line">    mask |= (<span class="number">1</span> &lt;&lt; (y + z - <span class="number">1</span>));</span><br><span class="line">    mask |= (<span class="number">1</span> &lt;&lt; (z - <span class="number">1</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    S        = (<span class="number">1</span> &lt;&lt; (x + y + z));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; S; s++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">10</span>; k++) &#123;</span><br><span class="line">                ll u = <span class="built_in">bitadd</span>(s, k);</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">check</span>(u)) &#123;</span><br><span class="line">                    dp[i][u] = (dp[i][u] + dp[i - <span class="number">1</span>][s]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; S; s++) &#123;</span><br><span class="line">        ans = (ans - dp[n][s] + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC078E Awkward Response</title>
    <url>/2021/05/14/ARC078E-Awkward-Response/</url>
    <content><![CDATA[<p>好耶，是交互</p>
<span id="more"></span>

<p>仔细思考一下发现可以先得把位数确定下来，字典序就可以完成</p>
<p>从 $1$ 开始往后加 $0$ 返回 $N$ 了说明位数超了，因为 $10000\dots$ 一直是字典序最小的，如果字典序和数字顺序不匹配说明字典序小了而数字顺序大了</p>
<p>位数如果确定了那么就可以二分了</p>
<p>考虑如果在中间值后面加个 $0$ ，那么字典序这时候就是数字顺序</p>
<p>而实际的 $mid\times10$ 数字顺序肯定是大于，就可以找到数字的大小关系了</p>
<p>坑：如果这个数字真的是 $1000\dots$ 还需要特判一下的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">5</span>];</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">return</span> (s[<span class="number">0</span>] == <span class="string">&#x27;Y&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">query</span>(<span class="number">1000000000</span>)) &#123;</span><br><span class="line">        x = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">query</span>(x - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">output</span>(x);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">query</span>(x)) &#123;</span><br><span class="line">        x *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">    ll l = x, r = x * <span class="number">10</span> - <span class="number">1</span>, ans;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        ll mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">query</span>(mid * <span class="number">10</span>)) &#123;</span><br><span class="line">            r   = mid - <span class="number">1</span>;</span><br><span class="line">            ans = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">output</span>(ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AtCoder</category>
        <category>题解</category>
        <category>ARC</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC089E GraphXY</title>
    <url>/2021/05/13/ARC089E-GraphXY/</url>
    <content><![CDATA[<p>构造大失败</p>
<span id="more"></span>

<p>直接说正解</p>
<p>考虑 $S,T$  路径里有 $i$ 个 $x$ ，$j$ 个 $y$ 其余边最小值为 $f_{i,j}$ </p>
<p>则 $d_{x,y}\ge ix+jy+f_{i,j} \Rightarrow d_{x,y}=\min (ix+jy+f_{i,j})j$</p>
<p>移项得到 $f_{i,j}\le d_{x,y}-ix-jy \Rightarrow f_{i,j}=\max(d_{x,y}-ix-y)$</p>
<p>构造从 $S$ 开始的一条链全是 $x$ ，到 $T$ 的链全是 $y$ </p>
<p>然后在第 $i$ 个 $x$ 与 $j$ 个 $y$ 间连边，暴力求出 $f_{i,j}$</p>
<p>最后检查一遍如果不符合就是无解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> A, B;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= B; j++) &#123;</span><br><span class="line">            cin &gt;&gt; d[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">100</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= A; x++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= B; y++) &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i][j], d[x][y] - i * x - j * y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= A; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= B; y++) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">100</span>; j++) &#123;</span><br><span class="line">                    now = <span class="built_in">min</span>(now, f[i][j] + i * x + j * y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (now != d[x][y]) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Impossible&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Possible&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;202 10401&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; X&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">102</span>; i &lt;= <span class="number">201</span>;i++)&#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; Y&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">100</span>;j++)&#123;</span><br><span class="line">            cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">202</span> - j &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; f[i][j] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1 202&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>AtCoder</category>
        <category>题解</category>
        <category>ARC</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC098D Donation</title>
    <url>/2021/05/12/ARC098D-Donation/</url>
    <content><![CDATA[<p>ARC F题的力量</p>
<span id="more"></span>

<p>显然一个点如果支付了费用就不会再访问了，因为考虑留下的费用越多越好，如果之后还会访问那不如最后支付费用</p>
<p>我们假设当前钱是 $x$ 先选 $i$ 点支付然后去 $j$ 和先去 $j$ 再去 $i$ 有两种条件</p>
<p>即 $x\ge a_i+b_j$ 与 $x \ge a_j+b_i$</p>
<p>要求最小则当且仅当 $a_i+b_j \le a_j+b_i \Rightarrow a_i-b_i \le a_j-b_j$ 才选 $i$</p>
<p>记 $c_i=\max(a_i-b_i,0)$</p>
<p>对于一个点 $i$ 来说它的剩余钱数至少为 $c_i$</p>
<p><del>很自然的想到排序按顺序做</del> </p>
<p>但是这样是忽略的图的限制的</p>
<p>那么我们继续考虑，选一个点之后剩下了几个连通块，先把几个连通块支付完再支付这个点然后是另一个联通块</p>
<p>按上面的条件仅需选择 $c_i$ 最大的点</p>
<p>这样一直选下去会构成一个树形结构，并且有 $c_i \le c_{fa_i}$</p>
<p>这样就可以排序然后并查集求出树了</p>
<p>之后在树上dp，记 $dp_i$ 为 $i$ 与它的子树的代价</p>
<p>那么 $dp_i=\min\limits_{v\in son(i)}(\sum\limits_{t\in subtree(i)}b_t-\sum\limits_{t\in subtree(v)}b_t+\max(dp_v,c+v))$</p>
<p>叶子当然是 $\max(a_i,b_i)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x] == x ? x : f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x    = <span class="built_in">find</span>(x);</span><br><span class="line">    y    = <span class="built_in">find</span>(y);</span><br><span class="line">    f[x] = y;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; Tr[N], G[N];</span><br><span class="line">ll dp[N], s[N];</span><br><span class="line"><span class="keyword">int</span> c[N], b[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    s[x] = b[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : Tr[x]) &#123;</span><br><span class="line">        <span class="built_in">pre</span>(v);</span><br><span class="line">        s[x] += s[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Tr[x].<span class="built_in">size</span>())</span><br><span class="line">        dp[x] = b[x] + c[x];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dp[x] = <span class="number">2e19</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : Tr[x]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        dp[x] = <span class="built_in">min</span>(dp[x], s[x] - s[v] + <span class="built_in">max</span>((ll)c[x], dp[v]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;A, <span class="keyword">const</span> <span class="keyword">int</span> &amp;B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c[A] &lt; c[B];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, p[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; c[i] &gt;&gt; b[i];</span><br><span class="line">        f[i] = i;</span><br><span class="line">        c[i] = <span class="built_in">max</span>(c[i] - b[i], <span class="number">0</span>);</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= n; t++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = p[t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[v]) &#123;</span><br><span class="line">                v = <span class="built_in">find</span>(v);</span><br><span class="line">                u = <span class="built_in">find</span>(u);</span><br><span class="line">                <span class="keyword">if</span> (u != v) &#123;</span><br><span class="line">                    <span class="built_in">merge</span>(v, u);</span><br><span class="line">                    Tr[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pre</span>(p[n]);</span><br><span class="line">    <span class="built_in">dfs</span>(p[n]);</span><br><span class="line">    cout &lt;&lt; dp[p[n]];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AtCoder</category>
        <category>题解</category>
        <category>ARC</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC071F Infinite Sequence</title>
    <url>/2021/05/11/ARC071F-Infinite-Sequence/</url>
    <content><![CDATA[<p>略水的F题</p>
<span id="more"></span>

<p>考虑如果有两个相邻的数字都不是 $1$ 那么就无限套娃下去了，即 $abbb\dots$</p>
<p>从这个方向下手设 $dp_i $ 是 $[i,n]$ 填完的方案数</p>
<p>那当 $i$ 填 $1$ 就是 $dp_i+=dp_{i+1}$</p>
<p>如果是无限套娃那这两个位从 $[2,n]$ 里随便填 $dp_i+=(n-1)^2$</p>
<p>当 $i$ 填非 $1$ 但是 $i+1$ 填 $1$ 就是 $a\underbrace{111\dots}_ablabla$</p>
<p>所以对于每一个选择 $x$ 就是 $dp_{i}+=dp_{i+x+1}$</p>
<p>初始值 $dp_n=n,dp_{n-1}=n^2$</p>
<p>然后后缀和优化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll dp[N];</span><br><span class="line">ll sum;</span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    dp[n]     = n;</span><br><span class="line">    dp[n - <span class="number">1</span>] = (n * n) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        sum += dp[i + <span class="number">3</span>];</span><br><span class="line">        sum %= mod;</span><br><span class="line">        dp[i] = dp[i + <span class="number">1</span>];</span><br><span class="line">        dp[i] += (n - <span class="number">1</span>) * (n - <span class="number">1</span>) % mod;</span><br><span class="line">        dp[i] %= mod;</span><br><span class="line">        dp[i] += sum;</span><br><span class="line">        dp[i] %= mod;</span><br><span class="line">        dp[i] += i + <span class="number">1</span> % mod;</span><br><span class="line">        dp[i] %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">1</span>] % mod;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AtCoder</category>
        <category>题解</category>
        <category>ARC</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC082F Sandglass</title>
    <url>/2021/05/11/ARC082F-Sandglass/</url>
    <content><![CDATA[<p>很妙的分析</p>
<span id="more"></span>

<p>如果以时间做 $x$ 轴，$A$ 中沙子做 $y$ 轴，那么当初始值 $a$ 确定的时候图象是一些斜率为 $1,-1$ 的斜线和 $y=0,y=X$ 的直线拼起来的分段函数</p>
<p>同时当且仅当在 $t=r_i$ 处斜率才会改变，再次之前如果碰到 $X$ 或 $0$ 就会变成直线</p>
<p><img src="/upload/ARC082F.png" alt="ARC082F"></p>
<p>设初始值为 $i$  的函数是 $f_i(t)$</p>
<p>那么显然有 $\forall t,f_i(t) \le f_{i+1}(t)$</p>
<p>我们考虑对于一个询问如果它的图像 $f_{a_i}(t)$ 在某一时刻触碰到了 $f_0$ 或 $f_X$  那么它之后就和他完全一致了</p>
<p>如果没有触碰过，那直线必然没碰到过 $0$ 或 $X$，因为他们斜率一样，所以只有当 $f_{0/X}$ 是横线而 $f_{a_i}$ 不是的时候才会碰撞</p>
<p>那这一部分就是对 $f_{0/X}$ 的平移而已，直接加上平移量即可</p>
<p>重点就是怎么判断碰到</p>
<p>记录当前时刻 $t_i$ 的 $f_0(t_i)$ 和 $f_X(t_i)$ </p>
<p>先假设没触碰过，算出来答案是 $ans$</p>
<p>若 $ans&gt;f_{0}(t_i)$ 或者 $ans&lt;f_{X}(t_i)$ 那么就是触碰过对应的值</p>
<p>否则就是没触碰过（建议配合图食用）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> x, n;</span><br><span class="line"><span class="keyword">int</span> r[N];</span><br><span class="line"><span class="keyword">int</span> cur, down, k = <span class="number">-1</span>, up, sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    up = x;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> t, a;</span><br><span class="line">        cin &gt;&gt; t &gt;&gt; a;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; n &amp;&amp; r[cur + <span class="number">1</span>] &lt;= t) &#123;</span><br><span class="line">            down = <span class="built_in">min</span>(x, <span class="built_in">max</span>(<span class="number">0</span>, down + k * (r[cur + <span class="number">1</span>] - r[cur])));</span><br><span class="line">            up   = <span class="built_in">min</span>(x, <span class="built_in">max</span>(<span class="number">0</span>, up + k * (r[cur + <span class="number">1</span>] - r[cur])));</span><br><span class="line">            sum  = sum + k * (r[cur + <span class="number">1</span>] - r[cur]);</span><br><span class="line">            k    = -k;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> downnow = <span class="built_in">min</span>(x, <span class="built_in">max</span>(<span class="number">0</span>, down + k * (t - r[cur])));</span><br><span class="line">        <span class="keyword">int</span> upnow   = <span class="built_in">min</span>(x, <span class="built_in">max</span>(<span class="number">0</span>, up + k * (t - r[cur])));</span><br><span class="line">        <span class="keyword">int</span> sumnow  = sum + k * (t - r[cur]);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">min</span>(upnow, <span class="built_in">max</span>(downnow, sumnow + a)) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AtCoder</category>
        <category>题解</category>
        <category>ARC</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC018E Sightseeing</title>
    <url>/2021/05/10/AGC018E-Sightseeing/</url>
    <content><![CDATA[<p>神仙题</p>
<span id="more"></span>

<p>考虑点$(x_1,y_1)$和$(x_2,y_2)$的路径条数是$\large\binom{x_2-x_1+y_2-y_1}{x_2-x_1}$</p>
<p><del>然后就可以考虑$O(n^6)$枚举了</del></p>
<p>如果记$C(x_1,y_1,x_2,y_2)$是从$(x_1,y_1)$到$(x_2,y_2)$的路径条数</p>
<p>$\sum\limits_{i=a}^b\sum\limits_{j=c}^d C(x_1,y_1,i,j)$就是点$(x_1,y_1)$到矩形$[a,b,c,d]$的路径条数</p>
<p> 那么一个点到一个矩形按照二位前缀和差分一下有$C(x,y,c+1,d+1)-C(x,y,a,d+1)-C(x,y,c+1,b)+C(x,y,a,b)$</p>
<p>如果我们确定了出发点和终止点的位置，对于经过中转点的路径</p>
<p>枚举中转矩形的进入/离开点，发现对于进入/离开点对的路径长度$l$来说，其上每一个点都可以作为中转点，所以枚举进入/离开点的复杂度是$O(n^2)$</p>
<p>$l=x_2-x_1+y_2-y_1=x_2+y_2-(x_1+y_1)$所以可以分离作为进入/离开点的贡献</p>
<p>也即是进入点具有$-1$的系数，离开点具有$1$的系数</p>
<p>最后需要乘上起点到枚举点和枚举点到终点的方案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6;</span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line"><span class="keyword">int</span> f;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FirstVal&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(FirstVal &amp;v)</span> </span>&#123;</span><br><span class="line">    v               = <span class="number">0</span>;</span><br><span class="line">    f               = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            f = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); v = v * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>())</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FirstVal, <span class="keyword">typename</span>... RestVal&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(FirstVal &amp;fst, RestVal &amp;... s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(fst);</span><br><span class="line">    <span class="built_in">read</span>(s...);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace IO</span></span><br><span class="line"><span class="keyword">using</span> IO::read;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N         = <span class="number">2e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll fac[N + <span class="number">2</span>], invfac[N + <span class="number">2</span>];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            res = res * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * fac[<span class="built_in">abs</span>(a - c) + <span class="built_in">abs</span>(b - d)] * invfac[<span class="built_in">abs</span>(a - c)] % mod *</span><br><span class="line">           invfac[<span class="built_in">abs</span>(b - d)] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * fac[n] * invfac[m] % mod * invfac[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x1, ll y1, ll sign1, ll x2, ll y2, ll sign2, ll x3, ll x4,</span></span></span><br><span class="line"><span class="function"><span class="params">         ll y3, ll y4)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll x = x3; x &lt;= x4; x++) &#123;</span><br><span class="line">        res = (res + <span class="number">1ll</span> * (x + y4 + <span class="number">1</span>) * <span class="built_in">C</span>(x - x1 + y4 - y1, y4 - y1) % mod *</span><br><span class="line">                         <span class="built_in">C</span>(x2 - x + y2 - y4 - <span class="number">1</span>, y2 - y4 - <span class="number">1</span>) % mod);</span><br><span class="line">        res = (res + mod -</span><br><span class="line">               <span class="number">1ll</span> * (x + y3) * <span class="built_in">C</span>(x - x1 + y3 - y1 - <span class="number">1</span>, y3 - y1 - <span class="number">1</span>) % mod *</span><br><span class="line">                   <span class="built_in">C</span>(x2 - x + y2 - y3, y2 - y3) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll y = y3; y &lt;= y4; y++) &#123;</span><br><span class="line">        res = (res + <span class="number">1ll</span> * (y + x4 + <span class="number">1</span>) * <span class="built_in">C</span>(y - y1 + x4 - x1, x4 - x1) % mod *</span><br><span class="line">                         <span class="built_in">C</span>(y2 - y + x2 - x4 - <span class="number">1</span>, x2 - x4 - <span class="number">1</span>) % mod);</span><br><span class="line">        res = (res + mod -</span><br><span class="line">               <span class="number">1ll</span> * (y + x3) * <span class="built_in">C</span>(y - y1 + x3 - x1 - <span class="number">1</span>, x3 - x1 - <span class="number">1</span>) % mod *</span><br><span class="line">                   <span class="built_in">C</span>(y2 - y + x2 - x3, x2 - x3) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    res %= mod;</span><br><span class="line">    <span class="keyword">return</span> res * sign1 * sign2 % mod;</span><br><span class="line">&#125;</span><br><span class="line">ll ans;</span><br><span class="line">ll f[<span class="number">5</span>][<span class="number">5</span>], g[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = x1 - <span class="number">1</span>, f[<span class="number">0</span>][<span class="number">1</span>] = y1 - <span class="number">1</span>, f[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = x2, f[<span class="number">1</span>][<span class="number">1</span>] = y1 - <span class="number">1</span>, f[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">-1</span>;</span><br><span class="line">    f[<span class="number">2</span>][<span class="number">0</span>] = x1 - <span class="number">1</span>, f[<span class="number">2</span>][<span class="number">1</span>] = y2, f[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">-1</span>;</span><br><span class="line">    f[<span class="number">3</span>][<span class="number">0</span>] = x2, f[<span class="number">3</span>][<span class="number">1</span>] = y2, f[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    g[<span class="number">0</span>][<span class="number">0</span>] = x5, g[<span class="number">0</span>][<span class="number">1</span>] = y5, g[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    g[<span class="number">1</span>][<span class="number">0</span>] = x6 + <span class="number">1</span>, g[<span class="number">1</span>][<span class="number">1</span>] = y5, g[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">-1</span>;</span><br><span class="line">    g[<span class="number">2</span>][<span class="number">0</span>] = x5, g[<span class="number">2</span>][<span class="number">1</span>] = y6 + <span class="number">1</span>, g[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">-1</span>;</span><br><span class="line">    g[<span class="number">3</span>][<span class="number">0</span>] = x6 + <span class="number">1</span>, g[<span class="number">3</span>][<span class="number">1</span>] = y6 + <span class="number">1</span>, g[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    fac[<span class="number">0</span>] = fac[<span class="number">1</span>] = invfac[<span class="number">0</span>] = invfac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    invfac[N] = <span class="built_in">qpow</span>(fac[N], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">        invfac[i] = <span class="number">1ll</span> * invfac[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            ans += <span class="built_in">solve</span>(f[i][<span class="number">0</span>], f[i][<span class="number">1</span>], f[i][<span class="number">2</span>], g[j][<span class="number">0</span>], g[j][<span class="number">1</span>], g[j][<span class="number">2</span>],</span><br><span class="line">                         x3, x4, y3, y4);</span><br><span class="line">            ans %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (ans + mod) % mod;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AtCoder</category>
        <category>题解</category>
        <category>AGC</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>组合计数</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC085F NRE</title>
    <url>/2021/05/10/ARC085F-NRE/</url>
    <content><![CDATA[<p><del>我想不出来但我大受震撼</del></p>
<span id="more"></span>

<p>要求 $\sum[a_i\neq b_i]=\sum[a_i=0][b_i=1]+\sum[a_i=1][b_i=0]$</p>
<p>看起来这个式子就很对称，但是鼓捣了半天没法做</p>
<p>看了下题解豁然开朗</p>
<p>变成 $\sum[a_i=0][b_i=1]+\sum[b_i=0]-\sum[a_i=0][b_i=0]$</p>
<p>第二项是常量，剩下的项与 $a_i=1$ 无关</p>
<p>设 $dp_{i,j}$ 表示前 $i$ 个数字确定，最后一个 $1$ 在 $j$ 的最小值</p>
<p>那么对于 $[l,r]$ 操作来说，$dp_{l,r}=\min\limits_{k\le r}{dp_{i-1,k}}$</p>
<p>其他的继承自 $dp_l$ 特别的对于 $j&lt;i$ 的是 $dp_{i,j}=\min\{dp_{i,j},dp_{i-1,j}+2b_i-1\}$</p>
<p>($2b_i-1$ 相当于 <code>b[i]?1:-1</code>)</p>
<p>容易发现其实后边的 $j$ 没必要记录</p>
<p>单点修改区间 $\min$ 线段树优化即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200005</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; pos[N];</span><br><span class="line"><span class="keyword">int</span> b[N], sum[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">namespace</span> SegmentTree &#123;</span><br><span class="line"><span class="keyword">int</span> val[N * <span class="number">4</span>], tag[N * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        val[x] = <span class="built_in">min</span>(val[x], v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) &#123;</span><br><span class="line">        <span class="built_in">update</span>(x * <span class="number">2</span>, l, mid, pos, v);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">update</span>(x * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, pos, v);</span><br><span class="line">    &#125;</span><br><span class="line">    val[x] = <span class="built_in">min</span>(val[x * <span class="number">2</span>], val[x * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">return</span> val[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid) &#123;</span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">query</span>(x * <span class="number">2</span>, l, mid, L, R));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (R &gt; mid) &#123;</span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">query</span>(x * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, L, R));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    val[x] = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(x * <span class="number">2</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(x * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace SegmentTree</span></span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> SegmentTree;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + (b[i] == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        pos[l].<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> r : pos[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = dp[i - <span class="number">1</span>];</span><br><span class="line">            p     = <span class="built_in">min</span>(p, <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, i - <span class="number">1</span>, r));</span><br><span class="line">            <span class="keyword">if</span> (p &lt; dp[r]) &#123;</span><br><span class="line">                dp[r] = p;</span><br><span class="line">                <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, r, dp[r]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = <span class="built_in">min</span>(dp[i], dp[i - <span class="number">1</span>] + <span class="number">2</span> * b[i] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n] + sum[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AtCoder</category>
        <category>题解</category>
        <category>ARC</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>线段树优化DP</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC093F Dark Horse</title>
    <url>/2021/05/10/ARC093F-Dark-Horse/</url>
    <content><![CDATA[<p>ARC093F</p>
<span id="more"></span>

<p>考虑$1$放哪都成，不如钦定在一号点，最后答案乘$2^n$即可</p>
<p>剩下的需要保证区间$[2^{k-1}+1,2^k]$内的最小数字都不是$A_i$中的数字</p>
<p>都不是是个很麻烦的限制，考虑反演设$f_i$是恰好有$i$个区间$A$中的元素是最小值，$g_i$是至少有$i$个区间是</p>
<p>易见$g_i=\sum\limits_{j=i}^n\binom{j}{i}f_j \Leftrightarrow f_i=\sum\limits_{j=i}^n(-1)^{j-i}\binom{i}{j}g_i$</p>
<p>$g_i$可以状压 dp，具体来说，设$dp_{i,j}$表示现在考虑到$A_i$并且区间的状态为$j$的情况，其中$j$每一位二进制的$1$代表第$k$个区间填完了</p>
<p>因为要把一个$A_i$放在某一个区间中并且保证他最小，需要加入$2^k-1$个比他大的元素，从大到小排序，以防填数的时候把大的$A_i$填进去了</p>
<p>如果当前的$A_i$不作为最小值，那么$dp_{i,j}=dp_{i,j}+dp_{i-1,j}$</p>
<p>否则作为区间$k$的最小值，那么$dp_{i,j|2^k}=dp_{i,j|2^k}+dp_{i-1,j}\times \binom{2^k-1}{2^n-j-A_i}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LIM = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod  = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            res = res * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll a[LIM];</span><br><span class="line">ll pow2[LIM];</span><br><span class="line">ll g[LIM][(<span class="number">1</span> &lt;&lt; LIM) + <span class="number">5</span>];</span><br><span class="line">ll fac[(<span class="number">1</span> &lt;&lt; LIM) + <span class="number">5</span>], ifac[(<span class="number">1</span> &lt;&lt; LIM) + <span class="number">5</span>];</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * ifac[m] % mod * ifac[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + m);</span><br><span class="line">    <span class="built_in">reverse</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + m);</span><br><span class="line">    pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; LIM; i++) &#123;</span><br><span class="line">        pow2[i] = pow2[i - <span class="number">1</span>] &lt;&lt; <span class="number">1ll</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pow2[LIM - <span class="number">1</span>]; i++) &#123;</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ifac[pow2[LIM - <span class="number">1</span>]] = <span class="built_in">qpow</span>(fac[pow2[LIM - <span class="number">1</span>]], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pow2[LIM - <span class="number">1</span>] - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ifac[i] = <span class="number">1ll</span> * ifac[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pow2[n]; j++) &#123;</span><br><span class="line">            g[i][j] = (g[i][j] + g[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &amp; pow2[k])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                g[i][(j | pow2[k])] =</span><br><span class="line">                    (g[i][(j | pow2[k])] +</span><br><span class="line">                     g[i - <span class="number">1</span>][j] * <span class="built_in">C</span>(pow2[n] - j - a[i], pow2[k] - <span class="number">1</span>) % mod *</span><br><span class="line">                         fac[pow2[k]] % mod) %</span><br><span class="line">                    mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pow2[n]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = __builtin_popcount(i);</span><br><span class="line">        <span class="keyword">if</span> (res &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ans = (ans - g[m][i] * fac[pow2[n] - <span class="number">1</span> - i] + mod) % mod;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = (ans + g[m][i] * fac[pow2[n] - <span class="number">1</span> - i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans * pow2[n] % mod;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AtCoder</category>
        <category>题解</category>
        <category>ARC</category>
      </categories>
      <tags>
        <tag>二项式反演</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC080D Prime Flip</title>
    <url>/2021/05/09/ARC080D-Prime-Flip/</url>
    <content><![CDATA[<p><del>哥德巴赫猜想之应用</del></p>
<span id="more"></span>

<p>区间反转就套路差分</p>
<p>所以就是每次选俩位置 $x,y$ 使得 $y-x \in \mathrm{Primes},y-x \neq 2$  取反，目标是差分数组全 $0$</p>
<p>分类讨论</p>
<p>如果 $y-x \in \mathrm{Primes}$ 需要一个操作</p>
<p>如果 $y-x \equiv 0 \bmod 2$ 需要两个操作，因为哥德巴赫猜想目前在很大的范围内成立(至少比数据范围大得多)</p>
<p>否则就是奇数，那我们随便选一个奇质数，然后就变成偶数了，三次操作</p>
<p><del>最大权匹配</del></p>
<p>权值仅有三个，贪心的让第一种最多，可以按奇偶建二分图，差为质数连边，然后跑最大匹配</p>
<p>然后剩余的图中尽可能匹配同奇偶的，也即第二种情况</p>
<p>剩下就是第三种，显然最多只能剩一个</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> nxt;</span><br><span class="line">&#125; edge[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edge[++ecnt].v = v;</span><br><span class="line">    edge[ecnt].nxt = head[u];</span><br><span class="line">    head[u]        = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> a[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; odds, evens;</span><br><span class="line"><span class="keyword">int</span> mmax;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">2000006</span>], pcnt;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getprime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= mmax; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            prime[++pcnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * prime[j] &gt; mmax) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> link[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[edge[i].v]) &#123;</span><br><span class="line">            vis[edge[i].v] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!link[edge[i].v] || <span class="built_in">match</span>(link[edge[i].v])) &#123;</span><br><span class="line">                link[edge[i].v] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        a[x] = <span class="number">1</span>;</span><br><span class="line">        mmax = <span class="built_in">max</span>(mmax, x + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mmax; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        a[i] ^= a[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mmax; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                odds.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                evens.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">getprime</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> odd : odds) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> even : evens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[<span class="built_in">abs</span>(even - odd)]) &#123;</span><br><span class="line">                <span class="built_in">add</span>(odd, even);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> odd : odds) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!link[odd]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> even : evens) &#123;</span><br><span class="line">                vis[even] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += <span class="built_in">match</span>(odd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = ans;</span><br><span class="line">    <span class="keyword">if</span> ((odds.<span class="built_in">size</span>() - p) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        ans += (odds.<span class="built_in">size</span>() - p) - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans += (odds.<span class="built_in">size</span>() - p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((evens.<span class="built_in">size</span>() - p) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        ans += (evens.<span class="built_in">size</span>() - p) - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans += (evens.<span class="built_in">size</span>() - p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((odds.<span class="built_in">size</span>() - p) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; ans + <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AtCoder</category>
        <category>题解</category>
        <category>ARC</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>二分图最大匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>CF868F Yet Another Minimization Problem</title>
    <url>/2021/05/08/CF868F-Yet-Another-Minimization-Problem/</url>
    <content><![CDATA[<p>决策单调性优化DP</p>
<span id="more"></span>

<p>$O(n^2k)$ 的暴力 DP：$dp_{i,j}=\min{dp_{k,j-1}+cnt(k+1,i)}$ $dp_{i,j}$ 表示前 $i$ 个数分 $j$ 段</p>
<p>口胡一下可以发现这个是具有决策单调性的</p>
<p>具体来说因为 $j$ 始终不变，先省略掉，如果 $i \rightarrow i+1$ 那么 $cnt(k+1,i) \rightarrow cnt(k+1,i)+\sum\limits_{l=k+1}^i[a_l=a_{i+1}]$</p>
<p>考虑如果是 $dp_{k,j-1} \rightarrow dp_{i,j}$</p>
<p>那么对于 $dp_{i+1,j}$ 来说所有的 $p \le k$ 都有 $dp_{p,j-1} + cnt(p+1,i) \le dp_{k,j-1}+cnt(k+1,i)$</p>
<p>而当 $i$ 右移之后$dp_{p,j-1}$ 不变，$cnt(p+1,i+1)$ 变化量不小于 $cnt(k+1,i+1)$</p>
<p>所以最优决策必然单调</p>
<p>这样的话我们可以对 $[l,r]$ 分治，$[l,mid-1]$ 的决策点必然在 $[dp_{l,j-1},dp_{mid,j-1}]$ 中且不会在 $dp_{mid,j}$ 的决策点的右边，右边同理</p>
<p>$dp_{mid,j}$ 暴力转移</p>
<p>$cnt(l,r)$ 可以借助类似莫队的方法搞，因为每次拓展仅一次，所以均摊 $O(1)$</p>
<p>复杂度 $O(nk\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">ll a[N];</span><br><span class="line">ll dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> now;</span><br><span class="line"><span class="keyword">int</span> ql = <span class="number">1</span>, qr;</span><br><span class="line">ll res, _cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    res += _cnt[x];</span><br><span class="line">    ++_cnt[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    --_cnt[x];</span><br><span class="line">    res -= _cnt[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">cnt</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (ql &gt; l) &#123;</span><br><span class="line">        <span class="built_in">add</span>(a[--ql]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ql &lt; l) &#123;</span><br><span class="line">        <span class="built_in">del</span>(a[ql++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (qr &gt; r) &#123;</span><br><span class="line">        <span class="built_in">del</span>(a[qr--]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (qr &lt; r) &#123;</span><br><span class="line">        <span class="built_in">add</span>(a[++qr]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">min</span>(mid, R); i &gt;= L; i--) &#123;</span><br><span class="line">        ll tmp = dp[i - <span class="number">1</span>][now ^ <span class="number">1</span>] + <span class="built_in">cnt</span>(i, mid);</span><br><span class="line">        <span class="keyword">if</span> (dp[mid][now] &gt;= tmp) &#123;</span><br><span class="line">            dp[mid][now] = tmp;</span><br><span class="line">            cur          = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(l, mid - <span class="number">1</span>, L, cur);</span><br><span class="line">    <span class="built_in">solve</span>(mid + <span class="number">1</span>, r, cur, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x7f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    now      = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>(<span class="number">1</span>, n, <span class="number">1</span>, n);</span><br><span class="line">        now ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][now ^ <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>决策单调性</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI Online 3 提高组 优秀子序列</title>
    <url>/2021/05/07/NOI_Online_3_%E4%BC%98%E7%A7%80%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>[NOI Online #3 提高组] 优秀子序列</p>
<span id="more"></span>

<p>把 $a_i$ 拆成二进制，视作一个形如 ${010010}$ 的集合，那就是找出所有的不相交的集合的无交并的权值之和</p>
<p>设 $dp_S$ 表示无交并为 $S$  的方案数，答案为 $\sum\limits_{S} dp_S\varphi(S+1)$</p>
<p>容易推出 $dp_S=\sum\limits_{S’ \in S}dp_{S’}\times cnt_{S-S’}$，就是选出来子集然后补成集合 $S$</p>
<p><del>可以子集卷积，但没必要</del></p>
<p>好吧还是卷一下</p>
<p>设$F_i(x)=x^{a_i}+x^{\phi}$</p>
<p>卷积为 $(F*G)[k]=\sum\limits_{i|j=k,i\&amp;j=0}F[i]G[j]$</p>
<p>答案就是 $\prod F_i(x)$的系数</p>
<p>按照付公主背包那题套路一下变成</p>
<p>$\exp\sum\ln(x^{a_i}+x^{\phi})=\exp\sum\limits_{i}\sum\limits_{k}\dfrac{(-1)^{k+1}(x^{a_i})^k}{k}$</p>
<p>显然 $(x^{a_i})^k$当且仅当 $k=1$ 时不为零（子集卷积意义下）</p>
<p>所以就是求 $\exp\sum x^{a_i}$</p>
<p>$O(n^2)$ exp即可（没写）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300005</span>, mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, mmax, cnt;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], dp[N];</span><br><span class="line"><span class="keyword">int</span> pcnt, primes[N], phi[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; cnt) &lt;= mmax) &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    pcnt   = <span class="number">0</span>;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            primes[++pcnt] = i;</span><br><span class="line">            phi[i]         = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt &amp;&amp; primes[j] * i &lt;= n; ++j) &#123;</span><br><span class="line">            vis[primes[j] * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[primes[j] * i] = phi[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                phi[primes[j] * i] = phi[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        ++a[x];</span><br><span class="line">        mmax = <span class="built_in">max</span>(mmax, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pre</span>(N - <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>, b[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; cnt); ++i) &#123;</span><br><span class="line">        b[i] = b[i &gt;&gt; <span class="number">1</span>] &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = b[i] ^ i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> S = m;; S = (S - <span class="number">1</span>) &amp; m) &#123;</span><br><span class="line">                dp[S | i] = (dp[S | i] + <span class="number">1ll</span> * dp[S] * a[i]) % mod;</span><br><span class="line">                <span class="keyword">if</span> (!S) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; cnt); ++i) &#123;</span><br><span class="line">        ans = (ans + <span class="number">1ll</span> * dp[i] * phi[i + <span class="number">1</span>]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[<span class="number">0</span>]; ++i) &#123;</span><br><span class="line">        ans = <span class="number">2</span> * ans % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>子集卷积</tag>
      </tags>
  </entry>
  <entry>
    <title>PKUWC2019 D1T1</title>
    <url>/2021/05/01/PKUWC2019-D1T1/</url>
    <content><![CDATA[<h3 id="PKUWC2019-D1T1"><a href="#PKUWC2019-D1T1" class="headerlink" title="PKUWC2019 D1T1"></a>PKUWC2019 D1T1</h3><p>不知道题目名</p>
<span id="more"></span>

<h4 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h4><p>$n$ 个点，$m$ 条边的无向图，每条边可以存在/不存在，求在所有 $2^m$ 的状态中合法的拓扑序数量</p>
<p>$n \le 20,m \le \frac{n(n-1)}{2}$</p>
<h4 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h4><p>考虑 $2^{m}$ 的边的状态是没法做的，反向考虑每个点所能 “贡献” 的合法的边的状态</p>
<p>具体来说设 $dp_S$ 表示<strong>当前</strong>的拓扑序集合 $S$ 所能确定的边的状态，考虑加入新点 $x$ 使得 $S \rightarrow S’$</p>
<p>对于所有 $x$ 的入边 $(u,x)$ ，如果 $u \in S$ 那么这条边可存在也可不存在，否则必须不存在</p>
<p>这样就能更新能确定的边，最终答案是 $dp_{V}$</p>
<p>因为没地方交就不写了（也没啥好写的</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>八省联考2018 制胡窜</title>
    <url>/2021/05/01/%E5%85%AB%E7%9C%81%E8%81%94%E8%80%832018-%E5%88%B6%E8%83%A1%E7%AA%9C/</url>
    <content><![CDATA[<p>除了代码有点难调还是挺妙的</p>
<span id="more"></span>

<p>题意：将一个字符串$S$分为三段$[1,i],[i+1,j-1],[j,n]$ 至少有一段包含了子串$S_{l,r}$的方案数</p>
<p>至少有一段不太好统计，考虑总共的方案数是$\binom{n-1}{2}$，如果能减去三段全不包含的就能得到答案</p>
<p>至少我们得知道$S_{l,r}$的所有位置，那假设我们就知道了（？）所有形如$[l_i,r_i]$的区间是$S_{l,r}$的位置，为了方便设有$m$个区间且按$l$从小到大排序</p>
<p>首先可以发现如果有三个子串不重叠必然为$0$</p>
<p>否则分类讨论</p>
<h4 id="Case-1"><a href="#Case-1" class="headerlink" title="Case 1:"></a>Case 1:</h4><p>如果最左的子串和最右的子串重叠，即$r_1&gt;l_{m}$</p>
<p>那么我们对$i$的选取讨论一下首先肯定是在$[1,r_1)$</p>
<p>如果$i\in[1,l_1)$那么$j$只能选$(l_m,r_1]$，贡献为$(l_1-1)(r_1-l_m)$</p>
<p>如果$i\in[l_i,l_{i+1})$，此时$j$的限制是$(l_m,r_{i+1}]$，贡献为$\sum(l_{i+1}-l_i)(r_{i+1}-l_m)$</p>
<p>如果$i\in[l_{i+1},r_1)$ 仅需保证$i+1&lt;j$，贡献为$\binom{r1-l_m}{2}+(r_1-l_m)(n-r_1)$</p>
<h4 id="Case-2"><a href="#Case-2" class="headerlink" title="Case 2:"></a>Case 2:</h4><p>如果最左的子串和最右的子串不交，即$r_1&lt;l_m$</p>
<p>首先如果$i \in [1,l_1)$是没法选的</p>
<p>当$i\in[l_i,l_{i+1}]$略麻烦，实际上也能写出这个式子$\sum(r_{i+1}-r_i)(r_{i+1}-l_m)$ 要求是$l_m&lt;r_{i+1}$ 且$l_{i+1}&lt;r_1$</p>
<p>但实际上会漏掉一些答案，还需要找到$r_1+len-1$在$endpos$中的前驱和后继$p_1,p_2$（建议画图理解）贡献为$(r_1-l_{p1})(r_{p2}-l_m)$</p>
<p>所以最终我们要维护区间最大最小，和$(r_{i+1}-r_i)r_{i+1}$与$(r_{i+1}-r_i)$（Case1中求和也可以改成这样）</p>
<p>对于询问先判断是否有三个相交的区间，然后讨论</p>
<p>前后缀可以利用最大最小来查询</p>
<p>至于$endpos$集合（也就是$[l_i,r_i]$），虽然在SAM定义里有这个东西，但实际上建出来的SAM是没有的</p>
<p>但是可以考虑每一个状态的$endpos$是他的$link$的所有点的$endpos$并集，这个东西可以跑线段树合并</p>
<p>具体来说是对于每一个前缀$i$插入到权值线段树里，然后$dfs$搞出来所有的$endpos$ </p>
<p>找$S_{l,r}$在SAM上的位置可以倍增</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> nxt;</span><br><span class="line">&#125; edge[N * <span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> head[N * <span class="number">2</span>], ecnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edge[++ecnt].v = v;</span><br><span class="line">    edge[ecnt].nxt = head[u];</span><br><span class="line">    head[u]        = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> SegmentTree &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">6</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mmin, mmax;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s1, s2;</span><br><span class="line">    <span class="keyword">int</span> ls, rs;</span><br><span class="line">&#125; tr[maxn * <span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="function">Node <span class="title">merge</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span> </span>&#123;</span><br><span class="line">    Node c;</span><br><span class="line">    c.mmin = <span class="built_in">min</span>(a.mmin, b.mmin);</span><br><span class="line">    c.mmax = <span class="built_in">max</span>(a.mmax, b.mmax);</span><br><span class="line">    c.s1   = a.s1 + b.s1 + b.mmin * <span class="number">1LL</span> * (b.mmin - a.mmax);</span><br><span class="line">    c.s2   = a.s2 + b.s2 + b.mmin - a.mmax;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[x].ls &amp;&amp; tr[x].rs) &#123;</span><br><span class="line">        tr[x].mmin = <span class="built_in">min</span>(tr[tr[x].ls].mmin, tr[tr[x].rs].mmin);</span><br><span class="line">        tr[x].mmax = <span class="built_in">max</span>(tr[tr[x].ls].mmax, tr[tr[x].rs].mmax);</span><br><span class="line">        tr[x].s1 =</span><br><span class="line">            tr[tr[x].ls].s1 + tr[tr[x].rs].s1 +</span><br><span class="line">            tr[tr[x].rs].mmin * <span class="number">1LL</span> * (tr[tr[x].rs].mmin - tr[tr[x].ls].mmax);</span><br><span class="line">        tr[x].s2 = tr[tr[x].ls].s2 + tr[tr[x].rs].s2 + tr[tr[x].rs].mmin -</span><br><span class="line">                   tr[tr[x].ls].mmax;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tr[x].ls) &#123;</span><br><span class="line">        <span class="keyword">int</span> t_ls = tr[x].ls;</span><br><span class="line">        <span class="keyword">int</span> t_rs = tr[x].rs;</span><br><span class="line">        tr[x]    = tr[tr[x].ls];</span><br><span class="line">        tr[x].ls = t_ls;</span><br><span class="line">        tr[x].rs = t_rs;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> t_ls = tr[x].ls;</span><br><span class="line">        <span class="keyword">int</span> t_rs = tr[x].rs;</span><br><span class="line">        tr[x]    = tr[tr[x].rs];</span><br><span class="line">        tr[x].ls = t_ls;</span><br><span class="line">        tr[x].rs = t_rs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">querymax</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">        <span class="keyword">return</span> tr[rt].mmax;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid)</span><br><span class="line">        ans = <span class="built_in">querymax</span>(tr[rt].ls, l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span> (R &gt; mid)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">querymax</span>(tr[rt].rs, mid + <span class="number">1</span>, r, L, R));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">querymin</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">        <span class="keyword">return</span> tr[rt].mmin;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid)</span><br><span class="line">        ans = <span class="built_in">querymin</span>(tr[rt].ls, l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span> (R &gt; mid)</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="built_in">querymin</span>(tr[rt].rs, mid + <span class="number">1</span>, r, L, R));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">Node c_res;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cquery</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c_res.mmin == <span class="number">0</span>)</span><br><span class="line">            c_res = tr[rt];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            c_res = <span class="built_in">merge</span>(c_res, tr[rt]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid)</span><br><span class="line">        <span class="built_in">cquery</span>(tr[rt].ls, l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span> (R &gt; mid)</span><br><span class="line">        <span class="built_in">cquery</span>(tr[rt].rs, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt)</span><br><span class="line">        rt = ++tot;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tr[rt].mmin = tr[rt].mmax = p;</span><br><span class="line">        tr[rt].s1 = tr[rt].s2 = <span class="number">0</span>;</span><br><span class="line">        tr[rt].ls = tr[rt].rs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid)</span><br><span class="line">        <span class="built_in">update</span>(tr[rt].ls, l, mid, p);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">update</span>(tr[rt].rs, mid + <span class="number">1</span>, r, p);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y)</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    <span class="keyword">int</span> rt    = ++tot;</span><br><span class="line">    tr[rt].ls = <span class="built_in">merge</span>(tr[x].ls, tr[y].ls);</span><br><span class="line">    tr[rt].rs = <span class="built_in">merge</span>(tr[x].rs, tr[y].rs);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace SegmentTree</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rt[N], dep[N], fa[N * <span class="number">2</span>][<span class="number">19</span>];</span><br><span class="line"><span class="keyword">int</span> pos[N];</span><br><span class="line"><span class="keyword">namespace</span> SAM &#123;</span><br><span class="line"><span class="keyword">int</span> nxt[N * <span class="number">2</span>][<span class="number">10</span>], link[N * <span class="number">2</span>], len[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> cnt, last;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = ++cnt;</span><br><span class="line">    <span class="keyword">int</span> p   = last;</span><br><span class="line">    last    = cur;</span><br><span class="line">    pos[id] = cur;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; !nxt[p][c]) &#123;</span><br><span class="line">        nxt[p][c] = cur;</span><br><span class="line">        p         = link[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">        link[cur] = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q = nxt[p][c];</span><br><span class="line">        <span class="keyword">if</span> (len[p] + <span class="number">1</span> == len[q]) &#123;</span><br><span class="line">            link[cur] = q;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> cq  = ++cnt;</span><br><span class="line">            len[cq] = len[p] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(nxt[cq], nxt[q], <span class="built_in"><span class="keyword">sizeof</span></span>(nxt[q]));</span><br><span class="line">            link[cq] = link[q];</span><br><span class="line">            link[q] = link[cur] = cq;</span><br><span class="line">            <span class="keyword">while</span> (p &amp;&amp; nxt[p][c] == q) &#123;</span><br><span class="line">                nxt[p][c] = cq;</span><br><span class="line">                p         = link[p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (link[i]) &#123;</span><br><span class="line">            <span class="built_in">add</span>(link[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        SegmentTree::<span class="built_in">update</span>(rt[pos[i]], <span class="number">1</span>, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    fa[x][<span class="number">0</span>] = link[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">18</span>; i++) &#123;</span><br><span class="line">        fa[x][i] = fa[fa[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v  = edge[i].v;</span><br><span class="line">        dep[v] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="number">1</span>) &#123;</span><br><span class="line">            rt[x] = SegmentTree::<span class="built_in">merge</span>(rt[x], rt[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace SAM</span></span><br><span class="line"><span class="function">ll <span class="title">C2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * n * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">querym</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> SAM::len;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> SegmentTree;</span><br><span class="line">    <span class="keyword">int</span> plen = r - l + <span class="number">1</span>, x = pos[r];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">18</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (len[fa[x][i]] &gt;= plen) &#123;</span><br><span class="line">            x = fa[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = tr[rt[x]].mmin, R = tr[rt[x]].mmax;</span><br><span class="line">    <span class="keyword">if</span> (L &lt; R - plen * <span class="number">2</span> + <span class="number">1</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">querymax</span>(rt[x], <span class="number">1</span>, n, L, R - plen) - plen + <span class="number">1</span> &gt; L)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">C2</span>(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (R - plen + <span class="number">1</span> &lt;= L) &#123;</span><br><span class="line">        Node now = tr[rt[x]];</span><br><span class="line">        <span class="keyword">int</span> lm   = R - plen + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans =</span><br><span class="line">            now.s1 - now.s2 * lm + <span class="built_in">C2</span>(L - lm) + (L - lm) * <span class="number">1LL</span> * (n - plen);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">C2</span>(n - <span class="number">1</span>) - ans;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c_res  = (Node)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> lm = R - plen + <span class="number">1</span>, poslm = <span class="built_in">querymax</span>(rt[x], <span class="number">1</span>, n, <span class="number">1</span>, lm);</span><br><span class="line">        <span class="built_in">cquery</span>(rt[x], <span class="number">1</span>, n, poslm, L + plen - <span class="number">1</span>);</span><br><span class="line">        Node now      = c_res;</span><br><span class="line">        <span class="keyword">int</span> p1        = <span class="built_in">querymax</span>(rt[x], <span class="number">1</span>, n, <span class="number">1</span>, L + plen - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> p2        = <span class="built_in">querymin</span>(rt[x], <span class="number">1</span>, n, L + plen, n);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = now.s1 - now.s2 * lm +</span><br><span class="line">                        (p2 &gt; lm ? (L - (p1 - plen + <span class="number">1</span>)) * <span class="number">1LL</span> * (p2 - lm) : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">C2</span>(n - <span class="number">1</span>) - ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    cin &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    SAM::last = SAM::cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        SAM::<span class="built_in">insert</span>(s[i] - <span class="string">&#x27;0&#x27;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    SAM::<span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">querym</span>(l, r) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Asusetic eru quionours</strong></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title>联合省选2021 A卷</title>
    <url>/2021/04/29/%E8%81%94%E5%90%88%E7%9C%81%E9%80%892021-A%E5%8D%B7/</url>
    <content><![CDATA[<p>不想写游记，没啥可写的，写写题解算了</p>
<span id="more"></span>

<h3 id="D1T1-卡牌游戏"><a href="#D1T1-卡牌游戏" class="headerlink" title="D1T1 卡牌游戏"></a>D1T1 卡牌游戏</h3><p>考虑到翻肯定翻最大最小值才能有效，那我们如果把所有值不分 $a,b$ 面升序排序就是删去一段前后缀使得剩下的极差最大</p>
<p>有额外限制是不能删除超过 $m$ 个数字，$a,b$ 不能一起删</p>
<p>直接用双指针维护删到哪就行 复杂度 $O(n\log n)$</p>
<p><del>这题适合有梦想的选手，直接输出所有数最大-最小就能过官方数据</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    ll val;</span><br><span class="line">    <span class="keyword">int</span> id, v;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Data &amp;A, <span class="keyword">const</span> Data &amp;B) &#123;</span><br><span class="line">        <span class="keyword">return</span> A.val &lt; B.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">bool</span> used[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i].val;</span><br><span class="line">        a[i].v  = <span class="number">1</span>;</span><br><span class="line">        a[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i + n].val;</span><br><span class="line">        a[i + n].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + <span class="number">2</span> * n);</span><br><span class="line">    ll l = <span class="number">0</span>, r = n * <span class="number">2</span> + <span class="number">1</span>, now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!used[a[l + <span class="number">1</span>].id] &amp;&amp; now + a[l + <span class="number">1</span>].v &lt;= m) &#123;</span><br><span class="line">        now += a[l + <span class="number">1</span>].v;</span><br><span class="line">        used[a[l + <span class="number">1</span>].id] = <span class="number">1</span>;</span><br><span class="line">        l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!used[a[r - <span class="number">1</span>].id] &amp;&amp; now + a[r - <span class="number">1</span>].v &lt;= m) &#123;</span><br><span class="line">        now += a[r - <span class="number">1</span>].v;</span><br><span class="line">        used[a[r - <span class="number">1</span>].id] = <span class="number">1</span>;</span><br><span class="line">        r--;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">2e18</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ans           = <span class="built_in">min</span>(a[r - <span class="number">1</span>].val - a[l + <span class="number">1</span>].val, ans);</span><br><span class="line">        used[a[l].id] = <span class="number">0</span>;</span><br><span class="line">        now -= a[l--].v;</span><br><span class="line">        <span class="keyword">while</span> (!used[a[r - <span class="number">1</span>].id] &amp;&amp; now + a[r - <span class="number">1</span>].v &lt;= m) &#123;</span><br><span class="line">            now += a[r - <span class="number">1</span>].v;</span><br><span class="line">            used[a[r - <span class="number">1</span>].id] = <span class="number">1</span>;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="D1T2-矩阵游戏"><a href="#D1T2-矩阵游戏" class="headerlink" title="D1T2 矩阵游戏"></a>D1T2 矩阵游戏</h3><p>构造并不是很麻烦的部分，其实也不难想，主要是处理 $0 \le a_{i,j} \le 10^6$ 的限制</p>
<p>考虑如果把所有的条件写成一个巨大的方程组，会发现有右下最外边的一圈是自由元，那我们钦定右下一行一列就可以递推了</p>
<p>然后就是怎么把这个推出来的 $a_{i,j}$ 改成合适的范围</p>
<p>发现对一行分别 $+x,-x,+x,-x\dots$ 的操作是不变的，一列同理</p>
<p>那么设 $c_i$ 是第 $i$ 列的调整量 $r_i$ 是对 $i$ 行的调整量</p>
<p>那么他们的改边量矩阵是</p>
<p>$$<br>\begin{bmatrix}<br>\begin{array}{c}<br>r_1+c_1 &amp; -r_1+c_2 &amp; r_1+c_3 &amp; \dots \\<br>r_2-c_1 &amp; -r_2-c_2 &amp; r_2-c_3 &amp; \dots \\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots \\<br>\end{array}<br>\end{bmatrix}<br>$$</p>
<p>每个位置需要满足 $ -a_{i,j} \le r_i \pm c_j\le10^6 -a_{i,j}$</p>
<p>虽然减法差分约束能做，但是和的形式好像不大好搞</p>
<p>试着类似黑白染色的取反</p>
<p>即</p>
<p>$$<br>\begin{bmatrix}<br>\begin{array}{c}<br>\mathrm{+} &amp; - &amp; + &amp; - \\<br>\mathrm{-} &amp; + &amp; - &amp; + \\<br>\mathrm{+} &amp; - &amp; + &amp; - \\<br>\mathrm{-} &amp; + &amp; - &amp; + \\<br>\end{array}<br>\end{bmatrix}<br>$$</p>
<p>显然这样也是不变的</p>
<p>那原矩阵都会是 $x-y$ 的形式，即<br>$$<br>\begin{bmatrix}<br>\begin{array}{c}<br>r_1-c_1 &amp; c_2-r_1 &amp; r_1-c_3 &amp; \dots \\<br>c_1-r_2 &amp; r_2-c_2 &amp; c_3-r_2 &amp; \dots \\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots \\<br>\end{array}<br>\end{bmatrix}<br>$$</p>
<p>就可以差分约束了</p>
<p>边很多，但卡不满</p>
<p><del>然而我连钦定自由元都没想到</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N   = <span class="number">605</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> b[N][N];</span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> w, nxt;</span><br><span class="line">&#125; edge[N * N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N * N * <span class="number">2</span>], ecnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">    ecnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edge[++ecnt].v = v;</span><br><span class="line">    edge[ecnt].w   = w;</span><br><span class="line">    edge[ecnt].nxt = head[u];</span><br><span class="line">    head[u]        = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dis[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N * <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x7f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        ++cnt[x];</span><br><span class="line">        vis[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt[x] &gt; n + m) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[x] + edge[i].w) &#123;</span><br><span class="line">                dis[v] = dis[x] + edge[i].w;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!q.<span class="built_in">empty</span>() &amp;&amp; dis[v] &lt; dis[q.<span class="built_in">front</span>()]) &#123;</span><br><span class="line">                        q.<span class="built_in">push_front</span>(v);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        q.<span class="built_in">push_back</span>(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                    vis[v] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">                cin &gt;&gt; b[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">                a[i][j] = b[i][j] - a[i + <span class="number">1</span>][j] - a[i + <span class="number">1</span>][j + <span class="number">1</span>] - a[i][j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i + j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">add</span>(i, j + n, MAX - a[i][j]);</span><br><span class="line">                    <span class="built_in">add</span>(j + n, i, a[i][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">add</span>(i, j + n, a[i][j]);</span><br><span class="line">                    <span class="built_in">add</span>(j + n, i, MAX - a[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">spfa</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((i + j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                        a[i][j] -= dis[i];</span><br><span class="line">                        a[i][j] += dis[j + n];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        a[i][j] += dis[i];</span><br><span class="line">                        a[i][j] -= dis[j + n];</span><br><span class="line">                    &#125;</span><br><span class="line">                    cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="D1T3-图函数"><a href="#D1T3-图函数" class="headerlink" title="D1T3 图函数"></a>D1T3 图函数</h3><p>$f(i,G)$ 就是 $[1,i]$ 这段点里满足 $i \rightarrow x$ 联通且 $x \rightarrow i$ 联通的 $x$ 的个数</p>
<p>发现其实条件就是 存在有 $i \rightarrow x$ 和 $x \rightarrow i$ 的路径不经过 $[1,x)$ 中的点</p>
<p>证明只要口胡下就行，如果存在 $i\rightarrow y \rightarrow x  \ (y \in [1,x)$ 的路径且 $i,x$ 双向联通那 $y$ 就被删了</p>
<p>设 $[i,x]$ 代表满足 $i,x$ 双向联通</p>
<p>那么我们要求的就是当前的 $G$ 的 $\sum\limits_{u,v \in G}[u,v]$</p>
<p>删边不太好做，反向加边</p>
<p>随着边增加满足条件的点对必然增大，仅需求出增量然后前缀和就行，也就是找到每个点对最早满足条件的时间</p>
<p>这种转移直接 Floyd 即可</p>
<p>复杂度 $O(n^3+m)$，虽然看起来稳 T 但是能过…</p>
<p>不知道有没有复杂度靠谱的算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> G[N][N];</span><br><span class="line"><span class="keyword">int</span> tim[N * N];</span><br><span class="line"><span class="keyword">int</span> n, m, ans[N * N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u][v] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = n; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            tim[<span class="built_in">min</span>(G[k][i], G[i][k])]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!G[i][k]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> nowid = G[i][k];</span><br><span class="line">            <span class="keyword">if</span> (i &gt; k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">                    G[i][j] = <span class="built_in">max</span>(G[i][j], <span class="built_in">min</span>(nowid, G[k][j]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                    G[i][j] = <span class="built_in">max</span>(G[i][j], <span class="built_in">min</span>(nowid, G[k][j]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[m + <span class="number">1</span>] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        ans[i] = ans[i + <span class="number">1</span>] + tim[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="D2T1-宝石"><a href="#D2T1-宝石" class="headerlink" title="D2T1 宝石"></a>D2T1 宝石</h3><p>概括下题意就是找到 $ u \rightarrow v$ 路径上最长的连续子序列，只需要按照给出个排列 $p$ 编号即可</p>
<p>先考虑链上的做法，发现可以倍增处理</p>
<p>因为对当前有贡献的只能是下一个数，所以按后继倍增，正反跑就行</p>
<p>而树上的做法先套路成 $u\rightarrow lca$ $lca \rightarrow v$ </p>
<p>$u \rightarrow lca$ 仍然可以倍增处理，而下行段考虑记录前驱倍增，如果倍增到当前前驱深度大于 $lca$ 就是一个可行解</p>
<p>然后发现答案是满足单调性的，于是可以二分</p>
<p>复杂度 $O(n \log^2n)$</p>
<p><del>题很不错，就是人菜</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, m, c;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> p[N], id[N], w[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> nxt;</span><br><span class="line">&#125; edge[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"><span class="keyword">int</span> lca[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edge[++ecnt].v = v;</span><br><span class="line">    edge[ecnt].nxt = head[u];</span><br><span class="line">    head[u]        = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">21</span>], dep[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[x][<span class="number">0</span>] = f;</span><br><span class="line">    dep[x]   = dep[f] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">19</span>; i++) &#123;</span><br><span class="line">        fa[x][i] = fa[fa[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">        <span class="keyword">if</span> (v == f) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pre</span>(v, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[fa[u][i]] &gt;= dep[v]) &#123;</span><br><span class="line">            u = fa[u][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) &#123;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[u][i] != fa[v][i]) &#123;</span><br><span class="line">            u = fa[u][i];</span><br><span class="line">            v = fa[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; up[N], down[N];</span><br><span class="line"><span class="keyword">int</span> updep[N][<span class="number">21</span>], ans[N];</span><br><span class="line"><span class="keyword">int</span> last[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p            = last[w[x]];</span><br><span class="line">    last[w[x]]       = dep[x];</span><br><span class="line">    updep[dep[x]][<span class="number">0</span>] = last[w[x] + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">19</span>; i++) &#123;</span><br><span class="line">        updep[dep[x]][i] = updep[updep[dep[x]][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> d : up[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = last[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x &lt; dep[lca[d]]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++ans[d];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (updep[x][i] &gt;= dep[lca[d]]) &#123;</span><br><span class="line">                ans[d] += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                x = updep[x][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">        <span class="keyword">if</span> (v != fa[x][<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="built_in">qup</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    last[w[x]] = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p            = last[w[x]];</span><br><span class="line">    last[w[x]]       = dep[x];</span><br><span class="line">    updep[dep[x]][<span class="number">0</span>] = last[w[x] - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">19</span>; i++) &#123;</span><br><span class="line">        updep[dep[x]][i] = updep[updep[dep[x]][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> d : down[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = ans[d] + <span class="number">1</span>, r = c, res = ans[d];</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> x = last[mid], cnt = mid - ans[d] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; i) &amp; cnt) &#123;</span><br><span class="line">                    x = updep[x][i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; dep[lca[d]]) &#123;</span><br><span class="line">                res = mid;</span><br><span class="line">                l   = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[d] = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">        <span class="keyword">if</span> (v != fa[x][<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="built_in">qdown</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    last[w[x]] = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; i++) &#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">        id[p[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line">        w[i] = id[w[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="built_in">add</span>(u, v);</span><br><span class="line">        <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    dep[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pre</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        lca[i] = <span class="built_in">getLCA</span>(u, v);</span><br><span class="line">        up[u].<span class="built_in">push_back</span>(i);</span><br><span class="line">        down[v].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(updep, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(updep));</span><br><span class="line">    <span class="built_in">qup</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">qdown</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="D2T2-滚榜"><a href="#D2T2-滚榜" class="headerlink" title="D2T2 滚榜"></a>D2T2 滚榜</h3><p>数据范围就把状压拍脸上了</p>
<p>考虑对一个排列 $\pi$ ，贪心的分配使得 $b_i$ 尽可能小即可</p>
<p>具体来说若 $\pi_i&gt;\pi_{i-1}$ 那因为 $b_i$ 不降就取 $b_{i-1}$ 否则取 $b_i=b_{i-1}+\pi_{i-1}-\pi_i$ （还需要考虑下分数相同标号小的放前面）</p>
<p>dp 是 $f[S][i][j]$ 表示状态为 $S$ 上一个人是 $i$ 当前用掉了 $j=\sum b_i$</p>
<p>可以发现 $\sum b_i=\sum\max(\pi_{i-1}-\pi_i,0)(n-i+1)$</p>
<p>枚举状态时枚举下一个人</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">13</span>, M = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, S, a[N + <span class="number">1</span>], id[<span class="number">1</span> &lt;&lt; N | <span class="number">1</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[(<span class="number">1</span> &lt;&lt; N) + <span class="number">1</span>][N + <span class="number">1</span>][M + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mmax = <span class="number">-1</span>, maxid;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    S = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; mmax) &#123;</span><br><span class="line">            mmax  = a[i];</span><br><span class="line">            maxid = i;</span><br><span class="line">        &#125;</span><br><span class="line">        id[<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = n * (mmax - a[i] + (maxid &lt; i));</span><br><span class="line">        <span class="keyword">if</span> (v &lt;= m) &#123;</span><br><span class="line">            dp[<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)][i][v] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; S; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = __builtin_popcount(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = i; t; t -= <span class="built_in">lowbit</span>(t)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> sum = <span class="number">0</span>; sum &lt;= m; sum++) &#123;</span><br><span class="line">                <span class="keyword">int</span> pos = id[<span class="built_in">lowbit</span>(t)];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((i &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)))) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> v =</span><br><span class="line">                            sum + (n - cnt) * <span class="built_in">max</span>(<span class="number">0</span>, (pos &lt; j) + a[pos] - a[j]);</span><br><span class="line">                        <span class="keyword">if</span> (v &lt;= m) &#123;</span><br><span class="line">                            dp[i | (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j][v] += dp[i][pos][sum];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            ans += dp[S][j][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="D2T3-支配"><a href="#D2T3-支配" class="headerlink" title="D2T3 支配"></a>D2T3 支配</h3><p>显然支配关系会构成一个树，假如我们通过奥妙重重的方法拿到了这个树</p>
<p>考虑加入边 $(u,v)$ 的影响，可以发现若 $x$ 的受支配集变化当且仅当 $fa_x$ 的受支配集变化或者 $fa_x$ 不支配 $x$</p>
<p>直接枚举点判断，从根节点向下找虽然也行，不过按 $bfs$ 序更好写</p>
<p>建树可以用 $O(n^2)$ 的算法，也就是枚举每个点删除后 $1$ 到其他点的连通性即可</p>
<p>总复杂度 $O(n^2+qn)$</p>
<p>虽然用优秀的 $O(n)$ 支配树建法可以不动脑子的过本题….?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">int</span> nxt;</span><br><span class="line">    &#125; edge[N * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N], ecnt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        edge[++ecnt].v = v;</span><br><span class="line">        edge[ecnt].nxt = head[u];</span><br><span class="line">        head[u]        = ecnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G, rG;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">bool</span> dom[N][N], qaq[N][N];</span><br><span class="line"><span class="keyword">int</span> in[N], fa[N], id[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dom[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dom[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> _i = G.head[x]; _i; _i = G.edge[_i].nxt) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = G.edge[_i].v;</span><br><span class="line">                <span class="keyword">if</span> (dom[i][v] &amp;&amp; (i != v)) &#123;</span><br><span class="line">                    dom[i][v] = <span class="number">0</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            in[j] += dom[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> que[N], head;</span><br><span class="line">    que[++head] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dom[x][i]) &#123;</span><br><span class="line">                --in[i];</span><br><span class="line">                <span class="keyword">if</span> (in[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                    fa[i] = x;</span><br><span class="line">                    q.<span class="built_in">push</span>(i);</span><br><span class="line">                    que[++head] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        id[i] = que[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        qaq[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rG.head[x]; j; j = rG.edge[j].nxt) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = rG.edge[j].v;</span><br><span class="line">                <span class="keyword">if</span> (!qaq[i][v] &amp;&amp; (v != fa[i])) &#123;</span><br><span class="line">                    qaq[i][v] = <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        G.<span class="built_in">add</span>(u, v);</span><br><span class="line">        rG.<span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> vis[N];</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            vis[id[i]] =</span><br><span class="line">                ((!dom[fa[id[i]]][a] &amp;&amp; qaq[id[i]][b]) || (vis[fa[id[i]]]));</span><br><span class="line">            ans += vis[id[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="额外内容"><a href="#额外内容" class="headerlink" title="额外内容"></a>额外内容</h3><p>当然是HE下午的特色FJOI2021加试，然而除了<a href="https://ycsgg.github.io/2021/04/28/%E8%AE%B0%E4%B8%80%E9%81%93%E6%95%B0%E5%AD%A6%E9%A2%98/">T3</a>啥也不会</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>差分约束</tag>
        <tag>贪心</tag>
        <tag>状压DP</tag>
        <tag>图论</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github Action自动部署</title>
    <url>/2021/04/28/Hexo-Github-Action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>因为Hexo三连太麻烦了，尤其是我还得切wsl，所以搞了下自动部署</p>
<span id="more"></span>

<p>部署好之后的流程是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">	本地写Markdown文件 --&gt; push到github上 </span><br><span class="line">	push到github上 --&gt; 由GithubAction部署至GithubPages</span><br><span class="line">	由GithubAction部署至GithubPages -- 成功 --&gt; 网页部署完毕</span><br><span class="line">	由GithubAction部署至GithubPages -- 失败 --&gt; 发邮件提醒</span><br></pre></td></tr></table></figure>

<p><del>我就想试下流程图</del></p>
<h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1."></a>Step 1.</h3><p>因为 Hexo 的网页是由 Hexo 生成的，所以 GithubPages 上的内容不是写的markdown</p>
<p>为了只写 markdown 然后让 Github 代劳生成网页得新建一个仓库</p>
<p>假定为 <code>user/Blog</code> 好了</p>
<p>在本地 Hexo 的文件夹里先 <code>Hexo clean</code> 清除掉之前生成的文件</p>
<p>记得去把 <code>themes</code> 下的的主题的 <code>.git</code> 文件夹删掉（如果有的话）</p>
<p>然后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;init&quot;</span></span><br><span class="line">git remote add origin git@github.com:user/Blog.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<p>把本地库放到 Github 上</p>
<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2."></a>Step 2.</h3><p>为了让 <code>user/Blog</code> 能够在集成的时候访问 <code>user/user.github.io</code> 需要配置密钥对</p>
<p>用如下命令生成一对密钥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;Hexo Deploy Key&quot;</span> -f github-key-blog -N <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>github-key-blog</code> 是私钥，另一个是公钥</p>
<p>在 Github里 <code>user/Blog</code> 的Setiing -&gt; Secrets 里添加私钥</p>
<p>在 <code>user/user.github.io</code> 的Setting -&gt; Depoly Key 中添加公钥，记得勾选 Allow write access </p>
<p>这样 <code>user/Blog</code> 就可以写入 GithubPages 的库里了</p>
<h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3."></a>Step 3.</h3><p>最后在 <code>user/Blog</code> 处添加一个 Action</p>
<p>内容如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">Blog</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> </span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line">      </span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span> </span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span> </span><br><span class="line">        </span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">Repository</span> <span class="string">master</span> <span class="string">branch</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@master</span> </span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span> <span class="number">10.</span><span class="string">x</span> </span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@master</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&quot;10.x&quot;</span></span><br><span class="line">   </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Hexo</span> <span class="string">Dependencies</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Deploy</span> <span class="string">Private</span> <span class="string">Key</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">HEXO_DEPLOY_PRIVATE_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.私钥名称</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">~/.ssh/</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">&quot;$HEXO_DEPLOY_PRIVATE_KEY&quot;</span> <span class="string">&gt;</span> <span class="string">~/.ssh/id_rsa</span> </span><br><span class="line">        <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">        <span class="string">ssh-keyscan</span> <span class="string">github.com</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line">        </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Git</span> <span class="string">Infomation</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span> </span><br><span class="line">        <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">&#x27;名字&#x27;</span> </span><br><span class="line">        <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">&#x27;邮件&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Hexo</span> </span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">        <span class="string">hexo</span> <span class="string">generate</span> </span><br><span class="line">        <span class="string">hexo</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure>

<p>保存之后再 <code>user/Blog</code> 里 push 就会自动更新了（当然挺慢的）</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 717Div2</title>
    <url>/2021/04/28/Codeforces-717Div2/</url>
    <content><![CDATA[<p>VP记录</p>
<span id="more"></span>

<p>第一次VP，过了ABC，D题读题读错浪费大量时间</p>
<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p><del>lexicographically 单词好长</del></p>
<p>字典序就很好搞，尽可能地让前面的小就行了（ pretest 过了还担心自己 FST 手玩了会 ， 浪费时间 * 1 ）</p>
<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>一开始以为只能变成俩，还说这题过于弱智 （阅读理解能力 – ）</p>
<p>然后冷静了一下没交，发现是至少俩，然后想了想没必要多于三个，否则可以合并，就判断一下哪三段/两段即可</p>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>和为奇数必然无解</p>
<p>如果是偶数需要讨论一下</p>
<p>先跑 $01$ 背包是否有解，然后考虑删数字</p>
<p>删成奇数肯定就无解了，如果有奇数就直接删掉肯定没问题</p>
<p>否则除 $2^k$ 再删去一个奇数 其中 $2^k | \min{a_i}$</p>
<p>这样也一定无解</p>
<h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>读题大失败</p>
<p>其实就是把一个区间划分成若干互质的区间</p>
<p>考虑对每个数预处理出来后面的能向后延伸的最大的互质长度，然后倍增去跳就行</p>
<h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>咕，之后补</p>
]]></content>
      <categories>
        <category>Codeforces</category>
        <category>Virtual participation</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.04.20模拟赛</title>
    <url>/2021/04/28/2021-04-20%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>很久之前的东西</p>
<span id="more"></span>

<h2 id="2021-04-20-模拟赛"><a href="#2021-04-20-模拟赛" class="headerlink" title="2021.04.20 模拟赛"></a>2021.04.20 模拟赛</h2><p>越来越菜</p>
<h3 id="T1-越野赛车问题"><a href="#T1-越野赛车问题" class="headerlink" title="T1 越野赛车问题"></a>T1 越野赛车问题</h3><p><a href="https://sjzezoj.com/problem/347">题面</a></p>
<p><del>矩阵乘写挂也有五十()</del></p>
<p>虽然有线段树分治+并查集的解法，不过个人感觉DDP比较好想</p>
<p>其实题目就是说一个树每个边在 $l_i$ 出现 $r_i$ 消失，时刻 $v$ 的直径</p>
<p>DDP的话</p>
<p>设 $dp_{x,1}$ 表示 $x$ 的子树内直径长度，$dp_{x,0}$ 表示起点为 $x$ 的最长链</p>
<p>$dp_{x,1}=\max\{\max\limits_{y\in son(x)}dp_{y,1},\max\limits_{y,z \in son(x)}dp_{y,0}+dp_{z,0}\}$</p>
<p>$dp_{x,0}=\max\limits_{y\in son(x)}\{dp_{y,0}\}+1$</p>
<p>DDP套路，设</p>
<p>$g_{x,0}=\max\limits_{y\in light(x)}dp_{y,0}$<br>$g_{x,1}=\max\{\max\limits_{y\in light(x)}dp_{y,1},\max\limits_{y,z\in light(x)}dp_{y,0}+dp_{z,0}\}$</p>
<p>于是</p>
<p>$dp_{x,0}=\max\{g_{x,0}+dp_{son,0}\}+1$<br>$dp_{x,1}=\max\{dp_{son,1},g_{x,1},dp_{son,0}+g_{x,0}\}$</p>
<p>转移为<br>$\begin{bmatrix}\begin{array}{c}1 &amp; -\infty &amp; g_{x,0}+1\\g_{x,0} &amp; 0 &amp;g_{x,1}\\-\infty &amp; -\infty &amp; 0\end{array}\end{bmatrix}\begin{bmatrix}\begin{array}{c}dp_{son,0}\\dp_{son,1}\\0\end{array}\end{bmatrix}=\begin{bmatrix}\begin{array}{c}dp_{x,0}\\dp_{x,1}\\0\end{array}\end{bmatrix}$</p>
<p>对于 $g_{x,0/1}$的维护需要开两个可删堆</p>
<p>一个记录 $dp_{x,0}$ 一个 $dp_{x,1}$，都只维护轻儿子</p>
<p>$g_{x,0}$ 是第一个里最大的</p>
<p>$g_{x,1}$ 是第二个最大的或者第一个前两个数</p>
<p>复杂度$O(n\log^2n)$ LCT可优化为 $O(n\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">70005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> x[N], y[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DelHeap</span> &#123;</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; q, p;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; !p.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">top</span>() == p.<span class="built_in">top</span>())</span><br><span class="line">            q.<span class="built_in">pop</span>(), p.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        p.<span class="built_in">push</span>(x), <span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, l, r;</span><br><span class="line">    <span class="keyword">int</span> nxt;</span><br><span class="line">&#125; edge[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    edge[++ecnt].v = v;</span><br><span class="line">    edge[ecnt].l   = l;</span><br><span class="line">    edge[ecnt].r   = r;</span><br><span class="line">    edge[ecnt].nxt = head[u];</span><br><span class="line">    head[u]        = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> DDP &#123;</span><br><span class="line">DelHeap q1[N], q2[N];</span><br><span class="line"><span class="keyword">int</span> leaf[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g0</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q1[x].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1[x].<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = q2[x].<span class="built_in">empty</span>() ? <span class="number">0</span> : q2[x].<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, tmp;</span><br><span class="line">    <span class="keyword">if</span> (q1[x].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = q1[x].<span class="built_in">top</span>();</span><br><span class="line">    q1[x].<span class="built_in">pop</span>();</span><br><span class="line">    tmp = sum;</span><br><span class="line">    <span class="keyword">if</span> (!q1[x].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        sum += q1[x].<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    q1[x].<span class="built_in">push</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(sum, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> top[N], fa[N], dep[N], son[N], siz[N], id[N], pos[N], tim;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    dep[x] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    fa[x]  = f;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">        <span class="keyword">if</span> (v == f) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs1</span>(v, x);</span><br><span class="line">        siz[x] += siz[v];</span><br><span class="line">        <span class="keyword">if</span> (siz[v] &gt; siz[son[x]]) &#123;</span><br><span class="line">            son[x] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">    top[x]   = topf;</span><br><span class="line">    id[x]    = ++tim;</span><br><span class="line">    pos[tim] = x;</span><br><span class="line">    <span class="keyword">if</span> (!son[x]) &#123;</span><br><span class="line">        leaf[x] = x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line">    leaf[x] = leaf[son[x]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">        <span class="keyword">if</span> (v == fa[x] || v == son[x]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *<span class="keyword">operator</span>[](<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[x];</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(Matrix b) &#123;</span><br><span class="line">        Matrix res = <span class="built_in">Matrix</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                res[i][j] = -(<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                    res[i][j] = <span class="built_in">max</span>(res[i][j], a[i][k] + b[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="keyword">namespace</span> SegmentTree &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line">Matrix tr[N * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    tr[rt].a[<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">g0</span>(x);</span><br><span class="line">    tr[rt].a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    tr[rt].a[<span class="number">1</span>][<span class="number">2</span>] = <span class="built_in">g1</span>(x);</span><br><span class="line">    tr[rt].a[<span class="number">2</span>][<span class="number">0</span>] = -INF;</span><br><span class="line">    tr[rt].a[<span class="number">2</span>][<span class="number">1</span>] = -INF;</span><br><span class="line">    tr[rt].a[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tr[rt][<span class="number">0</span>][<span class="number">0</span>] = -INF;</span><br><span class="line">        tr[rt][<span class="number">0</span>][<span class="number">1</span>] = -INF;</span><br><span class="line">        tr[rt][<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">init</span>(rt, pos[l]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(rt * <span class="number">2</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rt * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    tr[rt] = tr[rt * <span class="number">2</span>] * tr[rt * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">return</span> tr[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (R &lt;= mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(rt * <span class="number">2</span>, l, mid, L, R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (L &gt; mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(rt * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(rt * <span class="number">2</span>, l, mid, L, R) * <span class="built_in">query</span>(rt * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (w[pos[l]]) &#123;</span><br><span class="line">            tr[rt][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            tr[rt][<span class="number">0</span>][<span class="number">1</span>] = -INF;</span><br><span class="line">            tr[rt][<span class="number">0</span>][<span class="number">2</span>] = <span class="built_in">g0</span>(pos[l]) + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tr[rt][<span class="number">0</span>][<span class="number">0</span>] = -INF;</span><br><span class="line">            tr[rt][<span class="number">0</span>][<span class="number">1</span>] = -INF;</span><br><span class="line">            tr[rt][<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">init</span>(rt, pos[l]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) &#123;</span><br><span class="line">        <span class="built_in">update</span>(rt * <span class="number">2</span>, l, mid, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">update</span>(rt * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, x);</span><br><span class="line">    &#125;</span><br><span class="line">    tr[rt] = tr[rt * <span class="number">2</span>] * tr[rt * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace SegmentTree</span></span><br><span class="line"><span class="function">Matrix <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SegmentTree::<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[leaf[x]]) * <span class="built_in">Matrix</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    w[x] = k;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != <span class="number">1</span>) &#123;</span><br><span class="line">        Matrix tmp1 = <span class="built_in">query</span>(top[x]);</span><br><span class="line">        SegmentTree::<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x]);</span><br><span class="line">        Matrix tmp2 = <span class="built_in">query</span>(top[x]);</span><br><span class="line">        x           = fa[top[x]];</span><br><span class="line">        q1[x].<span class="built_in">del</span>(tmp1[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        q1[x].<span class="built_in">push</span>(tmp2[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        q2[x].<span class="built_in">del</span>(tmp1[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        q2[x].<span class="built_in">push</span>(tmp2[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    SegmentTree::<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x]);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; p[N];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    SegmentTree::<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[i]; j; j = edge[j].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[j].v;</span><br><span class="line">            <span class="keyword">if</span> (fa[i] == v) &#123;</span><br><span class="line">                p[edge[j].l].<span class="built_in">push_back</span>(i);</span><br><span class="line">                p[edge[j].r].<span class="built_in">push_back</span>(-i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : p[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">update</span>(x, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = <span class="built_in">query</span>(<span class="number">1</span>)[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : p[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">update</span>(-x, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace DDP</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">add</span>(u, v, l, r);</span><br><span class="line">        <span class="built_in">add</span>(v, u, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    DDP::<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours</span></span><br></pre></td></tr></table></figure>

<h3 id="T2-方舟系统"><a href="#T2-方舟系统" class="headerlink" title="T2 方舟系统"></a>T2 方舟系统</h3><p><a href="https://sjzezoj.com/problem/348">题面</a></p>
<p>考虑朴素 dp : $dp_i = \min\limits_{i&lt;j\le n+1}\{dp_j+|a_i-(j-i-1)|\}$</p>
<p>绝对值很难看，拆开</p>
<p>$dp_i\ =\min\limits_{i&lt; j\le n+1}\begin{cases}<br>dp_j-j+(a_i+i+1)&amp;a_i+i+1\ge j\<br>dp_j+j-(a_i+i+1)&amp;a_i+i+1&lt; j<br>\end{cases}$</p>
<p>分别用树状数组/线段树维护两个区间最小值</p>
<p>复杂度 $O(n\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> c[N];</span><br><span class="line">    <span class="built_in">BIT</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(c, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt;= n) &#123;</span><br><span class="line">            c[pos] = <span class="built_in">min</span>(c[pos], v);</span><br><span class="line">            pos += <span class="built_in">lowbit</span>(pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line">        <span class="keyword">while</span> (pos) &#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res, c[pos]);</span><br><span class="line">            pos -= <span class="built_in">lowbit</span>(pos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; d1, d2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    d1.<span class="built_in">update</span>(n - a[<span class="number">1</span>], a[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    d2.<span class="built_in">update</span>(a[<span class="number">1</span>] + <span class="number">1</span>, -a[<span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minv1 = d1.<span class="built_in">query</span>(n - i + <span class="number">1</span>), minv2 = d2.<span class="built_in">query</span>(i);</span><br><span class="line">        dp[i] = <span class="built_in">min</span>(minv1 - i, minv2 + i);</span><br><span class="line">        d1.<span class="built_in">update</span>(n - a[i] - i + <span class="number">1</span>, dp[i - <span class="number">1</span>] + a[i] + i);</span><br><span class="line">        d2.<span class="built_in">update</span>(a[i] + i, dp[i - <span class="number">1</span>] - a[i] - i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T3-椅子"><a href="#T3-椅子" class="headerlink" title="T3 椅子"></a>T3 椅子</h3><p><a href="https://sjzezoj.com/problem/349">题面</a></p>
<p>[原题]([AT2645 <a href="https://www.luogu.com.cn/problem/AT2645">ARC076D] Exhausted? - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>)</p>
<p>大力贪心</p>
<p>如果仅有 $l_i$ 的限制显然很好做，贪心扫一遍</p>
<p>加上 $r_i$ 后需要反悔，替换的时候必然是把 $r_i$ 最小的扔出去，因为他能坐的位置更多</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, ans, qp[N], cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">&#125; a[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Data &amp;A, <span class="keyword">const</span> Data &amp;B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.l != B.l) &#123;</span><br><span class="line">        <span class="keyword">return</span> A.l &lt; B.l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A.r &gt; B.r;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i].l &gt;&gt; a[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>, t = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(a[i].r);</span><br><span class="line">        <span class="keyword">if</span> (h &lt;= t &amp;&amp; h &lt;= a[i].l) &#123;</span><br><span class="line">            h++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            qp[++cnt] = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(qp + <span class="number">1</span>, qp + cnt + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h &lt;= t &amp;&amp; qp[i] &lt;= t) &#123;</span><br><span class="line">            t--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>动态DP</tag>
        <tag>贪心</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.04.19模拟赛</title>
    <url>/2021/04/28/2021-04-19%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>很久之前的东西</p>
<span id="more"></span>

<h2 id="2021-04-19-模拟赛"><a href="#2021-04-19-模拟赛" class="headerlink" title="2021.04.19 模拟赛"></a>2021.04.19 模拟赛</h2><h3 id="T1-青蛙"><a href="#T1-青蛙" class="headerlink" title="T1 青蛙"></a>T1 青蛙</h3><p><a href="https://sjzezoj.com/problem/344">题面</a></p>
<p>求第 $k$ 大这个操作可以类似滑动窗口一个个扫过去</p>
<p>求完之后就是置换的 $m$ 次幂，$m$ 不太大所以完全可以倍增水过去（需要滚动数组一下） $O(n\log n)$</p>
<p>如果很大可以考虑找环，找到之后减去柄长模环，复杂度 $O(n)$</p>
<p>倍增写法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">ll m;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> pos[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;n, &amp;k, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">        ans[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    ll l = <span class="number">1</span>, r = k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n &amp;&amp; a[r + <span class="number">1</span>] - a[i] &lt; a[i] - a[l]) &#123;</span><br><span class="line">            l++;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        pos[i][<span class="number">0</span>] = (a[r] - a[i] &gt; a[i] - a[l] ? r : l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; (<span class="number">1ll</span> &lt;&lt; i) &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = (i &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (m &amp; (<span class="number">1ll</span> &lt;&lt; i)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                ans[j] = pos[ans[j]][now];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            pos[j][now ^ <span class="number">1</span>] = pos[pos[j][now]][now];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours</span></span><br></pre></td></tr></table></figure>

<h3 id="T2-环"><a href="#T2-环" class="headerlink" title="T2 环"></a>T2 环</h3><p><a href="https://sjzezoj.com/problem/345">题面</a></p>
<p>看起来就很差分约束，如果固定了长度判断有解就按照限制连边，正整数的限制意味着 $i \rightarrow i+1$ 至少是 $1$ ，还需要按是否跨过零点分类讨论一下</p>
<p>二分一个答案区间不太现实，考虑二分上下界，那我们需要知道某个条件下需要向大还是向小调整</p>
<p>如果无解肯定是负环，我们希望知道负环上每个边的与总长度的关系</p>
<p>即当总长度变大/小时它怎么变，变大变小分别记作 $1,-1$，无关为 $0$，如果这些和是正的说明需要调大总长度才能无负环，反之同理</p>
<p>这样就能二分出上下界</p>
<p>复杂度 $O(n^2\log w)$</p>
<p>还没码</p>
<h3 id="T3-小基的高智商测试"><a href="#T3-小基的高智商测试" class="headerlink" title="T3 小基的高智商测试"></a>T3 小基的高智商测试</h3><p><a href="https://sjzezoj.com/problem/346">题面</a></p>
<p>阅读理解题</p>
<p>先把相等的点用并查集放一起，然后按小于连边</p>
<p>先排除掉环一类的无解情况，剩下的就是一个森林</p>
<p>连上一个虚点就能得到一个树，一开始以为是拓扑序计数，发现这个同一层的点是可以相等的</p>
<p>考虑直接钦定排名，相等的拿到同一个排名</p>
<p> 令 $f_i$ 表示用 $1\sim i$ 的数字分配排名的方案数，那么树上DP</p>
<p>设 $dp_{x,i}$ 为 $x$ 的子树用 $1 \sim i$ 的分配方案，于是 $dp_{x,i}=dp_{x,i-1}+\prod\limits_{v\in son(x)}dp_{v,j-1}$</p>
<p>即分配 $1\sim j-1$ 的方案和钦定自己分配 $j$ 的方案</p>
<p>但是发现这么定义的问题是可能有的排名没分配出去，二项式反演一下解决</p>
<p>即 $f_i=\sum\binom{i}{j}g_j \Rightarrow g_i=\sum(-1)^j\binom{i}{j}f_{i-j}$</p>
<p>复杂度 $O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5005</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Type</span> &#123;</span></span><br><span class="line">    VOID = <span class="number">-1</span>,</span><br><span class="line">    Equal,</span><br><span class="line">    Less,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Oper</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    Type typ;</span><br><span class="line">&#125; q[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> nxt;</span><br><span class="line">&#125; edge[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edge[++ecnt].v = v;</span><br><span class="line">    edge[ecnt].nxt = head[u];</span><br><span class="line">    head[u]        = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x     = <span class="built_in">find</span>(x);</span><br><span class="line">    y     = <span class="built_in">find</span>(y);</span><br><span class="line">    fa[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            res = res * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">ll fac[N], ifac[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i)</span><br><span class="line">        fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    ifac[n + <span class="number">1</span>] = <span class="built_in">qpow</span>(fac[n + <span class="number">1</span>], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        ifac[i] = <span class="number">1ll</span> * ifac[i + <span class="number">1</span>] * (<span class="number">1ll</span> * i + <span class="number">1ll</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> in[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">bool</span> G[N][N];</span><br><span class="line"><span class="keyword">bool</span> vis[N], flag = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x]  = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[x][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                dp[x][j] = <span class="number">1ll</span> * dp[x][j] * dp[v][j - <span class="number">1</span>] % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[x][i] = (<span class="number">1ll</span> * dp[x][i] + <span class="number">1ll</span> * dp[x][i - <span class="number">1</span>] % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[x][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * fac[n] * ifac[m] % mod * ifac[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">char</span> rub[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; q[i].u &gt;&gt; rub &gt;&gt; q[i].v;</span><br><span class="line">        <span class="keyword">if</span> (rub[<span class="number">0</span>] == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">            q[i].typ = Equal;</span><br><span class="line">            <span class="built_in">merge</span>(q[i].u, q[i].v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            q[i].typ = Less;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].typ == Equal) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">find</span>(q[i].u), y = <span class="built_in">find</span>(q[i].v);</span><br><span class="line">        <span class="keyword">if</span> (!G[x][y]) &#123;</span><br><span class="line">            <span class="built_in">add</span>(x, y);</span><br><span class="line">            G[x][y] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        in[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> QAQ = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i) == i &amp;&amp; in[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">0</span>, i);</span><br><span class="line">            QAQ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[<span class="built_in">find</span>(i)]) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                ans = (ans + mod - (<span class="number">1ll</span> * <span class="built_in">C</span>(i, j) % mod * dp[<span class="number">0</span>][i - j]) % mod) %</span><br><span class="line">                      mod;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = (ans + <span class="number">1ll</span> * <span class="built_in">C</span>(i, j) % mod * dp[<span class="number">0</span>][i - j] % mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>差分约束</tag>
        <tag>DP</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵玩小凹</title>
    <url>/2021/04/28/%E7%9F%A9%E9%98%B5%E7%8E%A9%E5%B0%8F%E5%87%B9/</url>
    <content><![CDATA[<h4 id="【集训队作业2018】矩阵玩小凹"><a href="#【集训队作业2018】矩阵玩小凹" class="headerlink" title="【集训队作业2018】矩阵玩小凹"></a>【集训队作业2018】矩阵玩小凹</h4><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>一个$n\times m$的矩阵$A_{n,m}$，其中的元素是$[0,1]$中的随机实数，设$s_i=\sum A_{i,j}$求$Ex(\lfloor\min s_i\rfloor^k)$</p>
<span id="more"></span>

<p>(因为没发现能交的地方，random了几组数据放在了<a href="https://www.luogu.com.cn/problem/U155544">矩阵玩小凹</a>上（并不保证写对了）)</p>
<h4 id="解："><a href="#解：" class="headerlink" title="解："></a>解：</h4><p>因为每一行本质相同，所以我们只考虑第一行</p>
<p>记$f_i$为$\lfloor s_1 \rfloor=i$的概率，$d_i$是$\lfloor\min(s_i)\rfloor=i$的概率，那么答案就是$\sum\limits_{i=1}^{m-1}i^kd_i$</p>
<p>同时$d_i=(\sum\limits_{j=i}^{n} f_j)^n-(\sum\limits_{j=i+1}^{n}f_j)^n$</p>
<p>这都是好算的，我们考虑$f_i$怎么算</p>
<p>记$g_i=\sum_{j=1}^{i}A_{1,j}-\lfloor\sum_{j=1}^{i}A_{1,j}\rfloor$，容易发现这也是$[0,1]$内随机生成的</p>
<p>那么$\lfloor s_1\rfloor=\sum\limits_{i=2}^m[g_i&lt;g_{i-1}]$</p>
<p>因为如果当前的$g_i$小于上一个$g_{i-1}$说明一定“溢出”了一个整数位（因为$A_{i,j}\in[0,1]$）</p>
<p>也就是说$f_i$就是随机$[0,1]$排列种上升的位置有$i$个的概率（这里我们忽略了存在相同的数字，因为在实数里随机出两个同样的数字的概率基本无）</p>
<p>那这个东西，我们把随机排列$n$中有$i$个上升位置的方案数</p>
<p>就是欧拉数$\left\langle\begin{matrix}n \ i\end{matrix}\right\rangle$</p>
<p>实际上我们有$\left\langle\begin{matrix}n \ i\end{matrix}\right\rangle=\sum(-1)^{i}\binom{n+1}{i}(m-i+1)^n$</p>
<p>证明有亿点难</p>
<p>对于$x_1+x_2+\dots+x_n \le x \quad x_i \ge 0$的超立方体体积记作$V_n(x)$</p>
<p>容易发现$h_1(x)=x$</p>
<p>$V_i(x)=\int_0^nh_{i-1}(t)\rm{d}t$</p>
<p>并不需要技巧就能得出$V_i(n)=\frac{n^i}{i!}$</p>
<p>考虑最原始的含义，$\sum\limits_{i=0}^m\left\langle\begin{matrix}n \ i\end{matrix}\right\rangle$就是$\lfloor s_1\rfloor\le i+1$的概率，容斥$x&gt; 1$的个数（因为$A_{i,j}\in[0,1]$），那么</p>
<p>$\sum\limits_{i=0}^m\left\langle\begin{matrix}n \ i\end{matrix}\right\rangle=\sum\limits_{i=0}^{m+1}(-1)^i\binom{n}{i}V_n(m-i+1)$</p>
<p>差分一下就能得到$\left\langle\begin{matrix}n \ i\end{matrix}\right\rangle=\sum(-1)^{i}\binom{n+1}{i}(m-i+1)^n$</p>
<p>这个是$i^n$与$(-1)^i\binom{n+1}{i}$的卷积，NTT $O(n\log n)$解决</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>烷基计数</title>
    <url>/2021/04/28/%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<p>Polya的奇怪应用</p>
<p>Update：真的polya定理</p>
<span id="more"></span>

<h3 id="烷基计数"><a href="#烷基计数" class="headerlink" title="烷基计数"></a>烷基计数</h3><p>参考：<a href="https://tieba.baidu.com/p/4929845825?red_tag=2138002071">神仙的化学计数</a></p>
<p>给出一个比较通用的计数方法</p>
<p>定义$Z(G)$为有限置换群$G$的循环指数，$Z(G)=\frac{1}{|G|}\sum\limits_{g\in G}\prod\limits_rs_r^{c_r(g)}$，这是一个关于$s_i$的多项式</p>
<p>$c_r(g)$是$g$的循环分解中有$r$个元素的循环，也就是将$g$循环分解表示加起来</p>
<p>比如$Z(S_3)=\frac{1}{6}(2s_3+3s_2s_1+s_1^3)$ (如果考虑手性就是群$\mathfrak{A}_3$)</p>
<p>而如果我们把$s_i$用多项式$\mathbb{Z}[x^r]$代替就是$Z(S_3,F(x))=\frac{1}{6}(2F(x^3)+3F(x^2)F(x)+F^3(x))$  （这其实就是真的Polya定理</p>
<p>考虑烷基计数</p>
<p>拆去第一个碳原子，剩下的取代基可以自由分配，所以其生成函数$F(x)=1+xZ(s_3,F(X))=1+\frac{x}{6}[2F(x^3)+3F(x^2)F(x)+F^3(x)]$</p>
<p>可以分治NTT或者牛顿迭代</p>
<p>选择不用脑子的牛顿迭代</p>
<p>$G(F(X))=1+\frac{x}{6}[2F(x^3)+3F(x^2)F(x)+F^3(x)]-F(x)$</p>
<p>设已经求出$H(x)$满足$G(H(x))\equiv0\pmod{ x^{\frac{n}{2}}}$</p>
<p>那么$F(x)=H(x)-\frac{G(H(x))}{G’(H(x))}$</p>
<p>$G’(H(x))$中因为已知可以当作常数$G’(H(x))=x\frac{3H(x)^2+3H(x^2)}{6}-1$</p>
<p>带入$F(X)=H(x)-\frac{6-x(H(x)^3+3H(x^2)H(x)+2H(x^3))-6H(x)}{3x(H(x)^2+H(x^2))-6}$</p>
<p>实际上这个方法像<a href="https://www.luogu.com.cn/problem/P6597">烯烃</a>/<a href="https://www.luogu.com.cn/problem/P6598">烷烃</a>计数都通用的，但是我懒得再写了</p>
<p>Tips:烷烃的话答案是</p>
<p>$G(x)=x[\frac{1}{24}F^4(x)+\frac 14 F^2(x)F(x^2)+\frac{1}{8}F^2(x^2)+\frac{1}{3}F(x)F(x^3)+\frac 14 F(x^4)]-\frac 12 F^2(x)+\frac 12 F(x^2)+F(x)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;dbg&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> ll G = <span class="number">3</span>, invG = <span class="number">332748118</span>;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;ll&gt; poly;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e6</span> + <span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> rev[N];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            res = res * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(poly &amp;a, <span class="keyword">int</span> len, <span class="keyword">int</span> typ)</span> </span>&#123;</span><br><span class="line">    a.<span class="built_in">resize</span>(len);</span><br><span class="line">    <span class="keyword">int</span> lim = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid *= <span class="number">2</span>) &#123;</span><br><span class="line">        ll wn = <span class="built_in">qpow</span>(typ == <span class="number">1</span> ? G : invG, (mod - <span class="number">1</span>) / (mid * <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += mid * <span class="number">2</span>) &#123;</span><br><span class="line">            ll w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k++) &#123;</span><br><span class="line">                ll x = a[j + k], y = w * a[j + k + mid] % mod;</span><br><span class="line">                a[j + k]       = (x + y) % mod;</span><br><span class="line">                a[j + k + mid] = (x - y + mod) % mod;</span><br><span class="line">                w              = w * wn % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (typ == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> invdeg = <span class="built_in">qpow</span>(lim, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) &#123;</span><br><span class="line">        a[i] = a[i] * invdeg % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll W[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        W[i]  = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> w = <span class="built_in">qpow</span>(<span class="number">3</span>, (mod - <span class="number">1</span>) / (i * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            W[i + j] = (ll)W[i + j - <span class="number">1</span>] * w % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLen</span><span class="params">(<span class="keyword">int</span> deg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt; deg) &#123;</span><br><span class="line">        len *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getRev</span><span class="params">(<span class="keyword">int</span> deg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i++) &#123;</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) ? (deg &gt;&gt; <span class="number">1</span>) : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PrepareNTT</span><span class="params">(<span class="keyword">int</span> deg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="built_in">getLen</span>(deg);</span><br><span class="line">    <span class="built_in">getRev</span>(L);</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line">poly _mul(<span class="keyword">const</span> poly &amp;a, <span class="keyword">const</span> poly &amp;b) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">poly <span class="title">res</span><span class="params">(len)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        res[i] = a[i] * b[i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">poly <span class="keyword">operator</span>-(<span class="keyword">const</span> poly &amp;a) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">poly <span class="title">res</span><span class="params">(len)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        res[i] = (mod - a[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">poly <span class="keyword">operator</span>+(<span class="keyword">const</span> poly &amp;a, <span class="keyword">const</span> poly &amp;b) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">poly <span class="title">res</span><span class="params">(len)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        res[i] = a[i] + b[i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">poly <span class="keyword">operator</span>-(<span class="keyword">const</span> poly &amp;a, <span class="keyword">const</span> poly &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + -b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">poly <span class="title">inv</span><span class="params">(poly a)</span> </span>&#123;</span><br><span class="line">    poly res, inv_a;</span><br><span class="line">    res.<span class="built_in">resize</span>(<span class="number">1</span>);</span><br><span class="line">    res[<span class="number">0</span>]  = <span class="built_in">qpow</span>(a[<span class="number">0</span>], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> lim = <span class="built_in">getLen</span>(a.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= lim; len *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">PrepareNTT</span>(len + len);</span><br><span class="line">        inv_a = a;</span><br><span class="line">        inv_a.<span class="built_in">resize</span>(n);</span><br><span class="line">        res.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; n; i++) &#123;</span><br><span class="line">            inv_a[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NTT</span>(inv_a, n, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NTT</span>(res, n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res[i] = <span class="number">1ll</span> * (<span class="number">2ll</span> - <span class="number">1ll</span> * inv_a[i] * res[i] % mod + mod) % mod *</span><br><span class="line">                     res[i] % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NTT</span>(res, n, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; n; i++) &#123;</span><br><span class="line">            res[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="built_in">resize</span>(a.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace Poly</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Poly;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    poly c(1, 1), hx2, hx3, p, q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt; n; len *= <span class="number">2</span>) &#123;</span><br><span class="line">        hx2 = hx3 = <span class="built_in">poly</span>(len * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">            hx2[j &lt;&lt; <span class="number">1</span>] = c[j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j * <span class="number">3</span> &lt; <span class="number">2</span> * len; j++)</span><br><span class="line">            hx3[j * <span class="number">3</span>] = c[j];</span><br><span class="line">        <span class="built_in">PrepareNTT</span>(len * <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">NTT</span>(c, len * <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NTT</span>(hx2, len * <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NTT</span>(hx3, len * <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        p = q = <span class="built_in">poly</span>(len * <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (len * <span class="number">4</span>); j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = j &lt; (len * <span class="number">2</span>) ? W[len * <span class="number">2</span> | j] : mod - W[len * <span class="number">2</span> | j];</span><br><span class="line">            q[j] =</span><br><span class="line">                (<span class="number">3ll</span> * w * ((<span class="built_in">ll</span>(c[j]) * c[j] % mod + hx2[j]) % mod) + mod - <span class="number">6</span>) %</span><br><span class="line">                mod;</span><br><span class="line">            p[j] = (w *</span><br><span class="line">                        ((<span class="built_in">ll</span>(c[j]) * c[j] % mod * c[j] +</span><br><span class="line">                          <span class="number">3ll</span> * hx2[j] * c[j] % mod + <span class="number">2ll</span> * hx3[j]) %</span><br><span class="line">                         mod) %</span><br><span class="line">                        mod +</span><br><span class="line">                    (mod - <span class="number">6ll</span>) * c[j] % mod + <span class="number">6ll</span>) %</span><br><span class="line">                   mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NTT</span>(p, len * <span class="number">4</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">NTT</span>(q, len * <span class="number">4</span>, <span class="number">-1</span>);</span><br><span class="line">        q.<span class="built_in">resize</span>(len * <span class="number">2</span>);</span><br><span class="line">        q = <span class="built_in">inv</span>(q);</span><br><span class="line">        p.<span class="built_in">resize</span>(len * <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">NTT</span>(p, len * <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NTT</span>(q, len * <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (len * <span class="number">4</span>); j++) &#123;</span><br><span class="line">            c[j] = (c[j] + (mod - p[j]) * (ll)q[j]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NTT</span>(c, len * <span class="number">4</span>, <span class="number">-1</span>);</span><br><span class="line">        c.<span class="built_in">resize</span>(len * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">poly res;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">prework</span>(<span class="number">2e6</span> + <span class="number">10</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">solve</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>Polya</tag>
      </tags>
  </entry>
  <entry>
    <title>记一道数学题</title>
    <url>/2021/04/28/%E8%AE%B0%E4%B8%80%E9%81%93%E6%95%B0%E5%AD%A6%E9%A2%98/</url>
    <content><![CDATA[<p>来自FJOI D2T3</p>
<span id="more"></span>

<h3 id="记一道数学题"><a href="#记一道数学题" class="headerlink" title="记一道数学题"></a>记一道数学题</h3><p>$\mathrm{D} $为微分算子，即$\mathrm{D}=\dfrac{\mathrm{d}}{\mathrm{d}x}$</p>
<p>Update : 更新更简洁的生成函数做法</p>
<p>为了式子的简洁忽略掉了一些 corner case </p>
<p>省略的求和指标一般是对 $i$ 求和</p>
<p><del>（颓了节美术课就搞出来了，考的时候在干嘛淦）</del></p>
<h3 id="题"><a href="#题" class="headerlink" title="题"></a>题</h3><p>设 $a_n=\dfrac{na_{n-1}+n(n-1)a_{n-2}}{2}+(-1)^n(1-\dfrac{n}{2})$</p>
<p>求 $\sum\binom{n}{i}(n-i+1)a_i$</p>
<h3 id="OI版"><a href="#OI版" class="headerlink" title="OI版"></a>OI版</h3><p>看到类似 $n^{\underline{i-1}}a_{n-i}$ 的可以考虑除个 $n!$ 搞 EGF</p>
<p>设 $b_n=\dfrac{a_n}{n!}$</p>
<p>则 $2b_n=b_{n-1}+b_{n-2}+\dfrac{2\times(-1)^n}{n!}-\dfrac{n(-1)^n}{n!}$</p>
<p>设 $b_n$ 的生成函数是 $B(x)$</p>
<p>$n(-1)^n$ 的 EGF 就是 $x\mathrm{D} e^{-x}=-xe^{-x}$</p>
<p>则 $2B(x)=xB(x)+x^2B(x)+2e^{-x}+xe^{-x}$</p>
<p>解出来 $B(x)=\dfrac{(x+2)e^{-x}}{2-x-x^2}=\dfrac{e^{-x}}{1-x}$</p>
<p>设 $s_n=\sum\binom{n}{i}(n-i+1)a_i=\sum\binom{n}{i}(n-i)a_i+\sum\binom{n}{i}a_i$</p>
<p>考虑前一项是 ${i}$ 与 ${a_i}$ 的二项卷积，即 $x\mathrm{D} e^{x}\dfrac{e^{-x}}{1-x}=\dfrac{x}{1-x}$</p>
<p>后一项是 ${1}$ 与 ${a_i}$ 的二项卷积，即$e^x\dfrac{e^{-x}}{1-x}=\dfrac{1}{1-x}$</p>
<p>则 $s_n$ 的 EGF 为 $\dfrac{1+x}{1-x}$</p>
<p>$s_n=n![x^n]\dfrac{1+x}{1-x}=n![x^n][(1+x)(1+x+x^2)+\dots]=2n!$</p>
<h3 id="MO版"><a href="#MO版" class="headerlink" title="MO版"></a>MO版</h3><p>看到这个 $na_{n-1} \quad n(n-1)a_{n-2}$ 就先除个 $n!$ ，设 $b_n=\dfrac{a_n}{n!}$</p>
<p>$2b_n=b_{n-1}+b_{n-2}+\dfrac{2\times(-1)^n}{n!}+\dfrac{(-1)^{n-1}}{(n-1)!}$</p>
<p>$2b_{n-1}=b_{n-2}+b_{n-3}+\dfrac{2\times(-1)^{n-1}}{(n-1)!}+\dfrac{(-1)^{n-2}}{(n-2)!}$</p>
<p>加起来</p>
<p>$2b_n+b_{n-1}=2b_{n-2}+b_{n-3}+\dfrac{2\times(-1)^n}{n!}+\dfrac{(-1)^{n-1}}{(n-1)!}+\dfrac{2\times(-1)^{n-1}}{(n-1)!}+\dfrac{(-1)^{n-2}}{(n-2)!}$</p>
<p>继续拆开</p>
<p>$2b_n+b_{n-1}=\dfrac{3\times(-1)^n}{n!}+\dfrac{3\times(-1)^{n-1}}{(n-1)!}+\dfrac{3\times(-1)^{n-2}}{(n-2)!}+\dots+\dfrac{2\times(-1)^{2}}{2!}+\dfrac{(-1)^1}{1!}+2b_2+b_1$</p>
<p>设 $c_n=b_n-\sum\limits_i\dfrac{(-1)^i}{i!}$</p>
<p>对比上面的式子能发现 $2c_n+c_{n-1}=0$ 且 $c_1=0$</p>
<p>所以所有 $c_n=0$ 即 $b_n=\sum\limits_i\dfrac{(-1)^i}{i!}$</p>
<p>$\binom{n}{i}a_i=n^{\underline{i}}b_i=n^{\underline{i}}\sum\limits_j\dfrac{(-1)^j}{j!}$</p>
<p>原式为 $\sum(n-i+1)n^{\underline{i}}\sum\limits_j \dfrac{(-1)^j}{j!}=\sum (n^{\underline{i+1}}+n^{\underline{i}})\sum\limits_j \dfrac{(-1)^j}{j!}$</p>
<p>考虑 $n^{\underline{i}}=\mathrm{D}^i x^n\big|_{x=1}$</p>
<p>则 $\sum (n^{\underline{i+1}}+n^{\underline{i}})\sum\limits_j \dfrac{(-1)^j}{j!}=(\sum(1+\mathrm{D})\mathrm{D}^i\sum\limits_j\dfrac{(-1)^j}{j!}x^n)\Big|_{x=1}$</p>
<p>$=((1+\mathrm{D})\sum\mathrm{D}^i\sum\limits_{j}\dfrac{(-1)^j}{j!})x^n\Big|_{x=1}$</p>
<p>交换求和 省略 $\big|_{x=1}$</p>
<p>$(1+\mathrm{D})\sum\limits_{j} \dfrac{(-1)^j}{j!}\sum\limits_{i \ge j} \mathrm{D}^ix^n=(1+\mathrm{D})\sum\limits_j \dfrac{(-1)^j}{j!}\dfrac{\mathrm{D}^j}{1-\mathrm{D}}x^n$ （没错就是可以把微分算子当作一个字母处理）</p>
<p>干掉求和号</p>
<p>$\dfrac{1+\mathrm{D}}{1-\mathrm{D}}e^{-\mathrm{D}} x^n$</p>
<p>$\dfrac{1+\mathrm{D}}{1-\mathrm{D}}(x-1)^n=\dfrac{1+\mathrm{D}}{1-\mathrm{D}}x^n\big|_{x=0}=2n!$ （就是对 $\mathrm{D}$ 展开了幂级数）</p>
<p>所以原式 $=2n!$</p>
<p><strong>Asusetic eru quionours</strong></p>
]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>高效因子分解</title>
    <url>/2021/04/28/%E9%AB%98%E6%95%88%E5%9B%A0%E5%AD%90%E5%88%86%E8%A7%A3/</url>
    <content><![CDATA[<p>本文主要包括了一些常见和不常见的高效因子分解算法，重点在于椭圆曲线法的讲解（虽然Dixon’s 的篇幅更多一些貌似）</p>
<span id="more"></span>

<p>主要参考为 Wikipedia 的 Integer Factorization 页面</p>
<p>Warning:多项内容需修正</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>质因数分解一直是一个密码学领域相当热门的话题，因为他直接关系着 RSA 等使用大素数相乘来加密的算法的安全性</p>
<p>相比于</p>
<ul>
<li><p>求素数（筛法或者特殊的生成法）</p>
</li>
<li><p>素性测验(能做到$O((\log n))^{6+\epsilon}$)</p>
</li>
<li><p>素数计数（求$[1,n]$的素数个数，可以使用Meissel-Lehmer在亚线性复杂度内求解）</p>
</li>
</ul>
<p>因数分解一直是一个很困难的内容</p>
<p>现有的对于一般数字分解的最好算法是GNFS（General Number Field Sieve，一般数域筛）的复杂度为$L_n[\frac{1}{3},\sqrt[3]{\frac{64}{9}}]=\exp((\sqrt[3]{\frac{64}{9}}+o(1)(\ln n)^\frac{1}{3}(\ln\ln n)^{\frac{2}{3}})$</p>
<p>能够分解上百位的合数</p>
<p>而数域筛涉及到大量的代数数论的内容，故笔者在此介绍一些更加简单易懂的算法包括 ：</p>
<p>Dixon’s ，CFRAC 和 Lanstra 椭圆曲线 算法</p>
<p>大概只需要一些基本的数论知识（和一小点群论），同时给出了一个椭圆曲线法的Python Demo</p>
<h2 id="基础的想法"><a href="#基础的想法" class="headerlink" title="基础的想法"></a>基础的想法</h2><h3 id="试除"><a href="#试除" class="headerlink" title="试除"></a>试除</h3><p>一个基础的想法是在$[2,\sqrt n]$的范围内试除，复杂度为$O(\sqrt n)$，虽然在 OI 里很多情况下都已经够用，但是对于分解数十甚至上百位整数的需求就难以接受</p>
<h3 id="Fermat"><a href="#Fermat" class="headerlink" title="Fermat"></a>Fermat</h3><p>而 Fermat 分解提供了一个新的思路</p>
<p>注意到若奇合数 $n=pq$ 那一定可以表示为两数平方差 $a^2-b^2$ 仅需取 $a=\frac{p+q}{2} \quad b=\frac{p-q}{2}$</p>
<p>变形一下得到 $a^2-n=b^2$ 那我们枚举 $a$ 测试 $a^2-n$ 是否为完全平方数即可</p>
<p>但是这样的复杂度为 $O(n)$ 甚至更慢，但是能够对更快的的质因数分解做出一定的启示</p>
<p>比如我们考虑如果放宽要求 $a^2\equiv b^2 \pmod n$ 那么$\gcd(a - b,n)$ 就很可能是一个非平凡因子</p>
<p>因为有$n|(a-b)(a+b)$，所以$\gcd(a-b,n) ,\gcd(a+b,n)$一定有一个因子 (只要不是 $a=\pm b$)</p>
<h2 id="Pollard’s-Rho算法"><a href="#Pollard’s-Rho算法" class="headerlink" title="Pollard’s Rho算法"></a>Pollard’s Rho算法</h2><p>该算法是 OI 中<strong>不</strong>常用的算法之一，但是是一个极好的高效因数分解的例子</p>
<p>Pollard’s Rho算法的思想是在接近随机的数列${x_i}:x_{i+1}= (x_i^2+c) \bmod n$</p>
<p>出现$x_a\equiv x_b\pmod n$的期望步数为$O(\sqrt n)$ （根据生日悖论）</p>
<p>而对于$n=pq$ 的 ${x_i \bmod p}$ 依然是接近随机行为的数列，同时期望为$O(\sqrt p)$</p>
<p>于是只要$x_a\ne x_b$计算$\gcd(x_a-x_b,n)$就得到了一个$n$的非平凡因子</p>
<p>于是我们得到了$O(\sqrt p)$或者说$O(n^{\frac{1}{4}})$的优秀算法</p>
<h2 id="亚指数级"><a href="#亚指数级" class="headerlink" title="亚指数级"></a>亚指数级</h2><p>$O(n^{\frac{1}{4}})$已经很快的，在 OI 中大概也是极限了（再大建议物理解决出题人）</p>
<p>但是它仍然不！够！快！</p>
<p>下面是 Linux 下 <code>factor</code> 的速度（内部实现为 Pollard’s Rho）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">time factor 60000000000000003100000000000000033</span><br><span class="line">60000000000000003100000000000000033: 200000000000000003 300000000000000011</span><br><span class="line">factor 60000000000000003100000000000000033  38.38s user 0.00s system 99% cpu 38.383 total</span><br></pre></td></tr></table></figure>

<p>可以看到分解仅 $35$ 位的合数就用了 $38$ s 这显然是不能接受的 （实际上 Linux 的跑的相当快,我写的丢人 Pollard’s Rho 跑了两分钟还没跑出来</p>
<p>而我们完全可以用 Fermat 的想法做到更快的分解速度</p>
<h3 id="Dixon’s-与-连分数-CFRAC"><a href="#Dixon’s-与-连分数-CFRAC" class="headerlink" title="Dixon’s 与 连分数 (CFRAC)"></a>Dixon’s 与 连分数 (CFRAC)</h3><p>为了方便的叙述先定义两个概念</p>
<h4 id="因子基"><a href="#因子基" class="headerlink" title="因子基"></a>因子基</h4><p>一个因子基意味前几个素数的集合${p_1,p_2,p_3,\dots}$</p>
<h4 id="L记号"><a href="#L记号" class="headerlink" title="L记号"></a>L记号</h4><p>L 记号同样是衡量时间复杂度的，$L_n[a,c]=\exp{(c+o(1)(\ln n)^a(\ln \ln n)^{1-a})}$</p>
<p>其中 $c &gt; 0,a \in [0,1]$</p>
<p>主要用来数论中算法的复杂度</p>
<h4 id="Dixon’s"><a href="#Dixon’s" class="headerlink" title="Dixon’s"></a>Dixon’s</h4><p>Dixon’s 的主要思想是：</p>
<p>选定一个大小为 $b$ 的因子基 $B$，选取一些数字$x_i$，使得 $x_i^2\bmod n=\prod p_i^{k_i}$ 的所有 $p_i \in B$ （显然不会所有的$k_i$都为偶数，否则就找到了一个$a^2\equiv b^2$）</p>
<p>然后通过奥妙重重的方法选取一系列$x_i$使得 $\prod x_i \equiv (\prod p_i^{k_i})^2 \pmod n$</p>
<p>这样我们就得到了一个$a^2 \equiv b^2 \pmod n$</p>
<p>那我们怎么才能寻找到这个奥妙重重的方法呢？</p>
<p>考虑 $\prod x_i = \prod p_i^{a_{i,1}+a_{i,2}+a_{i,3}+\dots} \pmod n$</p>
<p>令 $\vec{a_i}=(a_{i,1} \bmod 2,a_{i,2} \bmod 2, \dots ,a_{i,k} \bmod 2) \in(\mathbb{Z}_{2})^k$</p>
<p>可以用高斯消元解出来向量 $\vec{a}=(0,0,0,\dots,0) \in (\mathbb{Z}_2)^k$</p>
<p>把对应的数字乘起来即可</p>
<p>而 $x_i$ 的选取则是完全随机的（</p>
<p>大概分析下复杂度</p>
<p>对于确定的 $b=n^{-\alpha}$ 而言 找到一个合适的 $x$ 的概率大概是是 $a^{-\alpha}$ （这实际上Dickman function $\rho$ 的一个近似，之后我们会在椭圆曲线那里讨论） </p>
<p>而对于这个 $b$ 我们仅需找到 $\pi(b)$ 个 $x$ 即可总共随机约 $\exp{(\alpha+1)\ln \alpha +\frac{\ln n}{\alpha} -\ln\ln n}$ 次数 每次需要 $\pi(b)$ 次试除</p>
<p>取 $\alpha=2\sqrt{\frac{\ln n}{\ln \ln n}}$ 得到复杂度约为$L_n[\frac{1}{2},2\sqrt2]$</p>
<h3 id="连分数-CFRAC"><a href="#连分数-CFRAC" class="headerlink" title="连分数(CFRAC)"></a>连分数(CFRAC)</h3><p>笔者并没有系统的学习过连分数相关的理论，故仅在此给出简单的介绍</p>
<p>连分数因数分解实际上在 Dixon’s 上的一个优化</p>
<p>我们发现如果 $x^2 \bmod n$ 比较小的话就容易分解</p>
<p>那么用周期连分数表示 $\sqrt {kn}$ 来得到比较好的精度 这样可以做到 $L_n[\frac{1}{2},    \sqrt2]$</p>
<p>(抄的Wikipedia，如果有懂的大佬希望可以给出相关文献QAQ)</p>
<h3 id="二次筛"><a href="#二次筛" class="headerlink" title="二次筛"></a>二次筛</h3><p>二次筛法同样是对 Dixon’s 的优化，可以做到 $L_n[\frac{1}{2},1]$ 在 GNFS 之前一直是最快的因子分解算法</p>
<p>具体原理在学了，学会了也许会单独写一篇</p>
<h2 id="椭圆曲线法"><a href="#椭圆曲线法" class="headerlink" title="椭圆曲线法"></a>椭圆曲线法</h2><p>虽然椭圆曲线法同样是亚指数级别的，但是因为要给出比较详细的讲解故将其分离了出来</p>
<h3 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h3><h4 id="椭圆曲线"><a href="#椭圆曲线" class="headerlink" title="椭圆曲线"></a>椭圆曲线</h4><p><del>椭圆曲线是域上亏格为1的光滑射影曲线</del> </p>
<p>我们可以理解为形如 $y^2=x^3+ax+b$ 的曲线</p>
<h4 id="B-smooth"><a href="#B-smooth" class="headerlink" title="B-smooth"></a>B-smooth</h4><p>当我们说 $n$ 是 B-smooth 的指的是 $n$ 所有的质因子都小于等于 $B$</p>
<h4 id="B-powersmooth"><a href="#B-powersmooth" class="headerlink" title="B-powersmooth"></a>B-powersmooth</h4><p>同样的，B-powersmooth 指的是 $n$ 的任意因子的次幂不超过 $B$ 例如 $2^4 \times 3^2$ 是 16-powersmooth的</p>
<h4 id="椭圆曲线群"><a href="#椭圆曲线群" class="headerlink" title="椭圆曲线群"></a>椭圆曲线群</h4><p>我们在椭圆曲线上的点 $P,Q$ 定义加法为 $P+Q=T$，$T$是椭圆曲线上 $P,Q$ 两点连线的第三个交点的关于 $x$ 轴的对称点（这样定义是为了保持群的结构和交换）</p>
<p>定义自己加自己是沿着自己的切线的交点</p>
<p>再定义无穷远点记作$O$，容易验证椭圆曲线上的点加上点 $O$ 和加法构成结构是一个阿贝尔群，点 $O$ 是其幺元</p>
<h3 id="Pollard’s-p-1"><a href="#Pollard’s-p-1" class="headerlink" title="Pollard’s p-1"></a>Pollard’s p-1</h3><p>虽然 Pollard’s p-1 算法甚至不是正确的（不一定能得到答案）</p>
<p>但是它仍然有着借鉴意义</p>
<p>Pollard’s p-1 算法的思想是如果 $n=pq$</p>
<p>那么  $a^{k(p-1)} \equiv 1 \pmod p$ （费马小定理）</p>
<p>如果 $a$ 的 某个幂次 $k$ 是模 $n$ 的因子同余于 $1$ 那么 $\gcd(a^k-1,n)$ 大概率是一个 $n$ 的非平凡因子</p>
<p>我们选取一个 B-smooth 的数字 $M$ ，然后计算 $\gcd(x^M,n)$ 重复多次以寻找因子</p>
<p>而 $x$ 需要选取互质于 $n$ 的数字 对于奇合数来说选 $2$ 即可</p>
<h3 id="椭圆曲线法-1"><a href="#椭圆曲线法-1" class="headerlink" title="椭圆曲线法"></a>椭圆曲线法</h3><p>我们将椭圆曲线限制在有理点上，可以发现群的结构仍然保持</p>
<p>我们可以考虑有限域$\mathbb{F}_q$而非有理域，因为我们不需要有理数的结构</p>
<p>考虑椭圆曲线上的加法过程</p>
<p>令 $s=\frac{3x^2+a}{2y}$</p>
<p>则 $2(x,y)=(s^2-2x,y+s(u-x))$</p>
<p>如果我们在 $E(\mathbb{Z}/n\mathbb{Z})$ 下出现了无法除 $2y$ 的情况 ，那么我们在模 $n$ 意义下出现了不存在的逆元，也就是 $\gcd(n,t)\neq1$ 我们就大概率找到了一个因子</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li><p>选定一条曲线 $y^2=x^3+ax+b$ 与非平凡点 $P$</p>
</li>
<li><p>选定素数上界 $B$</p>
</li>
<li><p>计算 $(\prod\limits_{p_i&lt;B}p_i^{\ln B/\ln p_i})P$  （$\ln B/\ln p_i$ 是为了保证这个数 B-powersmooth）</p>
</li>
<li><p>加法过程中寻找因子</p>
</li>
</ol>
<h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>可以发现我们的基本思想是和 Pollard’s p-1 相同，只不过把乘法改成了在椭圆曲线群上的加法</p>
<p>所以它为什么比Pollard’s p-1 要好呢？</p>
<p>Pollard’s p-1 的本质在于在群 $\mathbb{Z}_q \times \mathbb{Z}_p$ 中找到了一个 $\mathbb{Z}_p$ 的幺元 $e_p$ 但是非 $\mathbb{Z}_q$ 的幺元</p>
<p>而这个群的阶 $p$ 不一定是一个 B-powersmooth 的数</p>
<p>而根据 Hasse 定理，椭圆曲线群 $|E(\mathbb{Z}/p\mathbb{Z})|\in[p+1-2\sqrt p,p+1+2\sqrt p]$</p>
<p>这样群的阶就会有变化，避免了不 powersmooth 的问题</p>
<p>进一步我们考虑曲线 $y^2=x^3+ax+b$ 分别在模 $p$ $q$ 意义下的群 $E(\mathbb{Z}/p\mathbb{Z})$ 与 $E(\mathbb{Z}/q\mathbb{Z})$ （假设 $n=pq$）</p>
<p>记他们的元素数量为 $N_q$ $N_p$ </p>
<p>根据拉格朗日定理（$|G|=[G:H]\times |H|$）若 $kP=O \pmod p$ </p>
<p>那么$N_pP=O \pmod p$</p>
<p>于是和 Pollard’s p-1 一样，如果我们找到了某个 $k$ 使得 $kP=O \pmod p$ 但不是$E(\mathbb{Z}/q\mathbb{Z})$ 中 $P$ 的阶，此时我们就找到一个因子</p>
<h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>找到一个可分解的椭圆曲线群的概率为 $B\ln^2n$</p>
<p>若设$B=p^{-a}$ 终止的概率为 $a^{-a}$</p>
<p>和 Dixon’s 一样的分析能得到复杂度大致为 $L_p[\frac{1}{2},\sqrt2]$ $p$ 为 $n$ 的最小素因子</p>
<p>可以看到椭圆曲线法的复杂度主要取决于 $n$ 的最小素因子大小而非 $n$ </p>
<p>所以椭圆曲线法可以快速去除一些小的素因子（大约 $30 \sim 40$ 位的素因子）</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>操作中选取曲线上的非平凡点这个行为可以变为随机一个点然后生成一个曲线</p>
<p>对于点 $(x,y)$ 选取一个 $a$ 计算得到 $b=y^3-x^3-ax$</p>
<h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> gcd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">EulerSieve</span>(<span class="params">n</span>):</span></span><br><span class="line">    vis = [<span class="literal">True</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    primes = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> vis[i]:</span><br><span class="line">            primes.append(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> primes:</span><br><span class="line">            <span class="keyword">if</span> i * j &gt; n:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            vis[i * j] = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> i % j == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> primes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exgcd</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, <span class="number">0</span>, a</span><br><span class="line">    q, r = <span class="built_in">divmod</span>(a, b)</span><br><span class="line">    x, y, d = exgcd(b, r)</span><br><span class="line">    <span class="keyword">return</span> y, x - q * y, d</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">elliptic_add</span>(<span class="params">p, q, a, b, m</span>):</span></span><br><span class="line">    <span class="keyword">if</span> p[<span class="number">2</span>] == <span class="number">0</span>: </span><br><span class="line">        <span class="keyword">return</span> q</span><br><span class="line">    <span class="keyword">if</span> q[<span class="number">2</span>] == <span class="number">0</span>: </span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    <span class="keyword">if</span> p[<span class="number">0</span>] == q[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">1</span>] + q[<span class="number">1</span>]) % m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        num = (<span class="number">3</span> * p[<span class="number">0</span>] * p[<span class="number">0</span>] + a) % m</span><br><span class="line">        denom = (<span class="number">2</span> * p[<span class="number">1</span>]) % m</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        num = (q[<span class="number">1</span>] - p[<span class="number">1</span>]) % m</span><br><span class="line">        denom = (q[<span class="number">0</span>] - p[<span class="number">0</span>]) % m</span><br><span class="line">    inv, _, g = modular_inv(denom, m)</span><br><span class="line">    <span class="keyword">if</span> g &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, denom  </span><br><span class="line">    z = (num * inv * num * inv - p[<span class="number">0</span>] - q[<span class="number">0</span>]) % m</span><br><span class="line">    <span class="keyword">return</span> z, (num * inv * (p[<span class="number">0</span>] - z) - p[<span class="number">1</span>]) % m, <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">elliptic_mul</span>(<span class="params">k, p, a, b, m</span>):</span></span><br><span class="line">    res = (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> p[<span class="number">2</span>] &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            res = elliptic_add(p, res, a, b, m)</span><br><span class="line">        k = k // <span class="number">2</span></span><br><span class="line">        p = elliptic_add(p, p, a, b, m)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lenstra</span>(<span class="params">n, limit</span>):</span></span><br><span class="line">    g = n</span><br><span class="line">    <span class="keyword">while</span> g == n:</span><br><span class="line">        q = randint(<span class="number">0</span>, n - <span class="number">1</span>), randint(<span class="number">0</span>, n - <span class="number">1</span>), <span class="number">1</span></span><br><span class="line">        a = randint(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">        b = (q[<span class="number">1</span>] * q[<span class="number">1</span>] - q[<span class="number">0</span>] * q[<span class="number">0</span>] * q[<span class="number">0</span>] - a * q[<span class="number">0</span>]) % n</span><br><span class="line">        g = gcd(<span class="number">4</span> * a * a * a + <span class="number">27</span> * b * b, n) </span><br><span class="line">    <span class="keyword">if</span> g &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line">    primes=EulerSieve(limit)</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> primes:</span><br><span class="line">        pp = p</span><br><span class="line">        <span class="keyword">while</span> pp &lt; limit:</span><br><span class="line">            q = elliptic_mul(p, q, a, b, n)</span><br><span class="line">            <span class="keyword">if</span> q[<span class="number">2</span>] &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> gcd(q[<span class="number">2</span>], n)</span><br><span class="line">            pp = p * pp</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    n=<span class="number">998244354</span></span><br><span class="line">    B=<span class="number">7000</span></span><br><span class="line">    curve_count=<span class="number">200</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(curve_count):</span><br><span class="line">        res=lenstra(n, B)</span><br><span class="line">        <span class="keyword">if</span> res != <span class="literal">False</span>:</span><br><span class="line">            <span class="built_in">print</span>(res)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="一些优化"><a href="#一些优化" class="headerlink" title="一些优化"></a>一些优化</h3><h4 id="B的选定"><a href="#B的选定" class="headerlink" title="B的选定"></a>B的选定</h4><p>如果定义 $\Phi(x,y)$ 为 $\le x$ 的 y-smooth 的数的个数，那么 $\Phi(x,x^{-a}) \sim x\rho(a)$</p>
<p>其中 $\rho$ 是之前提到过的 Dickman Function ，定义为 $x\rho’(x)+\rho(x-1)=0$</p>
<p>我们希望最小化 $\Phi(p,B)^{-1}\pi(B)$ 的值</p>
<p>如果采用近似 $\Phi(n,n^{-a}) \sim n\rho(a) \quad \pi(B) \sim \mathrm{Li}(B)$</p>
<p>可以用牛顿迭代一类的方法找极值，当然通常使用经验对 $30$ 位左右的数字用 $7000$ 的 B 即可</p>
<h4 id="多曲线"><a href="#多曲线" class="headerlink" title="多曲线"></a>多曲线</h4><p>我们可以一次性生成多条曲线，一起在这多条曲线上做加法，这样只要有一个曲线上找到了因子就可以退出</p>
<p>求逆元的时候也可以先求一次然后然后用乘法来算其他逆元，你一个个求要快</p>
<h4 id="蒙哥马利取模"><a href="#蒙哥马利取模" class="headerlink" title="蒙哥马利取模"></a>蒙哥马利取模</h4><p>Min_25 的博客有过介绍</p>
<p>核心步骤Reduce: （ $x \in [0,rn)$ 返回 $xn^{-1} \bmod r$）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce</span>(<span class="params">x</span>):</span></span><br><span class="line">    m=((x%n)*(inv(r)))%n</span><br><span class="line">    x=(x-m*r)//n</span><br><span class="line">    <span class="keyword">if</span> x&gt;=r:</span><br><span class="line">        <span class="keyword">return</span> x-r</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>

<p>究其本质大概是在 $n,r$ 互质的情况下映射 $f(a)=an$ 是 $\mathbb{F}_r$ 的自同态？</p>
<p>大量乘法取模的时候实际效率很高</p>
<h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><p>太菜了写不动这个东西，给一份 zball 大佬的实现，效率极高</p>
<p><a href="https://www.luogu.com.cn/paste/eha6wtkl">Here</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0.20788920s consumed</span><br><span class="line">200000000000000003 300000000000000011</span><br></pre></td></tr></table></figure>

<p>比 <code>factor</code> 快上百倍、</p>
<p>同时 wikipedia 上也列举了许多 ecm 的高效实现，可以在 <a href="https://en.wikipedia.org/wiki/Lenstra_elliptic-curve_factorization#External_links">Wikipedia</a>中查看（需独特的上网技巧）</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p><strong>Asusetic eru quionours</strong></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>TEST</title>
    <url>/2021/04/28/TEST/</url>
    <content><![CDATA[<p>测试用例</p>
<p>测试自动部署</p>
<span id="more"></span>

<p>咕咕咕</p>
<p>再次测试持续集成</p>
<p>$\vec{a_i}=(a_{i,1} \bmod 2,a_{i,2} \bmod 2, \dots ,a_{i,k} \bmod 2) \in(\mathbb{Z}_{2})^k$</p>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
        <tag>tag</tag>
      </tags>
  </entry>
  <entry>
    <title>小猪佩奇学数学</title>
    <url>/2021/04/25/%E5%B0%8F%E7%8C%AA%E4%BD%A9%E5%A5%87%E5%AD%A6%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<p>单位根反演</p>
<span id="more"></span>

<p><del>虽然说纯数学题不好，但是划着舒服</del></p>
<p>$\large\sum\binom{n}{i}p^i\lfloor\dfrac{i}{k}\rfloor$</p>
<p><del>因为我们事先知道了这是单位根反演题所以拆成能搞的形式</del></p>
<p>考虑到 $\lfloor\dfrac{i}{k}\rfloor=\sum\limits_{j\le i}[k|j]-1$</p>
<p>又 $[k|j]=\dfrac{1}{k}\sum\limits_{d \le k-1}\omega_k^{dj}$</p>
<p>带入 $\lfloor\dfrac{i}{k}\rfloor=\sum\limits_{j}\dfrac{1}{k}\sum\limits_{d}\omega^{dj}_k-1$</p>
<p>然后大力推式子</p>
<p>$\large\dfrac{1}{k}\sum\limits_{i}\binom{n}{i}p^i\sum\limits_{j}\sum\limits_{d}\omega^{dj}_k$</p>
<p>$\large = \dfrac{1}{k}\sum\limits_d\sum\limits_i\binom{n}{i}p^i\dfrac{\omega_k^{d(i+1)-1}}{\omega^d_k-1}$</p>
<p>$\large =\dfrac{1}{k}\sum\limits_d\dfrac{\sum\limits_i\binom{n}{i}(p\omega^d_k)^k-\sum\limits_i\binom{n}{i}p^i}{\omega^d_k-1}$</p>
<p>$\large\dfrac{1}{k}\sum\limits_d\dfrac{\omega_k^d(p\omega_k^d+1)^n-(p+1)^n}{\omega_k^d-1}$</p>
<p>当然最后有一个 $-(p+1)^n$</p>
<p>显然 $\omega_k$ 在 $\bmod p$ 意义下就是 $g^{\frac{p-1}{k}}$</p>
<p>还得特判 $ d=0 $ </p>
<p><strong>Asusetic eru quionours</strong></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>单位根反演</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC003D Anticube</title>
    <url>/2021/04/19/AGC003D-Anticube/</url>
    <content><![CDATA[<p>比较智慧</p>
<span id="more"></span>

<p>比较显然是事实是分解完质因数后幂次 $\bmod 3$ ，完全立方数要求所有质因子幂次之和为三的倍数，这样我们把处理过的幂次记录下来，判断一下相冲突的组哪个比较多就拿哪个</p>
<p>$10^{10}$ 级别的因子分解虽然可以大力 Pollard’s rho，但是应该没人写这个玩意</p>
<p>我们考虑因为因子幂次 $\bmod 3$ ，所以对于 $x$ 先除去 $\sqrt[3]{10^{10}}$ 以内的因子，剩下的肯定是 $pq,p^2,p$ 三者之一</p>
<p>如果这个数 $\ge10^5$ 是 $p$ 已经没意义了，因为对应的 $p^2$大于 $10^{10}$ $pq$ 同理</p>
<p>而如果这个数字不到 $10^5$ 那么不可能为 $p^2,pq$ 的形式，因为这样就有小于 $\sqrt[3]{10^{10}}$ 的因子</p>
<p>综上仅需判断是否平方数即可</p>
<p><del>不愧是智慧，完全想不到分类讨论只会大力PR</del></p>
<p><strong>Asusetic eru quionours</strong></p>
]]></content>
      <categories>
        <category>AtCoder</category>
        <category>题解</category>
        <category>AGC</category>
      </categories>
      <tags>
        <tag>分类讨论</tag>
      </tags>
  </entry>
</search>
